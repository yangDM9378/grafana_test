{"version":3,"file":"loki-query-field.9a41697f0de90f076b0a.js","mappings":"iGAEAA,EAAQ,GAAkBA,EAAQ,OAAwB,EAC1DA,EAAQ,EAAwB,CAE5BC,YAAa,6DACbC,SAAU,CACNC,YAAa,KAEjBC,SAAU,CACN,CAAC,IAAK,KACN,CAAC,IAAK,KACN,CAAC,IAAK,MAEVC,iBAAkB,CACd,CAAEC,KAAM,IAAKC,MAAO,KACpB,CAAED,KAAM,IAAKC,MAAO,KACpB,CAAED,KAAM,IAAKC,MAAO,KACpB,CAAED,KAAM,IAAKC,MAAO,KACpB,CAAED,KAAM,IAAKC,MAAO,KACpB,CAAED,KAAM,IAAKC,MAAO,MAExBC,iBAAkB,CACd,CAAEF,KAAM,IAAKC,MAAO,KACpB,CAAED,KAAM,IAAKC,MAAO,KACpB,CAAED,KAAM,IAAKC,MAAO,KACpB,CAAED,KAAM,IAAKC,MAAO,KACpB,CAAED,KAAM,IAAKC,MAAO,KACpB,CAAED,KAAM,IAAKC,MAAO,KACpB,CAAED,KAAM,IAAKC,MAAO,MAExBE,QAAS,CAAC,GAId,IAoCIC,EAAkB,CAAC,KAAM,WAEzBC,EAAsB,IAAIC,OAAOF,EAAgBG,QAAO,SAAUC,EAAMC,GAAQ,MAAO,GAAGH,OAAOE,EAAM,KAAKF,OAAOG,EAAO,IAAI,KAyB9HC,EA/De,CACf,MACA,MACA,MACA,MACA,SACA,SACA,QACA,OACA,WAuDCJ,OAnDS,CAAC,OAAQ,SAAU,SAAU,SAAU,YAoDhDA,OAjDoB,CAAC,cAAe,iBAkDpCA,OA/CqB,CACtB,kBACA,OACA,kBACA,aACA,gBACA,gBACA,gBACA,gBACA,mBACA,mBACA,qBACA,kBACA,iBACA,qBAkCCA,OAAOF,GACZV,EAAQ,GAAkB,CACtBiB,YAAY,EACZC,aAAc,GACdC,aAAc,SACdH,SAAUA,EACVI,UAjCY,CACZ,IACA,IACA,IACA,IACA,IACA,IACA,KACA,KACA,IACA,IACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,KACA,SACA,KAcAC,eAAgBV,EAEhBW,QAAS,uBACTC,QAAS,wEACTC,OAAQ,cACRC,YAAa,oBACbC,aAAc,oBACdC,UAAW,iCACXC,cAAe,mCACfC,YAAa,UAEbC,UAAW,CACPC,KAAM,CAEF,CAAC,2BAA4B,OAAQ,YAErC,CAAC,+BAAgC,OAEjC,CAAC,UAAW,WAEZ,CACI,eACA,CACIC,MAAO,CACH,YAAa,OACb,WAAY,gBAKxB,CAAC,IAAK,SAAU,kBAChB,CAAC,IAAK,SAAU,kBAChB,CAAC,IAAK,SAAU,oBAEhB,CAAEC,QAAS,eAEX,CAAC,aAAc,aACf,CAAC,mBAAoB,aACrB,CACI,WACA,CACID,MAAO,CACH,aAAc,YACd,WAAY,MAKxB,CAAC,cAAe,UAChB,CAAC,uCAAwC,gBACzC,CAAC,yCAA0C,gBAC3C,CAAC,gDAAiD,cAClD,CAAC,gCAAiC,gBAClC,CAAC,oCAAqC,iBACtC,CAAC,6BAA8B,UAC/B,CAAC,qBAAsB,WAE3BE,cAAe,CAEX,CAAC,gBAAiB,CAAEC,MAAO,WAC3B,CAAC,SAAU,UACX,CAAC,WAAY,iBACb,CAAC,MAAO,yBACR,CAAC,IAAK,SAAU,SAEpBC,cAAe,CACX,CAAC,UAAW,UACZ,CAAC,WAAY,iBACb,CAAC,MAAO,yBACR,CAAC,IAAK,SAAU,SAEpBC,gBAAiB,CAEb,CAAC,gBAAiB,CAAEF,MAAO,WAC3B,CAAC,SAAU,UACX,CAAC,WAAY,iBACb,CAAC,MAAO,yBACR,CAAC,IAAK,SAAU,SAEpBG,QAAS,CACL,CAAC,SAAU,OACX,CAAC,KAAM,aAAc,SAEzBC,WAAY,CAAC,CAAC,aAAc,W,2ICxFpC,IAAIC,EAA+D,CACjEC,eArFF,WAKE,MAAMC,EAAU,IAAIC,IAKpB,OAFAD,EAAQE,IAAI,yBAAwB,GAAKC,YAElC,CAELC,iBAAmBC,IAAiC,EACpDC,kBAAoBD,IAAiC,EACrDE,gBAAkBF,IAAiC,EAEnDG,IAAK,CAACC,EAAaC,EAAgBC,KAA+C,MAChF,OAAuB,QAAvB,EAAOX,EAAQQ,IAAIC,UAAI,QAAIE,CAAa,EAG1CC,WAAY,CAACH,EAAaC,EAAgBC,KACxC,MAAME,EAAMb,EAAQQ,IAAIC,GACxB,YAAYK,IAARD,EAGa,SAARA,EAEAF,CACT,EAGFI,UAAW,CAACN,EAAaC,EAAgBC,KACvC,MAAME,EAAMb,EAAQQ,IAAIC,GACxB,YAAYK,IAARD,EACKG,SAASH,EAAK,IAEdF,CACT,EAGFM,MAAO,CACLR,EACAS,EACAR,EACAS,KAGID,QACFlB,EAAQoB,OAAOX,GAEfT,EAAQE,IAAIO,EAAKS,EAAMf,WACzB,EAGFkB,OAAQ,CAACZ,EAAaC,KACpBV,EAAQoB,OAAOX,EAAI,EAGrBa,KAAM,CAACZ,EAAgBS,IACdI,MAAMC,KAAKxB,EAAQsB,QAG5BG,WAAY,KACVC,QAAQC,IAAI,8BAA8B,EAG5CC,QAAS,IAEAC,QAAQC,aAAQhB,GAGzBiB,MAAQrB,IAGC,EAGTsB,MAAQC,GAECJ,QAAQC,aAAQhB,GAG7B,CAGkBoB,ICxFX,MAAMC,UAAuBC,MAClCC,YAAYnB,GACVoB,MAAO,wCAAuCC,KAAKC,UAAUtB,KAC/D,E,gDCUF,MAAMuB,EAAgC,CACpC,CACEC,KAAM,UACNC,MAAO,KACPC,WAAY,OACZC,WAAW,EACXC,iBAAiB,IAIfC,EAAwCC,EAAAA,GAAAA,KAA2BC,IAAC,YAAM,CAC9EP,KAAM,WACNC,MAAOM,EAAEN,MACTC,WAAa,GAAc,QAAd,EAAEK,EAAEL,kBAAU,QAAI,SAC/BC,WAAW,EACXC,iBAAiB,EACjBI,OAAQD,EAAEC,OACVC,cAAeF,EAAEE,cAClB,IAEKC,EAAqCC,EAAAA,GAAAA,KAAyBJ,IAAC,YAAM,CACzEP,KAAM,WACNC,MAAOM,EAAEN,MACTC,WAAa,GAAc,QAAd,EAAEK,EAAEL,kBAAU,QAAI,0BAC/BC,WAAW,EACXC,iBAAiB,EACjBI,OAAQD,EAAEC,OACVC,cAAeF,EAAEE,cAClB,IAEKG,EAAqC,CAAC,cAAe,WAAY,KAAM,KAAM,MAAO,MAAO,KAAM,MAAMC,KAC1GC,IAAI,CACHd,KAAM,WACNC,MAAOa,EACPZ,WAAYY,MAIVC,EAA0B,CAC9B,CACEC,SAAU,KACVP,eAAeQ,EAAAA,EAAAA,IAAgBC,EAAAA,GAAAA,cAC/BC,WAAW,GAEb,CACEH,SAAU,KACVP,eAAeQ,EAAAA,EAAAA,IAAgBC,EAAAA,GAAAA,kBAEjC,CACEF,SAAU,KACVP,eAAeQ,EAAAA,EAAAA,IAAgBC,EAAAA,GAAAA,kBAC/BC,WAAW,GAEb,CACEH,SAAU,KACVP,eAAeQ,EAAAA,EAAAA,IAAgBC,EAAAA,GAAAA,uBAInC,SAASE,EAAyBD,GAChC,OAAOJ,EAAwBM,QAAQC,IAAgBH,GAAaG,EAAWH,YAAWN,KACxF,QAAC,SAAEG,EAAQ,cAAEP,GAAe,QAAM,CAChCT,KAAM,cACNC,MAAQ,GAAEe,OACVd,WAAa,GAAEiB,EAAYH,EAASO,QAAQ,IAAK,IAAMP,SACvDb,WAAW,EACXM,gBACD,GAEL,CAwCA,MAAMe,EAAU,CAAC,OAAQ,SAAU,UAAW,SAAU,UAgGjDC,eAAeC,EACpBC,EACAC,GAEA,OAAQD,EAAU3B,MAChB,IAAK,QACL,IAAK,UACH,MAAM6B,QA7IZJ,eAAwCG,GAGtC,aAFsBA,EAAaE,cAEpBjB,KAAKkB,IAAI,CACtB/B,KAAM,UACNC,MAAO8B,EACP7B,WAAY6B,KAEhB,CAqIuCC,CAAyBJ,GAC1D,MAAO,IAAIC,KAAuB9B,KAAoBM,KAA4BK,GACpF,IAAK,cACH,OAAOE,EACT,IAAK,cACH,OA1HNa,eACEQ,EACAL,GAEA,MAAM,mBAAEM,SAA6BN,EAAaO,sBAAsBF,GAExE,OAAOC,EAAmBrB,KAAKZ,IAAK,CAClCD,KAAM,aACNC,QACAC,WAAYD,EACZG,iBAAiB,KAErB,CA8GagC,CAAyBT,EAAUM,YAAaL,GACzD,IAAK,kCACH,OA1INH,eACEQ,EACAL,GAIA,aAFyBA,EAAaS,cAAcJ,IAElCpB,KAAKZ,IAAK,CAC1BD,KAAM,aACNC,QACAC,WAAa,GAAED,KACfG,iBAAiB,KAErB,CA8HakC,CAAoCX,EAAUM,YAAaL,GACpE,IAAK,oCACH,OA9BNH,eACEc,EACAC,EACAP,EACAL,GAGA,aADqBA,EAAaa,eAAeF,EAAWN,IAC9CpB,KAAKC,IAAI,CACrBd,KAAM,cACNC,MAAOa,EACPZ,WAAYsC,GAAgBE,EAAAA,EAAAA,IAAgC5B,GAAS,KAAG4B,EAAAA,EAAAA,IAAgC5B,SAE5G,CAkBa6B,CACLhB,EAAUY,UACVZ,EAAUa,cACVb,EAAUM,YACVL,GAEJ,IAAK,iBACH,OArHNH,eACEmB,EACAzB,EACAS,GAEA,MAAM,mBAAEM,EAAkB,QAAEW,EAAO,UAAEC,SAAoBlB,EAAaO,sBAAsBS,GACtFG,EAAa,IAAIC,IAAIxB,GACrByB,EAA4B,GAC5BC,EAAS/B,EAAY,IAAM,KAC3BgC,EAA4BjB,EAAmBkB,MAAMrF,GAAgB,UAARA,IACnE,GAAI8E,EAAS,CACXE,EAAWrE,OAAO,QAClB,MAAM2E,EAAQF,EAA4B,GAAK,cAC/CF,EAAYK,KAAK,CACftD,KAAM,SACNC,MAAQ,OAAMoD,IACdnD,WAAa,GAAEgD,QACfzC,cAAe0C,EACX,6CACAlC,EAAAA,EAAAA,IAAgBC,EAAAA,GAAAA,OAExB,CAEA,GAAI4B,EAAW,CACbC,EAAWrE,OAAO,UAClB,MAAM2E,EAAQF,EAA4B,GAAK,cAC/CF,EAAYK,KAAK,CACftD,KAAM,WACNC,MAAQ,SAAQoD,IAChBnD,WAAa,GAAEgD,UACfzC,cAAe0C,EACX,wCACAlC,EAAAA,EAAAA,IAAgBC,EAAAA,GAAAA,SAExB,CA2CA,OAzCyBrC,MAAMC,KAAKiE,GAAYQ,OAC/BC,SAASC,IACxBR,EAAYK,KAAK,CACftD,KAAM,SACNC,MAAOwD,EACPvD,WAAa,GAAEgD,IAASO,IACxBhD,eAAeQ,EAAAA,EAAAA,IAAgBwC,IAC/B,IAGJvB,EAAmBsB,SAASzF,IAC1BkF,EAAYK,KAAK,CACftD,KAAM,cACNC,MAAQ,UAASlC,IACjBmC,WAAa,GAAEgD,WAAgBnF,KAC/B,IAGJkF,EAAYK,KAAK,CACftD,KAAM,iBACNC,MAAO,SACPC,WAAa,GAAEgD,UACfzC,eAAeQ,EAAAA,EAAAA,IAAgBC,EAAAA,GAAAA,UAGjC+B,EAAYK,KAAK,CACftD,KAAM,iBACNC,MAAO,cACPC,WAAa,GAAEgD,yBACf/C,WAAW,EACXM,eAAeQ,EAAAA,EAAAA,IAAgBC,EAAAA,GAAAA,cAGjC+B,EAAYK,KAAK,CACftD,KAAM,iBACNC,MAAO,eACPC,WAAa,GAAEgD,gBACf/C,WAAW,EACXM,eAAeQ,EAAAA,EAAAA,IAAgBC,EAAAA,GAAAA,eAG1B,IAAIE,EAAyBD,MAAe8B,EACrD,CAuCaS,CAA4B/B,EAAUiB,OAAQjB,EAAUR,UAAWS,GAC5E,IAAK,iBACH,MAAO,IAAIlB,KAAyBL,GACtC,QACE,MAAM,IAAIZ,EAAekC,GAE/B,C,eC5OA,SAASgC,EAAKC,EAAkBC,GAC9B,OAAOD,EAAKC,EACd,CAEA,SAASC,EAAKF,EAAkBG,GAC9B,IAAIC,EAA6BJ,EACjC,IAAK,MAAOC,EAAWI,KAAiBF,EAAM,CAE5C,GADAC,EAAUL,EAAKK,EAASH,GACR,OAAZG,EAEF,OAAO,KAET,GAAIA,EAAQhE,KAAKkE,KAAOD,EAEtB,OAAO,IAEX,CACA,OAAOD,CACT,CAEA,SAASG,EAAYP,EAAkB9C,GACrC,OAAOA,EAAKsD,MAAMR,EAAK9E,KAAM8E,EAAKS,GACpC,CA4EA,SAASC,EAAYC,EAA0BC,GAC7C,OAAOD,EAAaE,OAAM,CAACC,EAAMC,IAAUD,IAASF,EAAWG,IACjE,CAEA,MAEMC,EAAwB,CAC5B,CACEb,KAAM,CAACc,EAAAA,IACPC,IA8SJ,SAAyBlB,EAAkB9C,EAAciE,GAKvD,MAAMC,EAAQlB,EAAKF,EAAM,CAAC,CAAC,aAAcqB,EAAAA,MACzC,GAAc,OAAVD,EAAgB,CASlB,IAFoBlE,EAAKsD,MAAMY,EAAMX,GAAIU,GAExBG,SAAS,KACxB,OAAO,IAEX,CAIA,MAAO,CACLlF,KAAM,kCACNiC,YAJkBkD,EAAUvB,EAAM9C,GAMtC,GAtUE,CACEiD,KAAM,CAACqB,EAAAA,IACPN,IAsOJ,SAAyBlB,EAAkB9C,EAAciE,GAIvD,MAAMM,EAAcvB,EAAKF,EAAM,CAC7B,CAAC,YAAa0B,EAAAA,IACd,CAAC,YAAaC,EAAAA,MAGhB,GAAmB,MAAfF,EACF,OAAOG,EAAqBH,EAAavE,EAAMiE,GAAK,GAWtD,GAAc,MALCjB,EAAKF,EAAM,CACxB,CAAC,aAhQiB,GAiQlB,CAAC,aAAc6B,EAAAA,MAIf,MAAO,CACLzF,KAAM,WAKV,OAAO,IACT,GAjQE,CACE+D,KAAM,CAAC2B,EAAAA,GAAQC,EAAAA,IACfb,IAAKc,GAEP,CACE7B,KAAM,CAAC8B,EAAAA,IACPf,IA+HJ,SAAkClB,EAAkB9C,EAAciE,GAChE,MAAMe,EAAchC,EAAKF,EAAM,CAAC,CAAC,SAAUmC,EAAAA,MAC3C,GAAoB,OAAhBD,EACF,OAAO,KAET,MAAME,EAAWF,EAAYG,SAAS,cACtC,GAAiB,OAAbD,EACF,OAAO,KAGT,MAAME,EAAepC,EAAKkC,EAAU,CAClC,CAAC,aAAcG,EAAAA,IACf,CAAC,YAAaC,EAAAA,IACd,CAAC,aAAcvB,EAAAA,MAGjB,GAAqB,OAAjBqB,EACF,OAAO,KAKT,MAAO,CACLlG,KAAM,cACNiC,YAJkBkD,EAAUe,EAAcpF,GAM9C,GAvJE,CACEiD,KAAM,CAACqC,EAAAA,IACPtB,IA+PJ,SAAyBlB,EAAkB9C,EAAciE,GACvD,OAAOS,EAAqB5B,EAAM9C,EAAMiE,GAAK,EAC/C,GA/PE,CACEhB,KAAM,CAxBY,EAwBI4B,EAAAA,IACtBb,IAAKc,GAEP,CACE7B,KAAM,CA5BY,EA4BIsC,EAAAA,IACtBvB,IAiPJ,SAA0BlB,EAAkB9C,EAAciE,GACxD,MAAO,CACL/E,KAAM,cAEV,GAnPE,CACE+D,KAAM,CAhCY,EAgCIqC,EAAAA,IACtBtB,IAuPJ,SAAkClB,EAAkB9C,EAAciE,GAChE,MAAMuB,EAASxC,EAAKF,EAAM,CAAC,CAAC,SAAUwC,EAAAA,MACtC,GAAe,OAAXE,EACF,OAAO,KAGT,OAAOd,EAAqBc,EAAQxF,EAAMiE,GAAK,EACjD,GA5PE,CACEhB,KAAM,CApCY,EAoCIwC,EAAAA,GAAaC,EAAAA,GAAYT,EAAAA,GAAuBS,EAAAA,GAAYlB,EAAAA,GAAMF,EAAAA,IACxFN,IAAK,KAAM,CAAG9E,KAAM,oBAEtB,CACE+D,KAAM,CAxCY,EAwCI0C,EAAAA,GAAeC,EAAAA,IACrC5B,IA+EJ,SAA0BlB,EAAkB9C,EAAciE,GAExD,MAAM4B,EAAW7C,EAAKF,EAAM,CAC1B,CAAC,SAAU6C,EAAAA,IACX,CAAC,SAAUC,EAAAA,MAGb,GAAiB,OAAbC,EACF,OAAO,KAGT,MAAM,OAAEL,GAAWK,EAEnB,GAAe,OAAXL,EACF,OAAO,KAGT,GAAIA,EAAOtG,KAAKkE,KAAOqB,EAAAA,IAAWe,EAAOtG,KAAKkE,KAAOkC,EAAAA,GACnD,OAAOZ,EAAqBc,EAAQxF,EAAMiE,GAAK,GAGjD,OAAO,IACT,IAjGM6B,EAAe,IAAIrJ,IAA2B,CAClD,CAAC,KAAM,KACP,CAAC,KAAM,MACP,CAAC,MAAO,MACR,CAAC,MAAO,QAOV,SAASsJ,EAASC,EAAyBhG,GACzC,GAAIgG,EAAY9G,KAAKkE,KAAOyB,EAAAA,GAC1B,OAAO,KAGT,MAAMoB,EAAWjD,EAAKgD,EAAa,CAAC,CAAC,aAAcrB,EAAAA,MAEnD,GAAiB,OAAbsB,EACF,OAAO,KAGT,MAAMC,EAASD,EAASE,YACxB,GAAe,OAAXD,EACF,OAAO,KAGT,MAAME,EApBR,SAAoBF,GAA0C,MAC5D,OAAoC,QAApC,EAAOJ,EAAa9I,IAAIkJ,EAAOG,aAAK,QAAI,IAC1C,CAkBaC,CAAWJ,GACtB,GAAW,OAAPE,EACF,OAAO,KAGT,MAAMG,EAAYvD,EAAKgD,EAAa,CAAC,CAAC,YAAapB,EAAAA,MAEnD,GAAkB,OAAd2B,EACF,OAAO,KAGT,MAAMF,EAAOhD,EAAY4C,EAAUjG,GAC7BtC,EAlKR,SAA4BsC,GAE1B,MAAMwG,EAASxG,EAAKsD,MAAM,EAAGtD,EAAKyG,OAAS,GAK3C,GAAIzG,EAAK0G,WAAW,MAAQ1G,EAAK2G,SAAS,KAGxC,OAAOH,EAAO/F,QAAQ,MAAO,KAI/B,GAAIT,EAAK0G,WAAW,MAAQ1G,EAAK2G,SAAS,KAGxC,OAAOH,EAAO/F,QAAQ,MAAO,KAI/B,GAAIT,EAAK0G,WAAW,MAAQ1G,EAAK2G,SAAS,KACxC,OAAOH,EAGT,MAAM,IAAI5H,MAAO,2BAA0BoB,IAC7C,CAwIgB4G,CAAmBvD,EAAYkD,EAAWvG,IAExD,MAAO,CAAEqG,OAAM3I,QAAO0I,KACxB,CAEA,SAAS/B,EAAUe,EAA0BpF,GAC3C,GAAIoF,EAAalG,KAAKkE,KAAOW,EAAAA,GAC3B,MAAO,GAGT,IAAI8C,EAA8B7D,EAAKoC,EAAc,CAAC,CAAC,aAAcjB,EAAAA,MAErE,MAAMrC,EAAkB,GAExB,KAAoB,OAAb+E,GAAmB,CACxB,MAAMb,EAAchD,EAAK6D,EAAU,CAAC,CAAC,YAAahC,EAAAA,MAClD,GAAoB,OAAhBmB,EAEF,MAAO,GAGT,MAAM7G,EAAQ4G,EAASC,EAAahG,GACtB,OAAVb,GACF2C,EAAOU,KAAKrD,GAId0H,EAAW7D,EAAK6D,EAAU,CAAC,CAAC,aAAc1C,EAAAA,KAC5C,CAKA,OAFArC,EAAOgF,UAEAhF,CACT,CAsDA,SAASgD,EAAehC,EAAkB9C,EAAciE,GAItD,MAAM8C,GAAgBjE,EAAK5D,KAAK8H,QAE1BxB,EAASxC,EAAKF,EAAM,CAAC,CAAC,SAAU+B,EAAAA,MACtC,GAAe,OAAXW,EACF,OAAO,KAGT,MAAMyB,EAAgBjE,EAAKwC,EAAQ,CAAC,CAAC,aAAcb,EAAAA,MACnD,GAAsB,OAAlBsC,EACF,OAAO,KAGT,MAAMxF,EAAY4B,EAAY4D,EAAejH,GAMvCkH,EAAgBlE,EAAKwC,EAAQ,CAAC,CAAC,SAAUrB,EAAAA,MAC/C,GAAsB,OAAlB+C,EACF,OAAO,KAGT,IAAIL,EAAWK,EAIX9B,EAAkC,KACtC,KAAwB,OAAjBA,GAAuB,CAC5B,MAAMI,EAASqB,EAASrB,OACxB,GAAe,OAAXA,EACF,OAAO,KAGT,OAAQA,EAAOtG,KAAKkE,IAClB,KAAKe,EAAAA,GAEH0C,EAAWrB,EACX,SACF,KAAKzB,EAAAA,GAEHqB,EAAeI,EACf,SACF,QAEE,OAAO,KAEb,CAGA,MAGMrE,EAHYkD,EAAUe,EAAcpF,GAGZO,QAAQpB,GAAUA,EAAMkH,OAAS5E,IAE/D,MAAO,CACLvC,KAAM,oCACNuC,YACAC,cAAeqF,EACf5F,cAEJ,CAoDA,SAASuD,EAAqB5B,EAAkB9C,EAAciE,EAAa5D,GAGzE,MAAM+E,EAAepC,EAAKF,EAAM,CAAC,CAAC,aAAciB,EAAAA,MAGhD,GAAoB,MAAhBqB,GAAwBA,EAAa7B,IAAMU,EAAK,CAElD,MAAO,CACL/E,KAAM,iBACNmB,YACAyB,OAJauC,EAAUe,EAAcpF,GAMzC,CAEA,OAAO,IACT,CCpZA,SAASmH,EAA4BjI,EAAsBkI,GACzD,OAAQlI,GACN,IAAK,WACH,OAAOkI,EAAOC,UAAUC,mBAAmBC,KAC7C,IAAK,WACH,OAAOH,EAAOC,UAAUC,mBAAmBE,SAC7C,IAAK,UACH,OAAOJ,EAAOC,UAAUC,mBAAmBG,QAC7C,IAAK,aACH,OAAOL,EAAOC,UAAUC,mBAAmBI,KAC7C,IAAK,cACH,OAAON,EAAOC,UAAUC,mBAAmBK,WAC7C,IAAK,UACH,OAAOP,EAAOC,UAAUC,mBAAmBM,YAC7C,IAAK,SACH,OAAOR,EAAOC,UAAUC,mBAAmBO,MAC7C,IAAK,cACH,OAAOT,EAAOC,UAAUC,mBAAmBQ,cAC7C,IAAK,iBACH,OAAOV,EAAOC,UAAUC,mBAAmBS,UAC7C,QACE,MAAM,IAAIpJ,EAAeO,GAE/B,CACO,SAAS8I,EACdZ,EACAtG,GAkDA,MAAO,CACLmH,kBAAmB,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,KAC5DC,uBAlD6B,CAC7BC,EACAC,KAEA,MAAMC,EAAOF,EAAMG,kBAAkBF,GAC/BG,EACI,MAARF,EACIjB,EAAO7B,MAAMiD,KAAK,CAChBC,gBAAiBL,EAASM,WAC1BC,cAAeP,EAASM,WACxBE,YAAaP,EAAKO,YAClBC,UAAWR,EAAKQ,YAElBzB,EAAO7B,MAAMuD,cAAcV,GAG3BW,EAAgB,CACpBC,OAAQZ,EAASY,OACjBN,WAAYN,EAASM,YAEjBO,EAASd,EAAMe,YAAYH,GAC3BlI,EDyZH,SAAsBb,EAAciE,GAIzC,GAAa,KAATjE,EACF,MAAO,CACLd,KAAM,SAIV,MAAMiK,EAAOxG,EAAAA,GAAAA,MAAa3C,GAOpBoJ,EAnCR,SAAsBD,EAAYnJ,EAAcqJ,GAI9C,MAAMC,EAAmBtJ,EAAKuJ,UAAU9C,OAClCxC,EAAMqF,EAAmBD,EAAYC,EAAmBD,EACxDG,EAAML,EAAKM,SAASxF,GAC1B,GACE,GAAIuF,EAAIxL,OAASiG,GAAOuF,EAAIjG,KAAOU,EAAK,CACtC,MAAM,KAAEnB,GAAS0G,EACjB,GAAI1G,EAAK5D,KAAK8H,QACZ,OAAOlE,CAEX,QACO0G,EAAIE,QACb,OAAO,IACT,CAmByBC,CAAaR,EAAMnJ,EAAMiE,GAE1CuF,EAAwB,MAAlBJ,EAAyBA,EAAeQ,SAAWT,EAAKM,SAASxF,GAEvE4F,EAAcL,EAAI1G,KAElBgH,EAAM,CAACN,EAAItK,KAAKkE,IACtB,KAAOoG,EAAIhE,UACTsE,EAAItH,KAAKgH,EAAItK,KAAKkE,IAGpB,IAAK,IAAI2G,KAAYjG,EACnB,GAAIN,EAAYuG,EAAS9G,KAAM6G,GAC7B,OAAOC,EAAS/F,IAAI6F,EAAa7J,EAAMiE,GAI3C,OAAO,IACT,CC5bsB+F,CAAa7B,EAAM8B,WAAYhB,GAEjD,OADwC,MAAbpI,EAAoBD,EAAeC,EAAWC,GAAgBzC,QAAQC,QAAQ,KAC/E4L,MAAMC,IAI9B,MAAMC,EAAiBD,EAAM1D,OAAO9J,WAAW8J,OAiB/C,MAAO,CAAE4D,YAhBmDF,EAAMpK,KAAI,CAAC6D,EAAMC,KAAU,CACrFyG,KAAMnD,EAA4BvD,EAAK1E,KAAMkI,GAC7CjI,MAAOyE,EAAKzE,MACZC,WAAYwE,EAAKxE,WACjBmL,gBAAiB3G,EAAKvE,UAnFO,OAmFoC/B,EACjEoC,OAAQkE,EAAKlE,OACbC,cAAeiE,EAAKjE,cACpB6K,SAAU3G,EAAMlH,WAAW8N,SAASL,EAAgB,KACpD7B,QACAmC,QAAS9G,EAAKtE,gBACV,CACE8D,GAAI,+BACJuH,MAAO,SAETrN,MAEgB,GACtB,EAON,C,cCvGO,MAAMsN,EACX/L,YAAoBgM,GAAyF,IAA7CC,EAAyC,UAAH,6CAAG,GAAE,KAAvFD,iBAAAA,EAAkC,KAAUC,QAAAA,CAA8C,CAEtGC,cAAcjJ,GAKpB,MAAQ,IAJcA,EAAO/B,KAC1BZ,GAAW,GAAEA,EAAMkH,OAAOlH,EAAMiH,OAAMxE,EAAAA,EAAAA,IAAgCzC,EAAMzB,YAGtDsN,KAAK,OAChC,CAEAhK,aACE,OAAOiK,KAAKH,QAAQ/K,KAAKmL,GAAUA,EAAMC,MAAMlK,OAAMV,QAAQU,QAAkB3D,IAAT2D,GACxE,CAEAN,sBAA+C,IAA3BQ,EAAuB,UAAH,6CAAG,GACzC,GAA2B,IAAvBA,EAAYsF,OAEd,OAAOwE,KAAKJ,iBAAiBO,eAE/B,MAAMvO,QAAaoO,KAAKI,gBAAgBlK,GAClCmK,EAAqBC,OAAOzN,KAAKjB,GACjC2O,EAAiB,IAAItJ,IAAIf,EAAYpB,KAAK0L,GAAMA,EAAEpF,QACxD,OAAOiF,EAAmB/K,QAAQpB,IAAWqM,EAAeE,IAAIvM,IAClE,CAEAwB,qBAAqBc,EAAmBN,GAAsB,MAC5D,GAA2B,IAAvBA,EAAYsF,OAEd,aAAawE,KAAKJ,iBAAiBlJ,eAAeF,GAIpD,OAAsB,QAAtB,SADmBwJ,KAAKI,gBAAgBlK,IAC5BM,UAAU,QAAI,EAC5B,CAEAd,4BAA4BmB,GAC1B,aAAamJ,KAAKJ,iBAAiBxJ,sBAAsB4J,KAAKF,cAAcjJ,GAC9E,CAEAnB,sBAAsBmB,GACpB,aAAamJ,KAAKJ,iBAAiBQ,gBAAgBJ,KAAKF,cAAcjJ,IAASoI,MAAMrN,GAASA,QAAAA,EAAQ,CAAC,GACzG,E,eCnCF,MAAM8O,EAAmE,CACvEC,UAAU,EACVC,aAAa,EAGbC,sBAAsB,EACtBvR,SAAS,EACTwR,SAAU,GACVC,qBAAsB,EACtBC,YAAa,MACbC,QAAS,CAAEC,SAAS,GACpBC,qBAAqB,EACrBC,mBAAoB,EACpBC,QAAS,CAGPC,IAAK,EACLC,OAAQ,GAEVC,oBAAqB,OACrBC,UAAW,CACTC,SAAU,SACVC,sBAAuB,EACvBC,WAAY,SACZC,wBAAyB,GAE3BC,sBAAsB,EACtBC,QF/BO,CAgBLC,WAAW,GEgBbC,gBAAiB,GACjBC,SAAU,MAYNC,EAAU,QAGhB,IAAIC,GAAyB,EAY7B,MAwHA,EA/GyB,IAA4E,IAA3E,iBAAExC,EAAgB,QAAEC,EAAO,OAAEwC,EAAM,WAAEC,EAAU,aAAEC,GAAqB,EAC9F,MAAMpK,GAAKqK,EAAAA,EAAAA,KAELC,GAAsBC,EAAAA,EAAAA,QN2BrBrR,GM1BDsR,GAAeD,EAAAA,EAAAA,QAAuB,MACtCE,GAAkBC,EAAAA,EAAAA,GAAUjD,GAC5BkD,GAAaD,EAAAA,EAAAA,GAAUhD,GACvBkD,GAAgBF,EAAAA,EAAAA,GAAUP,GAC1BU,GAAYH,EAAAA,EAAAA,GAAUR,GAEtBY,GAA8BP,EAAAA,EAAAA,QAA4B,MAG1DQ,EAtBWC,KACV,CACLC,UAAWC,EAAAA,GAAI;uBACIF,EAAMG,MAAMC;0BACTJ,EAAMK,WAAWC,MAAMC;QAkBhCC,EADDC,EAAAA,EAAAA,OAUd,OAPAC,EAAAA,EAAAA,YAAU,IAED,KAAM,MACwB,QAAnC,EAAAZ,EAA4BhL,eAAO,OAAnC,OAAAgL,EAAuC,GAExC,KAGD,gBACE,aAAYa,EAAAA,GAAAA,WAAAA,WAAAA,UACZC,UAAWb,EAAOE,UAElBY,IAAKrB,EAAa,UAElB,SAAC,IAAiB,CAChBtR,iBAAkBoR,EAAoBxK,QACtCyI,QAASA,EACTuD,SAAU9B,EACV1P,MAAO8P,EACP2B,YAAc/H,KArDtB,SAAqBA,IACY,IAA3BiG,IACFA,GAAyB,EACzBjG,EAAOC,UAAU+H,SAAS,CAAEhM,GAAIgK,IAEhChG,EAAOC,UAAUgI,yBAAyBjC,EAASkC,EAAAA,IACnDlI,EAAOC,UAAUkI,yBAAyBnC,EAASoC,EAAAA,GAEvD,CA8CUC,CAAYrI,EAAO,EAErBsI,QAAS,CAACC,EAAQvI,KAEhB,MAAMwI,EAAkBD,EAAOE,iBAA0B,kBAAoBzM,GAAI,GAEjFuM,EAAOG,uBAAsB,KAC3BF,EAAgBlT,KAAI,GACpBuR,EAAU/K,QAAQyM,EAAO1F,WAAW,IAEtC,MACM8F,EAAqB/H,EAAsBZ,EAD5B,IAAIwD,EAAuBiD,EAAgB3K,QAAS6K,EAAW7K,UAW9E8M,EAA4E,OAAH,UAC1ED,EAAkB,CACrB7H,uBAAwB,CAACC,EAAOC,EAAU6H,EAAShU,KAAU,MAG3D,OAAqB,QAAjB,EAAA0T,EAAOO,kBAAU,aAAjB,EAAmB9M,MAAO+E,EAAM/E,GAC3B,CAAEiH,YAAa,IAEjB0F,EAAmB7H,uBAAuBC,EAAOC,EAAU6H,EAAShU,EAAM,KAI/E,QAAEkU,GAAY/I,EAAOC,UAAU+I,+BAA+BhD,EAAS4C,GAE7E9B,EAA4BhL,QAAUiN,EAKtC,MAAME,EAAsB,KAC1B,MAAMC,EAAe1C,EAAa1K,QAClC,GAAqB,OAAjBoN,EAAuB,CACzB,MAAMC,EAAcZ,EAAOa,mBAC3BF,EAAaG,MAAMC,OAAU,GAAEH,EAzGhB,MA0GfD,EAAaG,MAAME,MAAQ,OAC3B,MAAMC,EAAaN,EAAaO,YAChClB,EAAOmB,OAAO,CAAEH,MAAOC,EAAYF,OAAQH,GAC7C,GAGFZ,EAAOoB,uBAAuBV,GAC9BA,IAGAV,EAAOqB,WACL5J,EAAO6J,OAAOC,MAAQ9J,EAAO+J,QAAQC,OACrC,KACEpD,EAAc9K,QAAQyM,EAAO1F,WAAW,GAE1C,kBAAoB7G,GAGtBuM,EAAO0B,sBAAqB,KAC1BzB,EAAgBlT,KAAI,GACa,KAA7BiT,EAAO1F,WAAWqH,QACpB3B,EAAO4B,QAAQ,GAAI,+BAAgC,CAAC,EACtD,GACA,KAGF,C,iDCpLV,QALgB,SAAU7T,GACtB,IAAIuR,GAAM,IAAAtB,QAAOjQ,GAEjB,OADAuR,EAAI/L,QAAUxF,EACPuR,CACX,C","sources":["webpack://grafana/./.yarn/__virtual__/@grafana-monaco-logql-virtual-630f79d16d/3/opt/drone/yarncache/@grafana-monaco-logql-npm-0.0.6-1be1b655d4-81ac76c0ea.zip/node_modules/@grafana/monaco-logql/index.js","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/getOverrideServices.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/NeverCaseError.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/completions.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/situation.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/index.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/CompletionDataProvider.ts","webpack://grafana/./public/app/plugins/datasource/loki/components/monaco-query-field/MonacoQueryField.tsx","webpack://grafana/./.yarn/__virtual__/react-use-virtual-0c21d950b6/3/opt/drone/yarncache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/useLatest.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.monarchlanguage = exports.languageConfiguration = void 0;\nexports.languageConfiguration = {\n    // the default separators except `@$`\n    wordPattern: /(-?\\d*\\.\\d\\w*)|([^`~!#%^&*()\\-=+\\[{\\]}\\\\|;:'\",.<>\\/?\\s]+)/g,\n    comments: {\n        lineComment: \"#\",\n    },\n    brackets: [\n        [\"{\", \"}\"],\n        [\"[\", \"]\"],\n        [\"(\", \")\"],\n    ],\n    autoClosingPairs: [\n        { open: \"{\", close: \"}\" },\n        { open: \"[\", close: \"]\" },\n        { open: \"(\", close: \")\" },\n        { open: '\"', close: '\"' },\n        { open: \"'\", close: \"'\" },\n        { open: \"`\", close: \"`\" },\n    ],\n    surroundingPairs: [\n        { open: \"{\", close: \"}\" },\n        { open: \"[\", close: \"]\" },\n        { open: \"(\", close: \")\" },\n        { open: '\"', close: '\"' },\n        { open: \"'\", close: \"'\" },\n        { open: \"`\", close: \"`\" },\n        { open: \"<\", close: \">\" },\n    ],\n    folding: {},\n};\n// LogQL built-in aggregation operators\n// https://grafana.com/docs/loki/latest/logql/metric_queries/#built-in-aggregation-operators\nvar aggregations = [\n    \"sum\",\n    \"avg\",\n    \"min\",\n    \"max\",\n    \"stddev\",\n    \"stdvar\",\n    \"count\",\n    \"topk\",\n    \"bottomk\",\n];\n// LogQL parser expressions\n// https://grafana.com/docs/loki/latest/logql/log_queries/#parser-expression\nvar parsers = [\"json\", \"logfmt\", \"regexp\", \"unpack\", \"pattern\"];\n// LogQL format expressions\n// https://grafana.com/docs/loki/latest/logql/log_queries/#parser-expression\nvar format_expressions = [\"line_format\", \"label_format\"];\n// LogQL vector aggregations\n// https://grafana.com/docs/loki/latest/logql/metric_queries/#range-vector-aggregation\nvar vector_aggregations = [\n    \"count_over_time\",\n    \"rate\",\n    \"bytes_over_time\",\n    \"bytes_rate\",\n    \"avg_over_time\",\n    \"sum_over_time\",\n    \"min_over_time\",\n    \"max_over_time\",\n    \"stdvar_over_time\",\n    \"stddev_over_time\",\n    \"quantile_over_time\",\n    \"first_over_time\",\n    \"last_over_time\",\n    \"absent_over_time\",\n];\n// LogQL by and without clauses\nvar vector_matching = [\"by\", \"without\"];\n// Produce a regex matching elements : (by|without)\nvar vectorMatchingRegex = \"(\".concat(vector_matching.reduce(function (prev, curr) { return \"\".concat(prev, \"|\").concat(curr); }), \")\");\n// LogQL Operators\nvar operators = [\n    \"+\",\n    \"-\",\n    \"*\",\n    \"/\",\n    \"%\",\n    \"^\",\n    \"==\",\n    \"!=\",\n    \">\",\n    \"<\",\n    \">=\",\n    \"<=\",\n    \"|=\",\n    \"!=\",\n    \"|~\",\n    \"!~\",\n    \"and\",\n    \"or\",\n    \"unless\",\n    \"|\",\n];\n// Merging all the keywords in one list\nvar keywords = aggregations\n    .concat(parsers)\n    .concat(format_expressions)\n    .concat(vector_aggregations)\n    .concat(vector_matching);\nexports.monarchlanguage = {\n    ignoreCase: false,\n    defaultToken: \"\",\n    tokenPostfix: \".logql\",\n    keywords: keywords,\n    operators: operators,\n    vectorMatching: vectorMatchingRegex,\n    // we include these common regular expressions\n    symbols: /[=><!~?:&|+\\-*\\/^%]+/,\n    escapes: /\\\\(?:[abfnrtv\\\\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,\n    digits: /\\d+(_+\\d+)*/,\n    octaldigits: /[0-7]+(_+[0-7]+)*/,\n    binarydigits: /[0-1]+(_+[0-1]+)*/,\n    hexdigits: /[[0-9a-fA-F]+(_+[0-9a-fA-F]+)*/,\n    integersuffix: /(ll|LL|u|U|l|L)?(ll|LL|u|U|l|L)?/,\n    floatsuffix: /[fFlL]?/,\n    // The main tokenizer for our languages\n    tokenizer: {\n        root: [\n            // 'by', 'without' and vector matching\n            [/@vectorMatching\\s*(?=\\()/, \"type\", \"@clauses\"],\n            // labels\n            [/[a-z_]\\w*(?=\\s*(=|!=|=~|!~))/, \"tag\"],\n            // comments\n            [/(^#.*$)/, \"comment\"],\n            // all keywords have the same color\n            [\n                /[a-zA-Z_]\\w*/,\n                {\n                    cases: {\n                        \"@keywords\": \"type\",\n                        \"@default\": \"identifier\",\n                    },\n                },\n            ],\n            // strings\n            [/\"/, \"string\", \"@string_double\"],\n            [/'/, \"string\", \"@string_single\"],\n            [/`/, \"string\", \"@string_backtick\"],\n            // whitespace\n            { include: \"@whitespace\" },\n            // delimiters and operators\n            [/[{}()\\[\\]]/, \"@brackets\"],\n            [/[<>](?!@symbols)/, \"@brackets\"],\n            [\n                /@symbols/,\n                {\n                    cases: {\n                        \"@operators\": \"delimiter\",\n                        \"@default\": \"\",\n                    },\n                },\n            ],\n            // numbers\n            [/\\d+[smhdwy]/, \"number\"],\n            [/\\d*\\d+[eE]([\\-+]?\\d+)?(@floatsuffix)/, \"number.float\"],\n            [/\\d*\\.\\d+([eE][\\-+]?\\d+)?(@floatsuffix)/, \"number.float\"],\n            [/0[xX][0-9a-fA-F']*[0-9a-fA-F](@integersuffix)/, \"number.hex\"],\n            [/0[0-7']*[0-7](@integersuffix)/, \"number.octal\"],\n            [/0[bB][0-1']*[0-1](@integersuffix)/, \"number.binary\"],\n            [/\\d[\\d']*\\d(@integersuffix)/, \"number\"],\n            [/\\d(@integersuffix)/, \"number\"],\n        ],\n        string_double: [\n            // Set to token: number to differentiate color\n            [/\\{\\{(.*?)\\}\\}/, { token: 'number' }],\n            [/[^\\\\\"]/, \"string\"],\n            [/@escapes/, \"string.escape\"],\n            [/\\\\./, \"string.escape.invalid\"],\n            [/\"/, \"string\", \"@pop\"],\n        ],\n        string_single: [\n            [/[^\\\\']+/, \"string\"],\n            [/@escapes/, \"string.escape\"],\n            [/\\\\./, \"string.escape.invalid\"],\n            [/'/, \"string\", \"@pop\"],\n        ],\n        string_backtick: [\n            // Set to token: number to differentiate color\n            [/\\{\\{(.*?)\\}\\}/, { token: 'number' }],\n            [/[^\\\\`]/, \"string\"],\n            [/@escapes/, \"string.escape\"],\n            [/\\\\./, \"string.escape.invalid\"],\n            [/`/, \"string\", \"@pop\"],\n        ],\n        clauses: [\n            [/[^(,)]/, \"tag\"],\n            [/\\)/, \"identifier\", \"@pop\"],\n        ],\n        whitespace: [[/[ \\t\\r\\n]+/, \"white\"]],\n    },\n};\n","import { monacoTypes } from '@grafana/ui';\n\n// this thing here is a workaround in a way.\n// what we want to achieve, is that when the autocomplete-window\n// opens, the \"second, extra popup\" with the extra help,\n// also opens automatically.\n// but there is no API to achieve it.\n// the way to do it is to implement the `storageService`\n// interface, and provide our custom implementation,\n// which will default to `true` for the correct string-key.\n// unfortunately, while the typescript-interface exists,\n// it is not exported from monaco-editor,\n// so we cannot rely on typescript to make sure\n// we do it right. all we can do is to manually\n// lookup the interface, and make sure we code our code right.\n// our code is a \"best effort\" approach,\n// i am not 100% how the `scope` and `target` things work,\n// but so far it seems to work ok.\n// i would use an another approach, if there was one available.\n\nfunction makeStorageService() {\n  // we need to return an object that fulfills this interface:\n  // https://github.com/microsoft/vscode/blob/ff1e16eebb93af79fd6d7af1356c4003a120c563/src/vs/platform/storage/common/storage.ts#L37\n  // unfortunately it is not export from monaco-editor\n\n  const strings = new Map<string, string>();\n\n  // we want this to be true by default\n  strings.set('expandSuggestionDocs', true.toString());\n\n  return {\n    // we do not implement the on* handlers\n    onDidChangeValue: (data: unknown): void => undefined,\n    onDidChangeTarget: (data: unknown): void => undefined,\n    onWillSaveState: (data: unknown): void => undefined,\n\n    get: (key: string, scope: unknown, fallbackValue?: string): string | undefined => {\n      return strings.get(key) ?? fallbackValue;\n    },\n\n    getBoolean: (key: string, scope: unknown, fallbackValue?: boolean): boolean | undefined => {\n      const val = strings.get(key);\n      if (val !== undefined) {\n        // the interface docs say the value will be converted\n        // to a boolean but do not specify how, so we improvise\n        return val === 'true';\n      } else {\n        return fallbackValue;\n      }\n    },\n\n    getNumber: (key: string, scope: unknown, fallbackValue?: number): number | undefined => {\n      const val = strings.get(key);\n      if (val !== undefined) {\n        return parseInt(val, 10);\n      } else {\n        return fallbackValue;\n      }\n    },\n\n    store: (\n      key: string,\n      value: string | boolean | number | undefined | null,\n      scope: unknown,\n      target: unknown\n    ): void => {\n      // the interface docs say if the value is nullish, it should act as delete\n      if (value === null || value === undefined) {\n        strings.delete(key);\n      } else {\n        strings.set(key, value.toString());\n      }\n    },\n\n    remove: (key: string, scope: unknown): void => {\n      strings.delete(key);\n    },\n\n    keys: (scope: unknown, target: unknown): string[] => {\n      return Array.from(strings.keys());\n    },\n\n    logStorage: (): void => {\n      console.log('logStorage: not implemented');\n    },\n\n    migrate: (): Promise<void> => {\n      // we do not implement this\n      return Promise.resolve(undefined);\n    },\n\n    isNew: (scope: unknown): boolean => {\n      // we create a new storage for every session, we do not persist it,\n      // so we return `true`.\n      return true;\n    },\n\n    flush: (reason?: unknown): Promise<void> => {\n      // we do not implement this\n      return Promise.resolve(undefined);\n    },\n  };\n}\n\nlet overrideServices: monacoTypes.editor.IEditorOverrideServices = {\n  storageService: makeStorageService(),\n};\n\nexport function getOverrideServices(): monacoTypes.editor.IEditorOverrideServices {\n  // One instance of this for every query editor\n  return overrideServices;\n}\n","// This helper class is used to make typescript warn you when you miss a case-block in a switch statement.\n// For example:\n//\n// const x:'A'|'B'|'C' = 'A';\n//\n// switch(x) {\n//   case 'A':\n//     // something\n//   case 'B':\n//     // something\n//   default:\n//     throw new NeverCaseError(x);\n// }\n//\n//\n// TypeScript detect the missing case and display an error.\n\nexport class NeverCaseError extends Error {\n  constructor(value: never) {\n    super(`Unexpected case in switch statement: ${JSON.stringify(value)}`);\n  }\n}\n","import { escapeLabelValueInExactSelector } from '../../../languageUtils';\nimport { explainOperator } from '../../../querybuilder/operations';\nimport { LokiOperationId } from '../../../querybuilder/types';\nimport { AGGREGATION_OPERATORS, RANGE_VEC_FUNCTIONS } from '../../../syntax';\n\nimport { CompletionDataProvider } from './CompletionDataProvider';\nimport { NeverCaseError } from './NeverCaseError';\nimport type { Situation, Label } from './situation';\n\nexport type CompletionType =\n  | 'HISTORY'\n  | 'FUNCTION'\n  | 'DURATION'\n  | 'LABEL_NAME'\n  | 'LABEL_VALUE'\n  | 'PATTERN'\n  | 'PARSER'\n  | 'LINE_FILTER'\n  | 'PIPE_OPERATION';\n\ntype Completion = {\n  type: CompletionType;\n  label: string;\n  insertText: string;\n  detail?: string;\n  documentation?: string;\n  triggerOnInsert?: boolean;\n  isSnippet?: boolean;\n};\n\nconst LOG_COMPLETIONS: Completion[] = [\n  {\n    type: 'PATTERN',\n    label: '{}',\n    insertText: '{$0}',\n    isSnippet: true,\n    triggerOnInsert: true,\n  },\n];\n\nconst AGGREGATION_COMPLETIONS: Completion[] = AGGREGATION_OPERATORS.map((f) => ({\n  type: 'FUNCTION',\n  label: f.label,\n  insertText: `${f.insertText ?? ''}($0)`, // i don't know what to do when this is nullish. it should not be.\n  isSnippet: true,\n  triggerOnInsert: true,\n  detail: f.detail,\n  documentation: f.documentation,\n}));\n\nconst FUNCTION_COMPLETIONS: Completion[] = RANGE_VEC_FUNCTIONS.map((f) => ({\n  type: 'FUNCTION',\n  label: f.label,\n  insertText: `${f.insertText ?? ''}({$0}[\\\\$__interval])`, // i don't know what to do when this is nullish. it should not be.\n  isSnippet: true,\n  triggerOnInsert: true,\n  detail: f.detail,\n  documentation: f.documentation,\n}));\n\nconst DURATION_COMPLETIONS: Completion[] = ['$__interval', '$__range', '1m', '5m', '10m', '30m', '1h', '1d'].map(\n  (text) => ({\n    type: 'DURATION',\n    label: text,\n    insertText: text,\n  })\n);\n\nconst LINE_FILTER_COMPLETIONS = [\n  {\n    operator: '|=',\n    documentation: explainOperator(LokiOperationId.LineContains),\n    afterPipe: true,\n  },\n  {\n    operator: '!=',\n    documentation: explainOperator(LokiOperationId.LineContainsNot),\n  },\n  {\n    operator: '|~',\n    documentation: explainOperator(LokiOperationId.LineMatchesRegex),\n    afterPipe: true,\n  },\n  {\n    operator: '!~',\n    documentation: explainOperator(LokiOperationId.LineMatchesRegexNot),\n  },\n];\n\nfunction getLineFilterCompletions(afterPipe: boolean): Completion[] {\n  return LINE_FILTER_COMPLETIONS.filter((completion) => !afterPipe || completion.afterPipe).map(\n    ({ operator, documentation }) => ({\n      type: 'LINE_FILTER',\n      label: `${operator} \"\"`,\n      insertText: `${afterPipe ? operator.replace('|', '') : operator} \"$0\"`,\n      isSnippet: true,\n      documentation,\n    })\n  );\n}\n\nasync function getAllHistoryCompletions(dataProvider: CompletionDataProvider): Promise<Completion[]> {\n  const history = await dataProvider.getHistory();\n\n  return history.map((expr) => ({\n    type: 'HISTORY',\n    label: expr,\n    insertText: expr,\n  }));\n}\n\nasync function getLabelNamesForSelectorCompletions(\n  otherLabels: Label[],\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  const labelNames = await dataProvider.getLabelNames(otherLabels);\n\n  return labelNames.map((label) => ({\n    type: 'LABEL_NAME',\n    label,\n    insertText: `${label}=`,\n    triggerOnInsert: true,\n  }));\n}\n\nasync function getInGroupingCompletions(\n  otherLabels: Label[],\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  const { extractedLabelKeys } = await dataProvider.getParserAndLabelKeys(otherLabels);\n\n  return extractedLabelKeys.map((label) => ({\n    type: 'LABEL_NAME',\n    label,\n    insertText: label,\n    triggerOnInsert: false,\n  }));\n}\n\nconst PARSERS = ['json', 'logfmt', 'pattern', 'regexp', 'unpack'];\n\nasync function getAfterSelectorCompletions(\n  labels: Label[],\n  afterPipe: boolean,\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  const { extractedLabelKeys, hasJSON, hasLogfmt } = await dataProvider.getParserAndLabelKeys(labels);\n  const allParsers = new Set(PARSERS);\n  const completions: Completion[] = [];\n  const prefix = afterPipe ? ' ' : '| ';\n  const hasLevelInExtractedLabels = extractedLabelKeys.some((key) => key === 'level');\n  if (hasJSON) {\n    allParsers.delete('json');\n    const extra = hasLevelInExtractedLabels ? '' : ' (detected)';\n    completions.push({\n      type: 'PARSER',\n      label: `json${extra}`,\n      insertText: `${prefix}json`,\n      documentation: hasLevelInExtractedLabels\n        ? 'Use it to get log-levels in the histogram'\n        : explainOperator(LokiOperationId.Json),\n    });\n  }\n\n  if (hasLogfmt) {\n    allParsers.delete('logfmt');\n    const extra = hasLevelInExtractedLabels ? '' : ' (detected)';\n    completions.push({\n      type: 'DURATION',\n      label: `logfmt${extra}`,\n      insertText: `${prefix}logfmt`,\n      documentation: hasLevelInExtractedLabels\n        ? 'Get detected levels in the histogram'\n        : explainOperator(LokiOperationId.Logfmt),\n    });\n  }\n\n  const remainingParsers = Array.from(allParsers).sort();\n  remainingParsers.forEach((parser) => {\n    completions.push({\n      type: 'PARSER',\n      label: parser,\n      insertText: `${prefix}${parser}`,\n      documentation: explainOperator(parser),\n    });\n  });\n\n  extractedLabelKeys.forEach((key) => {\n    completions.push({\n      type: 'LINE_FILTER',\n      label: `unwrap ${key}`,\n      insertText: `${prefix}unwrap ${key}`,\n    });\n  });\n\n  completions.push({\n    type: 'PIPE_OPERATION',\n    label: 'unwrap',\n    insertText: `${prefix}unwrap`,\n    documentation: explainOperator(LokiOperationId.Unwrap),\n  });\n\n  completions.push({\n    type: 'PIPE_OPERATION',\n    label: 'line_format',\n    insertText: `${prefix}line_format \"{{.$0}}\"`,\n    isSnippet: true,\n    documentation: explainOperator(LokiOperationId.LineFormat),\n  });\n\n  completions.push({\n    type: 'PIPE_OPERATION',\n    label: 'label_format',\n    insertText: `${prefix}label_format`,\n    isSnippet: true,\n    documentation: explainOperator(LokiOperationId.LabelFormat),\n  });\n\n  return [...getLineFilterCompletions(afterPipe), ...completions];\n}\n\nasync function getLabelValuesForMetricCompletions(\n  labelName: string,\n  betweenQuotes: boolean,\n  otherLabels: Label[],\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  const values = await dataProvider.getLabelValues(labelName, otherLabels);\n  return values.map((text) => ({\n    type: 'LABEL_VALUE',\n    label: text,\n    insertText: betweenQuotes ? escapeLabelValueInExactSelector(text) : `\"${escapeLabelValueInExactSelector(text)}\"`,\n  }));\n}\n\nexport async function getCompletions(\n  situation: Situation,\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  switch (situation.type) {\n    case 'EMPTY':\n    case 'AT_ROOT':\n      const historyCompletions = await getAllHistoryCompletions(dataProvider);\n      return [...historyCompletions, ...LOG_COMPLETIONS, ...AGGREGATION_COMPLETIONS, ...FUNCTION_COMPLETIONS];\n    case 'IN_DURATION':\n      return DURATION_COMPLETIONS;\n    case 'IN_GROUPING':\n      return getInGroupingCompletions(situation.otherLabels, dataProvider);\n    case 'IN_LABEL_SELECTOR_NO_LABEL_NAME':\n      return getLabelNamesForSelectorCompletions(situation.otherLabels, dataProvider);\n    case 'IN_LABEL_SELECTOR_WITH_LABEL_NAME':\n      return getLabelValuesForMetricCompletions(\n        situation.labelName,\n        situation.betweenQuotes,\n        situation.otherLabels,\n        dataProvider\n      );\n    case 'AFTER_SELECTOR':\n      return getAfterSelectorCompletions(situation.labels, situation.afterPipe, dataProvider);\n    case 'IN_AGGREGATION':\n      return [...FUNCTION_COMPLETIONS, ...AGGREGATION_COMPLETIONS];\n    default:\n      throw new NeverCaseError(situation);\n  }\n}\n","import type { Tree, SyntaxNode } from '@lezer/common';\n\nimport {\n  parser,\n  VectorAggregationExpr,\n  String,\n  Selector,\n  RangeAggregationExpr,\n  Range,\n  PipelineExpr,\n  PipelineStage,\n  Matchers,\n  Matcher,\n  LogQL,\n  LogRangeExpr,\n  LogExpr,\n  Identifier,\n  Grouping,\n  Expr,\n  LiteralExpr,\n  MetricExpr,\n} from '@grafana/lezer-logql';\n\ntype Direction = 'parent' | 'firstChild' | 'lastChild' | 'nextSibling';\ntype NodeType = number;\n\ntype Path = Array<[Direction, NodeType]>;\n\nfunction move(node: SyntaxNode, direction: Direction): SyntaxNode | null {\n  return node[direction];\n}\n\nfunction walk(node: SyntaxNode, path: Path): SyntaxNode | null {\n  let current: SyntaxNode | null = node;\n  for (const [direction, expectedNode] of path) {\n    current = move(current, direction);\n    if (current === null) {\n      // we could not move in the direction, we stop\n      return null;\n    }\n    if (current.type.id !== expectedNode) {\n      // the reached node has wrong type, we stop\n      return null;\n    }\n  }\n  return current;\n}\n\nfunction getNodeText(node: SyntaxNode, text: string): string {\n  return text.slice(node.from, node.to);\n}\n\nfunction parseStringLiteral(text: string): string {\n  // If it is a string-literal, it is inside quotes of some kind\n  const inside = text.slice(1, text.length - 1);\n\n  // Very simple un-escaping:\n\n  // Double quotes\n  if (text.startsWith('\"') && text.endsWith('\"')) {\n    // NOTE: this is not 100% perfect, we only unescape the double-quote,\n    // there might be other characters too\n    return inside.replace(/\\\\\"/, '\"');\n  }\n\n  // Single quotes\n  if (text.startsWith(\"'\") && text.endsWith(\"'\")) {\n    // NOTE: this is not 100% perfect, we only unescape the single-quote,\n    // there might be other characters too\n    return inside.replace(/\\\\'/, \"'\");\n  }\n\n  // Backticks\n  if (text.startsWith('`') && text.endsWith('`')) {\n    return inside;\n  }\n\n  throw new Error(`Invalid string literal: ${text}`);\n}\n\nexport type LabelOperator = '=' | '!=' | '=~' | '!~';\n\nexport type Label = {\n  name: string;\n  value: string;\n  op: LabelOperator;\n};\n\nexport type Situation =\n  | {\n      type: 'EMPTY';\n    }\n  | {\n      type: 'AT_ROOT';\n    }\n  | {\n      type: 'IN_DURATION';\n    }\n  | {\n      type: 'IN_AGGREGATION';\n    }\n  | {\n      type: 'IN_GROUPING';\n      otherLabels: Label[];\n    }\n  | {\n      type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME';\n      otherLabels: Label[];\n    }\n  | {\n      type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME';\n      labelName: string;\n      betweenQuotes: boolean;\n      otherLabels: Label[];\n    }\n  | {\n      type: 'AFTER_SELECTOR';\n      afterPipe: boolean;\n      labels: Label[];\n    };\n\ntype Resolver = {\n  path: NodeType[];\n  fun: (node: SyntaxNode, text: string, pos: number) => Situation | null;\n};\n\nfunction isPathMatch(resolverPath: NodeType[], cursorPath: number[]): boolean {\n  return resolverPath.every((item, index) => item === cursorPath[index]);\n}\n\nconst ERROR_NODE_ID = 0;\n\nconst RESOLVERS: Resolver[] = [\n  {\n    path: [Selector],\n    fun: resolveSelector,\n  },\n  {\n    path: [LogQL],\n    fun: resolveTopLevel,\n  },\n  {\n    path: [String, Matcher],\n    fun: resolveMatcher,\n  },\n  {\n    path: [Grouping],\n    fun: resolveLabelsForGrouping,\n  },\n  {\n    path: [LogRangeExpr],\n    fun: resolveLogRange,\n  },\n  {\n    path: [ERROR_NODE_ID, Matcher],\n    fun: resolveMatcher,\n  },\n  {\n    path: [ERROR_NODE_ID, Range],\n    fun: resolveDurations,\n  },\n  {\n    path: [ERROR_NODE_ID, LogRangeExpr],\n    fun: resolveLogRangeFromError,\n  },\n  {\n    path: [ERROR_NODE_ID, LiteralExpr, MetricExpr, VectorAggregationExpr, MetricExpr, Expr, LogQL],\n    fun: () => ({ type: 'IN_AGGREGATION' }),\n  },\n  {\n    path: [ERROR_NODE_ID, PipelineStage, PipelineExpr],\n    fun: resolvePipeError,\n  },\n];\n\nconst LABEL_OP_MAP = new Map<string, LabelOperator>([\n  ['Eq', '='],\n  ['Re', '=~'],\n  ['Neq', '!='],\n  ['Nre', '!~'],\n]);\n\nfunction getLabelOp(opNode: SyntaxNode): LabelOperator | null {\n  return LABEL_OP_MAP.get(opNode.name) ?? null;\n}\n\nfunction getLabel(matcherNode: SyntaxNode, text: string): Label | null {\n  if (matcherNode.type.id !== Matcher) {\n    return null;\n  }\n\n  const nameNode = walk(matcherNode, [['firstChild', Identifier]]);\n\n  if (nameNode === null) {\n    return null;\n  }\n\n  const opNode = nameNode.nextSibling;\n  if (opNode === null) {\n    return null;\n  }\n\n  const op = getLabelOp(opNode);\n  if (op === null) {\n    return null;\n  }\n\n  const valueNode = walk(matcherNode, [['lastChild', String]]);\n\n  if (valueNode === null) {\n    return null;\n  }\n\n  const name = getNodeText(nameNode, text);\n  const value = parseStringLiteral(getNodeText(valueNode, text));\n\n  return { name, value, op };\n}\n\nfunction getLabels(selectorNode: SyntaxNode, text: string): Label[] {\n  if (selectorNode.type.id !== Selector) {\n    return [];\n  }\n\n  let listNode: SyntaxNode | null = walk(selectorNode, [['firstChild', Matchers]]);\n\n  const labels: Label[] = [];\n\n  while (listNode !== null) {\n    const matcherNode = walk(listNode, [['lastChild', Matcher]]);\n    if (matcherNode === null) {\n      // unexpected, we stop\n      return [];\n    }\n\n    const label = getLabel(matcherNode, text);\n    if (label !== null) {\n      labels.push(label);\n    }\n\n    // there might be more labels\n    listNode = walk(listNode, [['firstChild', Matchers]]);\n  }\n\n  // our labels-list is last-first, so we reverse it\n  labels.reverse();\n\n  return labels;\n}\n\nfunction resolvePipeError(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // for example `{level=\"info\"} |`\n  const exprNode = walk(node, [\n    ['parent', PipelineStage],\n    ['parent', PipelineExpr],\n  ]);\n\n  if (exprNode === null) {\n    return null;\n  }\n\n  const { parent } = exprNode;\n\n  if (parent === null) {\n    return null;\n  }\n\n  if (parent.type.id === LogExpr || parent.type.id === LogRangeExpr) {\n    return resolveLogOrLogRange(parent, text, pos, true);\n  }\n\n  return null;\n}\n\nfunction resolveLabelsForGrouping(node: SyntaxNode, text: string, pos: number): Situation | null {\n  const aggrExpNode = walk(node, [['parent', VectorAggregationExpr]]);\n  if (aggrExpNode === null) {\n    return null;\n  }\n  const bodyNode = aggrExpNode.getChild('MetricExpr');\n  if (bodyNode === null) {\n    return null;\n  }\n\n  const selectorNode = walk(bodyNode, [\n    ['firstChild', RangeAggregationExpr],\n    ['lastChild', LogRangeExpr],\n    ['firstChild', Selector],\n  ]);\n\n  if (selectorNode === null) {\n    return null;\n  }\n\n  const otherLabels = getLabels(selectorNode, text);\n\n  return {\n    type: 'IN_GROUPING',\n    otherLabels,\n  };\n}\n\nfunction resolveMatcher(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // we can arrive here for two reasons. `node` is either:\n  // - a StringNode (like in `{job=\"^\"}`)\n  // - or an error node (like in `{job=^}`)\n  const inStringNode = !node.type.isError;\n\n  const parent = walk(node, [['parent', Matcher]]);\n  if (parent === null) {\n    return null;\n  }\n\n  const labelNameNode = walk(parent, [['firstChild', Identifier]]);\n  if (labelNameNode === null) {\n    return null;\n  }\n\n  const labelName = getNodeText(labelNameNode, text);\n\n  // now we need to go up, to the parent of Matcher,\n  // there can be one or many `Matchers` parents, we have\n  // to go through all of them\n\n  const firstListNode = walk(parent, [['parent', Matchers]]);\n  if (firstListNode === null) {\n    return null;\n  }\n\n  let listNode = firstListNode;\n\n  // we keep going through the parent-nodes as long as they are Matchers.\n  // as soon as we reach Selector, we stop\n  let selectorNode: SyntaxNode | null = null;\n  while (selectorNode === null) {\n    const parent = listNode.parent;\n    if (parent === null) {\n      return null;\n    }\n\n    switch (parent.type.id) {\n      case Matchers:\n        //we keep looping\n        listNode = parent;\n        continue;\n      case Selector:\n        // we reached the end, we can stop the loop\n        selectorNode = parent;\n        continue;\n      default:\n        // we reached some other node, we stop\n        return null;\n    }\n  }\n\n  // now we need to find the other names\n  const allLabels = getLabels(selectorNode, text);\n\n  // we need to remove \"our\" label from all-labels, if it is in there\n  const otherLabels = allLabels.filter((label) => label.name !== labelName);\n\n  return {\n    type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME',\n    labelName,\n    betweenQuotes: inStringNode,\n    otherLabels,\n  };\n}\n\nfunction resolveTopLevel(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // we try a couply specific paths here.\n  // `{x=\"y\"}` situation, with the cursor at the end\n\n  const logExprNode = walk(node, [\n    ['lastChild', Expr],\n    ['lastChild', LogExpr],\n  ]);\n\n  if (logExprNode != null) {\n    return resolveLogOrLogRange(logExprNode, text, pos, false);\n  }\n\n  // `s` situation, with the cursor at the end.\n  // (basically, user enters a non-special characters as first\n  // character in query field)\n  const idNode = walk(node, [\n    ['firstChild', ERROR_NODE_ID],\n    ['firstChild', Identifier],\n  ]);\n\n  if (idNode != null) {\n    return {\n      type: 'AT_ROOT',\n    };\n  }\n\n  // no patterns match\n  return null;\n}\n\nfunction resolveDurations(node: SyntaxNode, text: string, pos: number): Situation {\n  return {\n    type: 'IN_DURATION',\n  };\n}\n\nfunction resolveLogRange(node: SyntaxNode, text: string, pos: number): Situation | null {\n  return resolveLogOrLogRange(node, text, pos, false);\n}\n\nfunction resolveLogRangeFromError(node: SyntaxNode, text: string, pos: number): Situation | null {\n  const parent = walk(node, [['parent', LogRangeExpr]]);\n  if (parent === null) {\n    return null;\n  }\n\n  return resolveLogOrLogRange(parent, text, pos, false);\n}\n\nfunction resolveLogOrLogRange(node: SyntaxNode, text: string, pos: number, afterPipe: boolean): Situation | null {\n  // here the `node` is either a LogExpr or a LogRangeExpr\n  // we want to handle the case where we are next to a selector\n  const selectorNode = walk(node, [['firstChild', Selector]]);\n\n  // we check that the selector is before the cursor, not after it\n  if (selectorNode != null && selectorNode.to <= pos) {\n    const labels = getLabels(selectorNode, text);\n    return {\n      type: 'AFTER_SELECTOR',\n      afterPipe,\n      labels,\n    };\n  }\n\n  return null;\n}\n\nfunction resolveSelector(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // for example `{^}`\n\n  // false positive:\n  // `{a=\"1\"^}`\n  const child = walk(node, [['firstChild', Matchers]]);\n  if (child !== null) {\n    // means the label-matching part contains at least one label already.\n    //\n    // in this case, we will need to have a `,` character at the end,\n    // to be able to suggest adding the next label.\n    // the area between the end-of-the-child-node and the cursor-pos\n    // must contain a `,` in this case.\n    const textToCheck = text.slice(child.to, pos);\n\n    if (!textToCheck.includes(',')) {\n      return null;\n    }\n  }\n\n  const otherLabels = getLabels(node, text);\n\n  return {\n    type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME',\n    otherLabels,\n  };\n}\n\n// we find the first error-node in the tree that is at the cursor-position.\n// NOTE: this might be too slow, might need to optimize it\n// (ideas: we do not need to go into every subtree, based on from/to)\n// also, only go to places that are in the sub-tree of the node found\n// by default by lezer. problem is, `next()` will go upward too,\n// and we do not want to go higher than our node\nfunction getErrorNode(tree: Tree, text: string, cursorPos: number): SyntaxNode | null {\n  // sometimes the cursor is a couple spaces after the end of the expression.\n  // to account for this situation, we \"move\" the cursor position back,\n  // so that there are no spaces between the end-of-expression and the cursor\n  const trimRightTextLen = text.trimEnd().length;\n  const pos = trimRightTextLen < cursorPos ? trimRightTextLen : cursorPos;\n  const cur = tree.cursorAt(pos);\n  do {\n    if (cur.from === pos && cur.to === pos) {\n      const { node } = cur;\n      if (node.type.isError) {\n        return node;\n      }\n    }\n  } while (cur.next());\n  return null;\n}\n\nexport function getSituation(text: string, pos: number): Situation | null {\n  // there is a special case when we are at the start of writing text,\n  // so we handle that case first\n\n  if (text === '') {\n    return {\n      type: 'EMPTY',\n    };\n  }\n\n  const tree = parser.parse(text);\n\n  // if the tree contains error, it is very probable that\n  // our node is one of those error nodes.\n  // also, if there are errors, the node lezer finds us,\n  // might not be the best node.\n  // so first we check if there is an error node at the cursor position\n  const maybeErrorNode = getErrorNode(tree, text, pos);\n\n  const cur = maybeErrorNode != null ? maybeErrorNode.cursor() : tree.cursorAt(pos);\n\n  const currentNode = cur.node;\n\n  const ids = [cur.type.id];\n  while (cur.parent()) {\n    ids.push(cur.type.id);\n  }\n\n  for (let resolver of RESOLVERS) {\n    if (isPathMatch(resolver.path, ids)) {\n      return resolver.fun(currentNode, text, pos);\n    }\n  }\n\n  return null;\n}\n","import type { Monaco, monacoTypes } from '@grafana/ui';\n\nimport { CompletionDataProvider } from './CompletionDataProvider';\nimport { NeverCaseError } from './NeverCaseError';\nimport { getCompletions, CompletionType } from './completions';\nimport { getSituation } from './situation';\n\n// from: monacoTypes.languages.CompletionItemInsertTextRule.InsertAsSnippet\nconst INSERT_AS_SNIPPET_ENUM_VALUE = 4;\n\nexport function getSuggestOptions(): monacoTypes.editor.ISuggestOptions {\n  return {\n    // monaco-editor sometimes provides suggestions automatically, i am not\n    // sure based on what, seems to be by analyzing the words already\n    // written.\n    // to try it out:\n    // - enter `go_goroutines{job~`\n    // - have the cursor at the end of the string\n    // - press ctrl-enter\n    // - you will get two suggestions\n    // those were not provided by grafana, they are offered automatically.\n    // i want to remove those. the only way i found is:\n    // - every suggestion-item has a `kind` attribute,\n    //   that controls the icon to the left of the suggestion.\n    // - items auto-generated by monaco have `kind` set to `text`.\n    // - we make sure grafana-provided suggestions do not have `kind` set to `text`.\n    // - and then we tell monaco not to show suggestions of kind `text`\n    showWords: false,\n  };\n}\n\nfunction getMonacoCompletionItemKind(type: CompletionType, monaco: Monaco): monacoTypes.languages.CompletionItemKind {\n  switch (type) {\n    case 'DURATION':\n      return monaco.languages.CompletionItemKind.Unit;\n    case 'FUNCTION':\n      return monaco.languages.CompletionItemKind.Variable;\n    case 'HISTORY':\n      return monaco.languages.CompletionItemKind.Snippet;\n    case 'LABEL_NAME':\n      return monaco.languages.CompletionItemKind.Enum;\n    case 'LABEL_VALUE':\n      return monaco.languages.CompletionItemKind.EnumMember;\n    case 'PATTERN':\n      return monaco.languages.CompletionItemKind.Constructor;\n    case 'PARSER':\n      return monaco.languages.CompletionItemKind.Class;\n    case 'LINE_FILTER':\n      return monaco.languages.CompletionItemKind.TypeParameter;\n    case 'PIPE_OPERATION':\n      return monaco.languages.CompletionItemKind.Interface;\n    default:\n      throw new NeverCaseError(type);\n  }\n}\nexport function getCompletionProvider(\n  monaco: Monaco,\n  dataProvider: CompletionDataProvider\n): monacoTypes.languages.CompletionItemProvider {\n  const provideCompletionItems = (\n    model: monacoTypes.editor.ITextModel,\n    position: monacoTypes.Position\n  ): monacoTypes.languages.ProviderResult<monacoTypes.languages.CompletionList> => {\n    const word = model.getWordAtPosition(position);\n    const range =\n      word != null\n        ? monaco.Range.lift({\n            startLineNumber: position.lineNumber,\n            endLineNumber: position.lineNumber,\n            startColumn: word.startColumn,\n            endColumn: word.endColumn,\n          })\n        : monaco.Range.fromPositions(position);\n    // documentation says `position` will be \"adjusted\" in `getOffsetAt`\n    // i don't know what that means, to be sure i clone it\n    const positionClone = {\n      column: position.column,\n      lineNumber: position.lineNumber,\n    };\n    const offset = model.getOffsetAt(positionClone);\n    const situation = getSituation(model.getValue(), offset);\n    const completionsPromise = situation != null ? getCompletions(situation, dataProvider) : Promise.resolve([]);\n    return completionsPromise.then((items) => {\n      // monaco by default alphabetically orders the items.\n      // to stop it, we use a number-as-string sortkey,\n      // so that monaco keeps the order we use\n      const maxIndexDigits = items.length.toString().length;\n      const suggestions: monacoTypes.languages.CompletionItem[] = items.map((item, index) => ({\n        kind: getMonacoCompletionItemKind(item.type, monaco),\n        label: item.label,\n        insertText: item.insertText,\n        insertTextRules: item.isSnippet ? INSERT_AS_SNIPPET_ENUM_VALUE : undefined,\n        detail: item.detail,\n        documentation: item.documentation,\n        sortText: index.toString().padStart(maxIndexDigits, '0'), // to force the order we have\n        range,\n        command: item.triggerOnInsert\n          ? {\n              id: 'editor.action.triggerSuggest',\n              title: '',\n            }\n          : undefined,\n      }));\n      return { suggestions };\n    });\n  };\n\n  return {\n    triggerCharacters: ['{', ',', '[', '(', '=', '~', ' ', '\"', '|'],\n    provideCompletionItems,\n  };\n}\n","import { HistoryItem } from '@grafana/data';\nimport { escapeLabelValueInExactSelector } from 'app/plugins/datasource/prometheus/language_utils';\n\nimport LanguageProvider from '../../../LanguageProvider';\nimport { LokiQuery } from '../../../types';\n\nimport { Label } from './situation';\n\nexport class CompletionDataProvider {\n  constructor(private languageProvider: LanguageProvider, private history: Array<HistoryItem<LokiQuery>> = []) {}\n\n  private buildSelector(labels: Label[]): string {\n    const allLabelTexts = labels.map(\n      (label) => `${label.name}${label.op}\"${escapeLabelValueInExactSelector(label.value)}\"`\n    );\n\n    return `{${allLabelTexts.join(',')}}`;\n  }\n\n  getHistory() {\n    return this.history.map((entry) => entry.query.expr).filter((expr) => expr !== undefined);\n  }\n\n  async getLabelNames(otherLabels: Label[] = []) {\n    if (otherLabels.length === 0) {\n      // if there is no filtering, we have to use a special endpoint\n      return this.languageProvider.getLabelKeys();\n    }\n    const data = await this.getSeriesLabels(otherLabels);\n    const possibleLabelNames = Object.keys(data); // all names from datasource\n    const usedLabelNames = new Set(otherLabels.map((l) => l.name)); // names used in the query\n    return possibleLabelNames.filter((label) => !usedLabelNames.has(label));\n  }\n\n  async getLabelValues(labelName: string, otherLabels: Label[]) {\n    if (otherLabels.length === 0) {\n      // if there is no filtering, we have to use a special endpoint\n      return await this.languageProvider.getLabelValues(labelName);\n    }\n\n    const data = await this.getSeriesLabels(otherLabels);\n    return data[labelName] ?? [];\n  }\n\n  async getParserAndLabelKeys(labels: Label[]) {\n    return await this.languageProvider.getParserAndLabelKeys(this.buildSelector(labels));\n  }\n\n  async getSeriesLabels(labels: Label[]) {\n    return await this.languageProvider.getSeriesLabels(this.buildSelector(labels)).then((data) => data ?? {});\n  }\n}\n","import { css } from '@emotion/css';\nimport React, { useRef, useEffect } from 'react';\nimport { useLatest } from 'react-use';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { languageConfiguration, monarchlanguage } from '@grafana/monaco-logql';\nimport { useTheme2, ReactMonacoEditor, Monaco, monacoTypes } from '@grafana/ui';\n\nimport { Props } from './MonacoQueryFieldProps';\nimport { getOverrideServices } from './getOverrideServices';\nimport { getCompletionProvider, getSuggestOptions } from './monaco-completion-provider';\nimport { CompletionDataProvider } from './monaco-completion-provider/CompletionDataProvider';\n\nconst options: monacoTypes.editor.IStandaloneEditorConstructionOptions = {\n  codeLens: false,\n  contextmenu: false,\n  // we need `fixedOverflowWidgets` because otherwise in grafana-dashboards\n  // the popup is clipped by the panel-visualizations.\n  fixedOverflowWidgets: true,\n  folding: false,\n  fontSize: 14,\n  lineDecorationsWidth: 8, // used as \"padding-left\"\n  lineNumbers: 'off',\n  minimap: { enabled: false },\n  overviewRulerBorder: false,\n  overviewRulerLanes: 0,\n  padding: {\n    // these numbers were picked so that visually this matches the previous version\n    // of the query-editor the best\n    top: 4,\n    bottom: 5,\n  },\n  renderLineHighlight: 'none',\n  scrollbar: {\n    vertical: 'hidden',\n    verticalScrollbarSize: 8, // used as \"padding-right\"\n    horizontal: 'hidden',\n    horizontalScrollbarSize: 0,\n  },\n  scrollBeyondLastLine: false,\n  suggest: getSuggestOptions(),\n  suggestFontSize: 12,\n  wordWrap: 'on',\n};\n\n// this number was chosen by testing various values. it might be necessary\n// because of the width of the border, not sure.\n//it needs to do 2 things:\n// 1. when the editor is single-line, it should make the editor height be visually correct\n// 2. when the editor is multi-line, the editor should not be \"scrollable\" (meaning,\n//    you do a scroll-movement in the editor, and it will scroll the content by a couple pixels\n//    up & down. this we want to avoid)\nconst EDITOR_HEIGHT_OFFSET = 2;\n\nconst LANG_ID = 'logql';\n\n// we must only run the lang-setup code once\nlet LANGUAGE_SETUP_STARTED = false;\n\nfunction ensureLogQL(monaco: Monaco) {\n  if (LANGUAGE_SETUP_STARTED === false) {\n    LANGUAGE_SETUP_STARTED = true;\n    monaco.languages.register({ id: LANG_ID });\n\n    monaco.languages.setMonarchTokensProvider(LANG_ID, monarchlanguage);\n    monaco.languages.setLanguageConfiguration(LANG_ID, languageConfiguration);\n  }\n}\n\nconst getStyles = (theme: GrafanaTheme2) => {\n  return {\n    container: css`\n      border-radius: ${theme.shape.borderRadius()};\n      border: 1px solid ${theme.components.input.borderColor};\n    `,\n  };\n};\n\nconst MonacoQueryField = ({ languageProvider, history, onBlur, onRunQuery, initialValue }: Props) => {\n  const id = uuidv4();\n  // we need only one instance of `overrideServices` during the lifetime of the react component\n  const overrideServicesRef = useRef(getOverrideServices());\n  const containerRef = useRef<HTMLDivElement>(null);\n  const langProviderRef = useLatest(languageProvider);\n  const historyRef = useLatest(history);\n  const onRunQueryRef = useLatest(onRunQuery);\n  const onBlurRef = useLatest(onBlur);\n\n  const autocompleteCleanupCallback = useRef<(() => void) | null>(null);\n\n  const theme = useTheme2();\n  const styles = getStyles(theme);\n\n  useEffect(() => {\n    // when we unmount, we unregister the autocomplete-function, if it was registered\n    return () => {\n      autocompleteCleanupCallback.current?.();\n    };\n  }, []);\n\n  return (\n    <div\n      aria-label={selectors.components.QueryField.container}\n      className={styles.container}\n      // NOTE: we will be setting inline-style-width/height on this element\n      ref={containerRef}\n    >\n      <ReactMonacoEditor\n        overrideServices={overrideServicesRef.current}\n        options={options}\n        language={LANG_ID}\n        value={initialValue}\n        beforeMount={(monaco) => {\n          ensureLogQL(monaco);\n        }}\n        onMount={(editor, monaco) => {\n          // Monaco has a bug where it runs actions on all instances (https://github.com/microsoft/monaco-editor/issues/2947), so we ensure actions are executed on instance-level with this ContextKey.\n          const isEditorFocused = editor.createContextKey<boolean>('isEditorFocused' + id, false);\n          // we setup on-blur\n          editor.onDidBlurEditorWidget(() => {\n            isEditorFocused.set(false);\n            onBlurRef.current(editor.getValue());\n          });\n          const dataProvider = new CompletionDataProvider(langProviderRef.current, historyRef.current);\n          const completionProvider = getCompletionProvider(monaco, dataProvider);\n\n          // completion-providers in monaco are not registered directly to editor-instances,\n          // they are registered to languages. this makes it hard for us to have\n          // separate completion-providers for every query-field-instance\n          // (but we need that, because they might connect to different datasources).\n          // the trick we do is, we wrap the callback in a \"proxy\",\n          // and in the proxy, the first thing is, we check if we are called from\n          // \"our editor instance\", and if not, we just return nothing. if yes,\n          // we call the completion-provider.\n          const filteringCompletionProvider: monacoTypes.languages.CompletionItemProvider = {\n            ...completionProvider,\n            provideCompletionItems: (model, position, context, token) => {\n              // if the model-id does not match, then this call is from a different editor-instance,\n              // not \"our instance\", so return nothing\n              if (editor.getModel()?.id !== model.id) {\n                return { suggestions: [] };\n              }\n              return completionProvider.provideCompletionItems(model, position, context, token);\n            },\n          };\n\n          const { dispose } = monaco.languages.registerCompletionItemProvider(LANG_ID, filteringCompletionProvider);\n\n          autocompleteCleanupCallback.current = dispose;\n          // this code makes the editor resize itself so that the content fits\n          // (it will grow taller when necessary)\n          // FIXME: maybe move this functionality into CodeEditor, like:\n          // <CodeEditor resizingMode=\"single-line\"/>\n          const updateElementHeight = () => {\n            const containerDiv = containerRef.current;\n            if (containerDiv !== null) {\n              const pixelHeight = editor.getContentHeight();\n              containerDiv.style.height = `${pixelHeight + EDITOR_HEIGHT_OFFSET}px`;\n              containerDiv.style.width = '100%';\n              const pixelWidth = containerDiv.clientWidth;\n              editor.layout({ width: pixelWidth, height: pixelHeight });\n            }\n          };\n\n          editor.onDidContentSizeChange(updateElementHeight);\n          updateElementHeight();\n          // handle: shift + enter\n          // FIXME: maybe move this functionality into CodeEditor?\n          editor.addCommand(\n            monaco.KeyMod.Shift | monaco.KeyCode.Enter,\n            () => {\n              onRunQueryRef.current(editor.getValue());\n            },\n            'isEditorFocused' + id\n          );\n\n          editor.onDidFocusEditorText(() => {\n            isEditorFocused.set(true);\n            if (editor.getValue().trim() === '') {\n              editor.trigger('', 'editor.action.triggerSuggest', {});\n            }\n          });\n        }}\n      />\n    </div>\n  );\n};\n\n// Default export for lazy load.\nexport default MonacoQueryField;\n","import { useRef } from 'react';\nvar useLatest = function (value) {\n    var ref = useRef(value);\n    ref.current = value;\n    return ref;\n};\nexport default useLatest;\n"],"names":["exports","wordPattern","comments","lineComment","brackets","autoClosingPairs","open","close","surroundingPairs","folding","vector_matching","vectorMatchingRegex","concat","reduce","prev","curr","keywords","ignoreCase","defaultToken","tokenPostfix","operators","vectorMatching","symbols","escapes","digits","octaldigits","binarydigits","hexdigits","integersuffix","floatsuffix","tokenizer","root","cases","include","string_double","token","string_single","string_backtick","clauses","whitespace","overrideServices","storageService","strings","Map","set","toString","onDidChangeValue","data","onDidChangeTarget","onWillSaveState","get","key","scope","fallbackValue","getBoolean","val","undefined","getNumber","parseInt","store","value","target","delete","remove","keys","Array","from","logStorage","console","log","migrate","Promise","resolve","isNew","flush","reason","makeStorageService","NeverCaseError","Error","constructor","super","JSON","stringify","LOG_COMPLETIONS","type","label","insertText","isSnippet","triggerOnInsert","AGGREGATION_COMPLETIONS","AGGREGATION_OPERATORS","f","detail","documentation","FUNCTION_COMPLETIONS","RANGE_VEC_FUNCTIONS","DURATION_COMPLETIONS","map","text","LINE_FILTER_COMPLETIONS","operator","explainOperator","LokiOperationId","afterPipe","getLineFilterCompletions","filter","completion","replace","PARSERS","async","getCompletions","situation","dataProvider","historyCompletions","getHistory","expr","getAllHistoryCompletions","otherLabels","extractedLabelKeys","getParserAndLabelKeys","getInGroupingCompletions","getLabelNames","getLabelNamesForSelectorCompletions","labelName","betweenQuotes","getLabelValues","escapeLabelValueInExactSelector","getLabelValuesForMetricCompletions","labels","hasJSON","hasLogfmt","allParsers","Set","completions","prefix","hasLevelInExtractedLabels","some","extra","push","sort","forEach","parser","getAfterSelectorCompletions","move","node","direction","walk","path","current","expectedNode","id","getNodeText","slice","to","isPathMatch","resolverPath","cursorPath","every","item","index","RESOLVERS","Selector","fun","pos","child","Matchers","includes","getLabels","LogQL","logExprNode","Expr","LogExpr","resolveLogOrLogRange","Identifier","String","Matcher","resolveMatcher","Grouping","aggrExpNode","VectorAggregationExpr","bodyNode","getChild","selectorNode","RangeAggregationExpr","LogRangeExpr","Range","parent","LiteralExpr","MetricExpr","PipelineStage","PipelineExpr","exprNode","LABEL_OP_MAP","getLabel","matcherNode","nameNode","opNode","nextSibling","op","name","getLabelOp","valueNode","inside","length","startsWith","endsWith","parseStringLiteral","listNode","reverse","inStringNode","isError","labelNameNode","firstListNode","getMonacoCompletionItemKind","monaco","languages","CompletionItemKind","Unit","Variable","Snippet","Enum","EnumMember","Constructor","Class","TypeParameter","Interface","getCompletionProvider","triggerCharacters","provideCompletionItems","model","position","word","getWordAtPosition","range","lift","startLineNumber","lineNumber","endLineNumber","startColumn","endColumn","fromPositions","positionClone","column","offset","getOffsetAt","tree","maybeErrorNode","cursorPos","trimRightTextLen","trimEnd","cur","cursorAt","next","getErrorNode","cursor","currentNode","ids","resolver","getSituation","getValue","then","items","maxIndexDigits","suggestions","kind","insertTextRules","sortText","padStart","command","title","CompletionDataProvider","languageProvider","history","buildSelector","join","this","entry","query","getLabelKeys","getSeriesLabels","possibleLabelNames","Object","usedLabelNames","l","has","options","codeLens","contextmenu","fixedOverflowWidgets","fontSize","lineDecorationsWidth","lineNumbers","minimap","enabled","overviewRulerBorder","overviewRulerLanes","padding","top","bottom","renderLineHighlight","scrollbar","vertical","verticalScrollbarSize","horizontal","horizontalScrollbarSize","scrollBeyondLastLine","suggest","showWords","suggestFontSize","wordWrap","LANG_ID","LANGUAGE_SETUP_STARTED","onBlur","onRunQuery","initialValue","uuidv4","overrideServicesRef","useRef","containerRef","langProviderRef","useLatest","historyRef","onRunQueryRef","onBlurRef","autocompleteCleanupCallback","styles","theme","container","css","shape","borderRadius","components","input","borderColor","getStyles","useTheme2","useEffect","selectors","className","ref","language","beforeMount","register","setMonarchTokensProvider","monarchlanguage","setLanguageConfiguration","languageConfiguration","ensureLogQL","onMount","editor","isEditorFocused","createContextKey","onDidBlurEditorWidget","completionProvider","filteringCompletionProvider","context","getModel","dispose","registerCompletionItemProvider","updateElementHeight","containerDiv","pixelHeight","getContentHeight","style","height","width","pixelWidth","clientWidth","layout","onDidContentSizeChange","addCommand","KeyMod","Shift","KeyCode","Enter","onDidFocusEditorText","trim","trigger"],"sourceRoot":""}