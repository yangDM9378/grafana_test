{"version":3,"file":"zipkinPlugin.c7cc91526b52b05854e7.js","mappings":"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","sources":["webpack://grafana/./public/app/core/utils/tracing.ts","webpack://grafana/./public/app/plugins/datasource/zipkin/constants.ts","webpack://grafana/./public/app/plugins/datasource/zipkin/QueryField.tsx","webpack://grafana/./public/app/plugins/datasource/zipkin/utils/graphTransform.ts","webpack://grafana/./public/app/plugins/datasource/zipkin/datasource.ts","webpack://grafana/./public/app/plugins/datasource/zipkin/module.ts","webpack://grafana/./public/app/plugins/datasource/zipkin/ConfigEditor.tsx","webpack://grafana/./public/app/plugins/datasource/zipkin/utils/transforms.ts","webpack://grafana/./.yarn/__virtual__/react-use-virtual-0c21d950b6/3/opt/drone/yarncache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/useMount.js"],"sourcesContent":["/**\n * Get non overlapping duration of the ranges as they can overlap or have gaps.\n */\nimport { FieldType, MutableDataFrame, NodeGraphDataFrameFieldNames as Fields } from '@grafana/data';\n\nexport function getNonOverlappingDuration(ranges: Array<[number, number]>): number {\n  ranges.sort((a, b) => a[0] - b[0]);\n  const mergedRanges = ranges.reduce((acc, range) => {\n    if (!acc.length) {\n      return [range];\n    }\n    const tail = acc.slice(-1)[0];\n    const [prevStart, prevEnd] = tail;\n    const [start, end] = range;\n    if (end < prevEnd) {\n      // In this case the range is completely inside the prev range so we can just ignore it.\n      return acc;\n    }\n\n    if (start > prevEnd) {\n      // There is no overlap so we can just add it to stack\n      return [...acc, range];\n    }\n\n    // We know there is overlap and current range ends later than previous so we can just extend the range\n    return [...acc.slice(0, -1), [prevStart, end]] as Array<[number, number]>;\n  }, [] as Array<[number, number]>);\n\n  return mergedRanges.reduce((acc, range) => {\n    return acc + (range[1] - range[0]);\n  }, 0);\n}\n\n/**\n * Returns a map of the spans with children array for easier processing. It will also contain empty spans in case\n * span is missing but other spans are its children. This is more generic because it needs to allow iterating over\n * both arrays and dataframe views.\n */\nexport function makeSpanMap<T>(getSpan: (index: number) => { span: T; id: string; parentIds: string[] } | undefined): {\n  [id: string]: { span: T; children: string[] };\n} {\n  const spanMap: { [id: string]: { span?: T; children: string[] } } = {};\n\n  let span;\n  for (let index = 0; (span = getSpan(index)), !!span; index++) {\n    if (!spanMap[span.id]) {\n      spanMap[span.id] = {\n        span: span.span,\n        children: [],\n      };\n    } else {\n      spanMap[span.id].span = span.span;\n    }\n\n    for (const parentId of span.parentIds) {\n      if (parentId) {\n        if (!spanMap[parentId]) {\n          spanMap[parentId] = {\n            span: undefined,\n            children: [span.id],\n          };\n        } else {\n          spanMap[parentId].children.push(span.id);\n        }\n      }\n    }\n  }\n  return spanMap as { [id: string]: { span: T; children: string[] } };\n}\n\nexport function getStats(duration: number, traceDuration: number, selfDuration: number) {\n  return {\n    main: `${toFixedNoTrailingZeros(duration)}ms (${toFixedNoTrailingZeros((duration / traceDuration) * 100)}%)`,\n    secondary: `${toFixedNoTrailingZeros(selfDuration)}ms (${toFixedNoTrailingZeros(\n      (selfDuration / duration) * 100\n    )}%)`,\n  };\n}\n\nfunction toFixedNoTrailingZeros(n: number) {\n  return parseFloat(n.toFixed(2));\n}\n\n/**\n * Create default frames used when returning data for node graph.\n */\nexport function makeFrames() {\n  const nodesFrame = new MutableDataFrame({\n    fields: [\n      { name: Fields.id, type: FieldType.string },\n      { name: Fields.title, type: FieldType.string },\n      { name: Fields.subTitle, type: FieldType.string },\n      { name: Fields.mainStat, type: FieldType.string, config: { displayName: 'Total time (% of trace)' } },\n      { name: Fields.secondaryStat, type: FieldType.string, config: { displayName: 'Self time (% of total)' } },\n      {\n        name: Fields.color,\n        type: FieldType.number,\n        config: { color: { mode: 'continuous-GrYlRd' }, displayName: 'Self time / Trace duration' },\n      },\n    ],\n    meta: {\n      preferredVisualisationType: 'nodeGraph',\n    },\n  });\n\n  const edgesFrame = new MutableDataFrame({\n    fields: [\n      { name: Fields.id, type: FieldType.string },\n      { name: Fields.target, type: FieldType.string },\n      { name: Fields.source, type: FieldType.string },\n    ],\n    meta: {\n      preferredVisualisationType: 'nodeGraph',\n    },\n  });\n\n  return [nodesFrame, edgesFrame];\n}\n","export const apiPrefix = '/api/v2';\n","import { css } from '@emotion/css';\nimport { fromPairs } from 'lodash';\nimport React, { useCallback, useMemo, useState } from 'react';\nimport { useAsyncFn, useMount, useMountedState } from 'react-use';\nimport { AsyncState } from 'react-use/lib/useAsyncFn';\n\nimport { GrafanaTheme2, QueryEditorProps } from '@grafana/data';\nimport {\n  ButtonCascader,\n  CascaderOption,\n  FileDropzone,\n  InlineField,\n  InlineFieldRow,\n  RadioButtonGroup,\n  useTheme2,\n  QueryField,\n  useStyles2,\n} from '@grafana/ui';\nimport { notifyApp } from 'app/core/actions';\nimport { createErrorNotification } from 'app/core/copy/appNotification';\nimport { dispatch } from 'app/store/store';\n\nimport { apiPrefix } from './constants';\nimport { ZipkinDatasource } from './datasource';\nimport { ZipkinQuery, ZipkinQueryType, ZipkinSpan } from './types';\n\ntype Props = QueryEditorProps<ZipkinDatasource, ZipkinQuery>;\n\nconst getStyles = (theme: GrafanaTheme2) => {\n  return {\n    tracesCascader: css({\n      label: 'tracesCascader',\n      marginRight: theme.spacing(1),\n    }),\n  };\n};\n\nexport const ZipkinQueryField = ({ query, onChange, onRunQuery, datasource }: Props) => {\n  const serviceOptions = useServices(datasource);\n  const theme = useTheme2();\n  const styles = useStyles2(getStyles);\n  const { onLoadOptions, allOptions } = useLoadOptions(datasource);\n\n  const onSelectTrace = useCallback(\n    (values: string[], selectedOptions: CascaderOption[]) => {\n      if (selectedOptions.length === 3) {\n        const traceID = selectedOptions[2].value;\n        onChange({ ...query, query: traceID });\n        onRunQuery();\n      }\n    },\n    [onChange, onRunQuery, query]\n  );\n\n  const onChangeQuery = (value: string) => {\n    const nextQuery = { ...query, query: value };\n    onChange(nextQuery);\n  };\n\n  let cascaderOptions = useMapToCascaderOptions(serviceOptions, allOptions);\n\n  return (\n    <>\n      <InlineFieldRow>\n        <InlineField label=\"Query type\">\n          <RadioButtonGroup<ZipkinQueryType>\n            options={[\n              { value: 'traceID', label: 'TraceID' },\n              { value: 'upload', label: 'JSON File' },\n            ]}\n            value={query.queryType || 'traceID'}\n            onChange={(v) =>\n              onChange({\n                ...query,\n                queryType: v,\n              })\n            }\n            size=\"md\"\n          />\n        </InlineField>\n      </InlineFieldRow>\n      {query.queryType === 'upload' ? (\n        <div className={css({ padding: theme.spacing(2) })}>\n          <FileDropzone\n            options={{ multiple: false }}\n            onLoad={(result) => {\n              datasource.uploadedJson = result;\n              onRunQuery();\n            }}\n          />\n        </div>\n      ) : (\n        <InlineFieldRow>\n          <ButtonCascader\n            options={cascaderOptions}\n            onChange={onSelectTrace}\n            loadData={onLoadOptions}\n            variant=\"secondary\"\n            buttonProps={{ className: styles.tracesCascader }}\n          >\n            Traces\n          </ButtonCascader>\n          <div className=\"gf-form gf-form--grow flex-shrink-1 min-width-15\">\n            <QueryField\n              query={query.query}\n              onChange={onChangeQuery}\n              onRunQuery={onRunQuery}\n              placeholder={'Insert Trace ID (run with Shift+Enter)'}\n              portalOrigin=\"zipkin\"\n            />\n          </div>\n        </InlineFieldRow>\n      )}\n    </>\n  );\n};\n\n// Exported for tests\nexport function useServices(datasource: ZipkinDatasource): AsyncState<CascaderOption[]> {\n  const url = `${apiPrefix}/services`;\n\n  const [servicesOptions, fetch] = useAsyncFn(async (): Promise<CascaderOption[]> => {\n    try {\n      const services: string[] | null = await datasource.metadataRequest(url);\n      if (services) {\n        return services.sort().map((service) => ({\n          label: service,\n          value: service,\n          isLeaf: false,\n        }));\n      }\n      return [];\n    } catch (error) {\n      const errorToShow = error instanceof Error ? error : 'An unknown error occurred';\n      dispatch(notifyApp(createErrorNotification('Failed to load services from Zipkin', errorToShow)));\n      throw error;\n    }\n  }, [datasource]);\n\n  useMount(() => {\n    // We should probably call this periodically to get new services after mount.\n    fetch();\n  });\n\n  return servicesOptions;\n}\n\ntype OptionsState = {\n  [serviceName: string]: {\n    [spanName: string]: {\n      [traceId: string]: string;\n    };\n  };\n};\n\n// Exported for tests\nexport function useLoadOptions(datasource: ZipkinDatasource) {\n  const isMounted = useMountedState();\n  const [allOptions, setAllOptions] = useState({} as OptionsState);\n\n  const [, fetchSpans] = useAsyncFn(\n    async function findSpans(service: string): Promise<void> {\n      const url = `${apiPrefix}/spans`;\n      try {\n        // The response of this should have been full ZipkinSpan objects based on API docs but is just list\n        // of span names.\n        // TODO: check if this is some issue of version used or something else\n        const response: string[] = await datasource.metadataRequest(url, { serviceName: service });\n        if (isMounted()) {\n          setAllOptions((state) => {\n            const spanOptions = fromPairs(response.map((span: string) => [span, undefined]));\n            return {\n              ...state,\n              [service]: spanOptions as any,\n            };\n          });\n        }\n      } catch (error) {\n        const errorToShow = error instanceof Error ? error : 'An unknown error occurred';\n        dispatch(notifyApp(createErrorNotification('Failed to load spans from Zipkin', errorToShow)));\n        throw error;\n      }\n    },\n    [datasource, allOptions]\n  );\n\n  const [, fetchTraces] = useAsyncFn(\n    async function findTraces(serviceName: string, spanName: string): Promise<void> {\n      const url = `${apiPrefix}/traces`;\n      const search = {\n        serviceName,\n        spanName,\n        // See other params and default here https://zipkin.io/zipkin-api/#/default/get_traces\n      };\n      try {\n        // This should return just root traces as there isn't any nesting\n        const traces: ZipkinSpan[][] = await datasource.metadataRequest(url, search);\n        if (isMounted()) {\n          const newTraces = traces.length\n            ? fromPairs(\n                traces.map((trace) => {\n                  const rootSpan = trace.find((span) => !span.parentId)!;\n\n                  return [`${rootSpan.name} [${Math.floor(rootSpan.duration / 1000)} ms]`, rootSpan.traceId];\n                })\n              )\n            : noTracesOptions;\n\n          setAllOptions((state) => {\n            const spans = state[serviceName];\n            return {\n              ...state,\n              [serviceName]: {\n                ...spans,\n                [spanName]: newTraces,\n              },\n            };\n          });\n        }\n      } catch (error) {\n        const errorToShow = error instanceof Error ? error : 'An unknown error occurred';\n        dispatch(notifyApp(createErrorNotification('Failed to load spans from Zipkin', errorToShow)));\n        throw error;\n      }\n    },\n    [datasource]\n  );\n\n  const onLoadOptions = useCallback(\n    (selectedOptions: CascaderOption[]) => {\n      const service = selectedOptions[0].value;\n      if (selectedOptions.length === 1) {\n        fetchSpans(service);\n      } else if (selectedOptions.length === 2) {\n        const spanName = selectedOptions[1].value;\n        fetchTraces(service, spanName);\n      }\n    },\n    [fetchSpans, fetchTraces]\n  );\n\n  return {\n    onLoadOptions,\n    allOptions,\n  };\n}\n\nfunction useMapToCascaderOptions(services: AsyncState<CascaderOption[]>, allOptions: OptionsState) {\n  return useMemo(() => {\n    let cascaderOptions: CascaderOption[] = [];\n\n    if (services.value && services.value.length) {\n      cascaderOptions = services.value.map((services) => {\n        return {\n          ...services,\n          children:\n            allOptions[services.value] &&\n            Object.keys(allOptions[services.value]).map((spanName) => {\n              return {\n                label: spanName,\n                value: spanName,\n                isLeaf: false,\n                children:\n                  allOptions[services.value][spanName] &&\n                  Object.keys(allOptions[services.value][spanName]).map((traceName) => {\n                    return {\n                      label: traceName,\n                      value: allOptions[services.value][spanName][traceName],\n                    };\n                  }),\n              };\n            }),\n        };\n      });\n    } else if (services.value && !services.value.length) {\n      cascaderOptions = noTracesFoundOptions;\n    }\n\n    return cascaderOptions;\n  }, [services, allOptions]);\n}\n\nconst NO_TRACES_KEY = '__NO_TRACES__';\nconst noTracesFoundOptions = [\n  {\n    label: 'No traces found',\n    value: 'no_traces',\n    isLeaf: true,\n\n    // Cannot be disabled because then cascader shows 'loading' for some reason.\n    // disabled: true,\n  },\n];\n\nconst noTracesOptions = {\n  '[No traces in time range]': NO_TRACES_KEY,\n};\n","import { DataFrame, NodeGraphDataFrameFieldNames as Fields } from '@grafana/data';\n\nimport { getNonOverlappingDuration, getStats, makeFrames, makeSpanMap } from '../../../../core/utils/tracing';\nimport { ZipkinSpan } from '../types';\n\ninterface Node {\n  [Fields.id]: string;\n  [Fields.title]: string;\n  [Fields.subTitle]: string;\n  [Fields.mainStat]: string;\n  [Fields.secondaryStat]: string;\n  [Fields.color]: number;\n}\n\ninterface Edge {\n  [Fields.id]: string;\n  [Fields.target]: string;\n  [Fields.source]: string;\n}\n\nexport function createGraphFrames(data: ZipkinSpan[]): DataFrame[] {\n  const { nodes, edges } = convertTraceToGraph(data);\n  const [nodesFrame, edgesFrame] = makeFrames();\n\n  for (const node of nodes) {\n    nodesFrame.add(node);\n  }\n\n  for (const edge of edges) {\n    edgesFrame.add(edge);\n  }\n\n  return [nodesFrame, edgesFrame];\n}\n\nfunction convertTraceToGraph(spans: ZipkinSpan[]): { nodes: Node[]; edges: Edge[] } {\n  const nodes: Node[] = [];\n  const edges: Edge[] = [];\n\n  const traceDuration = findTraceDuration(spans);\n  const spanMap = makeSpanMap((index) => {\n    if (index >= spans.length) {\n      return undefined;\n    }\n    return {\n      span: spans[index],\n      id: spans[index].id,\n      parentIds: spans[index].parentId ? [spans[index].parentId!] : [],\n    };\n  });\n\n  for (const span of spans) {\n    const ranges: Array<[number, number]> = spanMap[span.id].children.map((c) => {\n      const span = spanMap[c].span;\n      return [span.timestamp, span.timestamp + span.duration];\n    });\n    const childrenDuration = getNonOverlappingDuration(ranges);\n    const selfDuration = span.duration - childrenDuration;\n    const stats = getStats(span.duration / 1000, traceDuration / 1000, selfDuration / 1000);\n\n    nodes.push({\n      [Fields.id]: span.id,\n      [Fields.title]: span.localEndpoint?.serviceName || span.remoteEndpoint?.serviceName || 'unknown',\n      [Fields.subTitle]: span.name,\n      [Fields.mainStat]: stats.main,\n      [Fields.secondaryStat]: stats.secondary,\n      [Fields.color]: selfDuration / traceDuration,\n    });\n\n    if (span.parentId && spanMap[span.parentId].span) {\n      edges.push({\n        [Fields.id]: span.parentId + '--' + span.id,\n        [Fields.target]: span.id,\n        [Fields.source]: span.parentId,\n      });\n    }\n  }\n\n  return { nodes, edges };\n}\n\n/**\n * Get the duration of the whole trace as it isn't a part of the response data.\n * Note: Seems like this should be the same as just longest span, but this is probably safer.\n */\nfunction findTraceDuration(spans: ZipkinSpan[]): number {\n  let traceEndTime = 0;\n  let traceStartTime = Infinity;\n\n  for (const span of spans) {\n    if (span.timestamp < traceStartTime) {\n      traceStartTime = span.timestamp;\n    }\n\n    if (span.timestamp + span.duration > traceEndTime) {\n      traceEndTime = span.timestamp + span.duration;\n    }\n  }\n  return traceEndTime - traceStartTime;\n}\n","import { lastValueFrom, Observable, of } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nimport {\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceApi,\n  DataSourceInstanceSettings,\n  DataSourceJsonData,\n  FieldType,\n  MutableDataFrame,\n  ScopedVars,\n} from '@grafana/data';\nimport { BackendSrvRequest, FetchResponse, getBackendSrv, getTemplateSrv, TemplateSrv } from '@grafana/runtime';\nimport { SpanBarOptions } from '@jaegertracing/jaeger-ui-components';\nimport { NodeGraphOptions } from 'app/core/components/NodeGraphSettings';\n\nimport { serializeParams } from '../../../core/utils/fetch';\n\nimport { apiPrefix } from './constants';\nimport { ZipkinQuery, ZipkinSpan } from './types';\nimport { createGraphFrames } from './utils/graphTransform';\nimport { transformResponse } from './utils/transforms';\n\nexport interface ZipkinJsonData extends DataSourceJsonData {\n  nodeGraph?: NodeGraphOptions;\n}\n\nexport class ZipkinDatasource extends DataSourceApi<ZipkinQuery, ZipkinJsonData> {\n  uploadedJson: string | ArrayBuffer | null = null;\n  nodeGraph?: NodeGraphOptions;\n  spanBar?: SpanBarOptions;\n  constructor(\n    private instanceSettings: DataSourceInstanceSettings<ZipkinJsonData>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv()\n  ) {\n    super(instanceSettings);\n    this.nodeGraph = instanceSettings.jsonData.nodeGraph;\n  }\n\n  query(options: DataQueryRequest<ZipkinQuery>): Observable<DataQueryResponse> {\n    const target = options.targets[0];\n    if (target.queryType === 'upload') {\n      if (!this.uploadedJson) {\n        return of({ data: [] });\n      }\n\n      try {\n        const traceData = JSON.parse(this.uploadedJson as string);\n        return of(responseToDataQueryResponse({ data: traceData }, this.nodeGraph?.enabled));\n      } catch (error) {\n        return of({ error: { message: 'JSON is not valid Zipkin format' }, data: [] });\n      }\n    }\n\n    if (target.query) {\n      const query = this.applyVariables(target, options.scopedVars);\n      return this.request<ZipkinSpan[]>(`${apiPrefix}/trace/${encodeURIComponent(query.query)}`).pipe(\n        map((res) => responseToDataQueryResponse(res, this.nodeGraph?.enabled))\n      );\n    }\n    return of(emptyDataQueryResponse);\n  }\n\n  async metadataRequest(url: string, params?: Record<string, any>): Promise<any> {\n    const res = await lastValueFrom(this.request(url, params, { hideFromInspector: true }));\n    return res.data;\n  }\n\n  async testDatasource(): Promise<{ status: string; message: string }> {\n    await this.metadataRequest(`${apiPrefix}/services`);\n    return { status: 'success', message: 'Data source is working' };\n  }\n\n  getQueryDisplayText(query: ZipkinQuery): string {\n    return query.query;\n  }\n\n  interpolateVariablesInQueries(queries: ZipkinQuery[], scopedVars: ScopedVars): ZipkinQuery[] {\n    if (!queries || queries.length === 0) {\n      return [];\n    }\n\n    return queries.map((query) => {\n      return {\n        ...query,\n        datasource: this.getRef(),\n        ...this.applyVariables(query, scopedVars),\n      };\n    });\n  }\n\n  applyVariables(query: ZipkinQuery, scopedVars: ScopedVars) {\n    const expandedQuery = { ...query };\n\n    return {\n      ...expandedQuery,\n      query: this.templateSrv.replace(query.query ?? '', scopedVars),\n    };\n  }\n\n  private request<T = any>(\n    apiUrl: string,\n    data?: any,\n    options?: Partial<BackendSrvRequest>\n  ): Observable<FetchResponse<T>> {\n    const params = data ? serializeParams(data) : '';\n    const url = `${this.instanceSettings.url}${apiUrl}${params.length ? `?${params}` : ''}`;\n    const req = {\n      ...options,\n      url,\n    };\n\n    return getBackendSrv().fetch<T>(req);\n  }\n}\n\nfunction responseToDataQueryResponse(response: { data: ZipkinSpan[] }, nodeGraph = false): DataQueryResponse {\n  let data = response?.data ? [transformResponse(response?.data)] : [];\n  if (nodeGraph) {\n    data.push(...createGraphFrames(response?.data));\n  }\n  return {\n    data,\n  };\n}\n\nconst emptyDataQueryResponse = {\n  data: [\n    new MutableDataFrame({\n      fields: [\n        {\n          name: 'trace',\n          type: FieldType.trace,\n          values: [],\n        },\n      ],\n      meta: {\n        preferredVisualisationType: 'trace',\n        custom: {\n          traceFormat: 'zipkin',\n        },\n      },\n    }),\n  ],\n};\n","import { DataSourcePlugin } from '@grafana/data';\n\nimport { ConfigEditor } from './ConfigEditor';\nimport { ZipkinQueryField } from './QueryField';\nimport { ZipkinDatasource } from './datasource';\n\nexport const plugin = new DataSourcePlugin(ZipkinDatasource)\n  .setQueryEditor(ZipkinQueryField)\n  .setConfigEditor(ConfigEditor);\n","import React from 'react';\n\nimport { DataSourcePluginOptionsEditorProps } from '@grafana/data';\nimport { config } from '@grafana/runtime';\nimport { DataSourceHttpSettings } from '@grafana/ui';\nimport { SpanBarSettings } from '@jaegertracing/jaeger-ui-components';\nimport { NodeGraphSettings } from 'app/core/components/NodeGraphSettings';\nimport { TraceToLogsSettings } from 'app/core/components/TraceToLogs/TraceToLogsSettings';\nimport { TraceToMetricsSettings } from 'app/core/components/TraceToMetrics/TraceToMetricsSettings';\n\nexport type Props = DataSourcePluginOptionsEditorProps;\n\nexport const ConfigEditor = ({ options, onOptionsChange }: Props) => {\n  return (\n    <>\n      <DataSourceHttpSettings\n        defaultUrl=\"http://localhost:9411\"\n        dataSourceConfig={options}\n        showAccessOptions={false}\n        onChange={onOptionsChange}\n      />\n\n      <div className=\"gf-form-group\">\n        <TraceToLogsSettings options={options} onOptionsChange={onOptionsChange} />\n      </div>\n\n      {config.featureToggles.traceToMetrics ? (\n        <div className=\"gf-form-group\">\n          <TraceToMetricsSettings options={options} onOptionsChange={onOptionsChange} />\n        </div>\n      ) : null}\n\n      <div className=\"gf-form-group\">\n        <NodeGraphSettings options={options} onOptionsChange={onOptionsChange} />\n      </div>\n\n      <div className=\"gf-form-group\">\n        <SpanBarSettings options={options} onOptionsChange={onOptionsChange} />\n      </div>\n    </>\n  );\n};\n","import { identity } from 'lodash';\n\nimport { DataFrame, FieldType, MutableDataFrame, TraceKeyValuePair, TraceLog, TraceSpanRow } from '@grafana/data';\n\nimport { ZipkinAnnotation, ZipkinEndpoint, ZipkinSpan } from '../types';\n\n/**\n * Transforms response to Grafana trace data frame.\n */\nexport function transformResponse(zSpans: ZipkinSpan[]): DataFrame {\n  const spanRows = zSpans.map(transformSpan);\n  const frame = new MutableDataFrame({\n    fields: [\n      { name: 'traceID', type: FieldType.string },\n      { name: 'spanID', type: FieldType.string },\n      { name: 'parentSpanID', type: FieldType.string },\n      { name: 'operationName', type: FieldType.string },\n      { name: 'serviceName', type: FieldType.string },\n      { name: 'serviceTags', type: FieldType.other },\n      { name: 'startTime', type: FieldType.number },\n      { name: 'duration', type: FieldType.number },\n      { name: 'logs', type: FieldType.other },\n      { name: 'tags', type: FieldType.other },\n    ],\n    meta: {\n      preferredVisualisationType: 'trace',\n      custom: {\n        traceFormat: 'zipkin',\n      },\n    },\n  });\n\n  for (const span of spanRows) {\n    frame.add(span);\n  }\n\n  return frame;\n}\n\nfunction transformSpan(span: ZipkinSpan): TraceSpanRow {\n  const row = {\n    traceID: span.traceId,\n    spanID: span.id,\n    parentSpanID: span.parentId,\n    operationName: span.name,\n    serviceName: span.localEndpoint?.serviceName || span.remoteEndpoint?.serviceName || 'unknown',\n    serviceTags: serviceTags(span),\n    startTime: span.timestamp / 1000,\n    duration: span.duration / 1000,\n    logs: span.annotations?.map(transformAnnotation) ?? [],\n    tags: Object.keys(span.tags || {}).reduce<TraceKeyValuePair[]>((acc, key) => {\n      // If tag is error we remap it to simple boolean so that the trace ui will show an error icon.\n      if (key === 'error') {\n        acc.push({\n          key: 'error',\n          value: true,\n        });\n\n        acc.push({\n          key: 'errorValue',\n          value: span.tags!['error'],\n        });\n        return acc;\n      }\n      acc.push({ key, value: span.tags![key] });\n      return acc;\n    }, []),\n  };\n\n  if (span.kind) {\n    row.tags = [\n      {\n        key: 'kind',\n        value: span.kind,\n      },\n      ...(row.tags ?? []),\n    ];\n  }\n\n  if (span.shared) {\n    row.tags = [\n      {\n        key: 'shared',\n        value: span.shared,\n      },\n      ...(row.tags ?? []),\n    ];\n  }\n\n  return row;\n}\n\n/**\n * Maps annotations as a log as that seems to be the closest thing.\n * See https://zipkin.io/zipkin-api/#/default/get_trace__traceId_\n */\nfunction transformAnnotation(annotation: ZipkinAnnotation): TraceLog {\n  return {\n    timestamp: annotation.timestamp,\n    fields: [\n      {\n        key: 'annotation',\n        value: annotation.value,\n      },\n    ],\n  };\n}\n\nfunction serviceTags(span: ZipkinSpan): TraceKeyValuePair[] {\n  const endpoint = span.localEndpoint || span.remoteEndpoint;\n  if (!endpoint) {\n    return [];\n  }\n  return [\n    valueToTag('ipv4', endpoint.ipv4),\n    valueToTag('ipv6', endpoint.ipv6),\n    valueToTag('port', endpoint.port),\n    valueToTag('endpointType', span.localEndpoint ? 'local' : 'remote'),\n  ].filter(identity) as TraceKeyValuePair[];\n}\n\nfunction valueToTag<T>(key: string, value: T): TraceKeyValuePair<T> | undefined {\n  if (!value) {\n    return undefined;\n  }\n  return {\n    key,\n    value,\n  };\n}\n\n/**\n * Transforms data frame to Zipkin response\n */\nexport const transformToZipkin = (data: MutableDataFrame): ZipkinSpan[] => {\n  let response: ZipkinSpan[] = [];\n\n  for (let i = 0; i < data.length; i++) {\n    const span = data.get(i);\n    response.push({\n      traceId: span.traceID,\n      parentId: span.parentSpanID,\n      name: span.operationName,\n      id: span.spanID,\n      timestamp: span.startTime * 1000,\n      duration: span.duration * 1000,\n      ...getEndpoint(span),\n      annotations: span.logs.length\n        ? span.logs.map((l: TraceLog) => ({ timestamp: l.timestamp, value: l.fields[0].value }))\n        : undefined,\n      tags: span.tags.length\n        ? span.tags\n            .filter((t: TraceKeyValuePair) => t.key !== 'kind' && t.key !== 'endpointType' && t.key !== 'shared')\n            .reduce((tags: { [key: string]: string }, t: TraceKeyValuePair) => {\n              if (t.key === 'error') {\n                return {\n                  ...tags,\n                  [t.key]: span.tags.find((t: TraceKeyValuePair) => t.key === 'errorValue').value || '',\n                };\n              }\n              return { ...tags, [t.key]: t.value };\n            }, {})\n        : undefined,\n      kind: span.tags.find((t: TraceKeyValuePair) => t.key === 'kind')?.value,\n      shared: span.tags.find((t: TraceKeyValuePair) => t.key === 'shared')?.value,\n    });\n  }\n\n  return response;\n};\n\n// Returns remote or local endpoint object\nconst getEndpoint = (span: any): { [key: string]: ZipkinEndpoint } | undefined => {\n  const key =\n    span.serviceTags.find((t: TraceKeyValuePair) => t.key === 'endpointType')?.value === 'local'\n      ? 'localEndpoint'\n      : 'remoteEndpoint';\n  return span.serviceName !== 'unknown'\n    ? {\n        [key]: {\n          serviceName: span.serviceName,\n          ipv4: span.serviceTags.find((t: TraceKeyValuePair) => t.key === 'ipv4')?.value,\n          ipv6: span.serviceTags.find((t: TraceKeyValuePair) => t.key === 'ipv6')?.value,\n          port: span.serviceTags.find((t: TraceKeyValuePair) => t.key === 'port')?.value,\n        },\n      }\n    : undefined;\n};\n","import useEffectOnce from './useEffectOnce';\nvar useMount = function (fn) {\n    useEffectOnce(function () {\n        fn();\n    });\n};\nexport default useMount;\n"],"names":["getNonOverlappingDuration","ranges","sort","a","b","reduce","acc","range","length","tail","slice","prevStart","prevEnd","start","end","makeSpanMap","getSpan","spanMap","span","index","id","children","parentId","parentIds","push","undefined","getStats","duration","traceDuration","selfDuration","main","toFixedNoTrailingZeros","secondary","n","parseFloat","toFixed","makeFrames","MutableDataFrame","fields","name","Fields","type","FieldType","config","displayName","color","mode","meta","preferredVisualisationType","getStyles","theme","tracesCascader","css","label","marginRight","spacing","noTracesFoundOptions","value","isLeaf","noTracesOptions","createGraphFrames","data","nodes","edges","spans","traceEndTime","traceStartTime","Infinity","timestamp","findTraceDuration","map","c","childrenDuration","stats","localEndpoint","serviceName","remoteEndpoint","convertTraceToGraph","nodesFrame","edgesFrame","node","add","edge","ZipkinDatasource","DataSourceApi","constructor","instanceSettings","templateSrv","getTemplateSrv","super","this","nodeGraph","jsonData","query","options","target","targets","queryType","uploadedJson","of","traceData","JSON","parse","responseToDataQueryResponse","enabled","error","message","applyVariables","scopedVars","request","encodeURIComponent","pipe","res","emptyDataQueryResponse","async","url","params","lastValueFrom","hideFromInspector","metadataRequest","status","getQueryDisplayText","interpolateVariablesInQueries","queries","datasource","getRef","expandedQuery","replace","apiUrl","serializeParams","req","getBackendSrv","fetch","response","transformResponse","values","custom","traceFormat","plugin","DataSourcePlugin","setQueryEditor","onChange","onRunQuery","serviceOptions","servicesOptions","useAsyncFn","services","service","errorToShow","Error","dispatch","notifyApp","createErrorNotification","useMount","useServices","useTheme2","styles","useStyles2","onLoadOptions","allOptions","isMounted","useMountedState","setAllOptions","useState","fetchSpans","state","spanOptions","fromPairs","fetchTraces","spanName","search","traces","newTraces","trace","rootSpan","find","Math","floor","traceId","useCallback","selectedOptions","useLoadOptions","onSelectTrace","traceID","cascaderOptions","useMemo","Object","keys","traceName","useMapToCascaderOptions","InlineFieldRow","InlineField","RadioButtonGroup","v","size","className","padding","FileDropzone","multiple","onLoad","result","ButtonCascader","loadData","variant","buttonProps","QueryField","nextQuery","placeholder","portalOrigin","setConfigEditor","onOptionsChange","DataSourceHttpSettings","defaultUrl","dataSourceConfig","showAccessOptions","TraceToLogsSettings","TraceToMetricsSettings","NodeGraphSettings","zSpans","spanRows","transformSpan","frame","row","spanID","parentSpanID","operationName","serviceTags","startTime","logs","annotations","transformAnnotation","tags","key","kind","shared","annotation","endpoint","valueToTag","ipv4","ipv6","port","filter","identity","transformToZipkin","i","get","getEndpoint","l","t","fn"],"sourceRoot":""}