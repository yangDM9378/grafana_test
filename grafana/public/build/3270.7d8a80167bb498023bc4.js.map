{"version":3,"file":"3270.7d8a80167bb498023bc4.js","mappings":"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","sources":["webpack://grafana/./public/app/features/dashboard/state/initDashboard.ts","webpack://grafana/./public/app/features/dashboard/state/analyticsProcessor.ts","webpack://grafana/./public/app/features/explore/AddToDashboard/addToDashboard.ts","webpack://grafana/./public/app/features/explore/AddToDashboard/AddToDashboardModal.tsx","webpack://grafana/./public/app/features/explore/AddToDashboard/index.tsx"],"sourcesContent":["import { DataQuery, locationUtil, setWeekStart, DashboardLoadedEvent } from '@grafana/data';\nimport { config, isFetchError, locationService } from '@grafana/runtime';\nimport { notifyApp } from 'app/core/actions';\nimport appEvents from 'app/core/app_events';\nimport { createErrorNotification } from 'app/core/copy/appNotification';\nimport { backendSrv } from 'app/core/services/backend_srv';\nimport { KeybindingSrv } from 'app/core/services/keybindingSrv';\nimport store from 'app/core/store';\nimport { dashboardLoaderSrv } from 'app/features/dashboard/services/DashboardLoaderSrv';\nimport { DashboardSrv, getDashboardSrv } from 'app/features/dashboard/services/DashboardSrv';\nimport { getTimeSrv, TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { dashboardWatcher } from 'app/features/live/dashboard/dashboardWatcher';\nimport { playlistSrv } from 'app/features/playlist/PlaylistSrv';\nimport { toStateKey } from 'app/features/variables/utils';\nimport { DashboardDTO, DashboardInitPhase, DashboardRoutes, StoreState, ThunkDispatch, ThunkResult } from 'app/types';\n\nimport { createDashboardQueryRunner } from '../../query/state/DashboardQueryRunner/DashboardQueryRunner';\nimport { initVariablesTransaction } from '../../variables/state/actions';\nimport { getIfExistsLastKey } from '../../variables/state/selectors';\n\nimport { DashboardModel } from './DashboardModel';\nimport { PanelModel } from './PanelModel';\nimport { emitDashboardViewEvent } from './analyticsProcessor';\nimport { dashboardInitCompleted, dashboardInitFailed, dashboardInitFetching, dashboardInitServices } from './reducers';\n\nexport interface InitDashboardArgs {\n  urlUid?: string;\n  urlSlug?: string;\n  urlType?: string;\n  urlFolderId?: string;\n  panelType?: string;\n  accessToken?: string;\n  routeName?: string;\n  fixUrl: boolean;\n  keybindingSrv: KeybindingSrv;\n}\n\nasync function fetchDashboard(\n  args: InitDashboardArgs,\n  dispatch: ThunkDispatch,\n  getState: () => StoreState\n): Promise<DashboardDTO | null> {\n  // When creating new or adding panels to a dashboard from explore we load it from local storage\n  const model = store.getObject<DashboardDTO>(DASHBOARD_FROM_LS_KEY);\n  if (model) {\n    removeDashboardToFetchFromLocalStorage();\n    return model;\n  }\n\n  try {\n    switch (args.routeName) {\n      case DashboardRoutes.Home: {\n        // load home dash\n        const dashDTO: DashboardDTO = await backendSrv.get('/api/dashboards/home');\n\n        // if user specified a custom home dashboard redirect to that\n        if (dashDTO.redirectUri) {\n          const newUrl = locationUtil.stripBaseFromUrl(dashDTO.redirectUri);\n          locationService.replace(newUrl);\n          return null;\n        }\n\n        // disable some actions on the default home dashboard\n        dashDTO.meta.canSave = false;\n        dashDTO.meta.canShare = false;\n        dashDTO.meta.canStar = false;\n        return dashDTO;\n      }\n      case DashboardRoutes.Public: {\n        return await dashboardLoaderSrv.loadDashboard('public', args.urlSlug, args.accessToken);\n      }\n      case DashboardRoutes.Normal: {\n        const dashDTO: DashboardDTO = await dashboardLoaderSrv.loadDashboard(args.urlType, args.urlSlug, args.urlUid);\n\n        if (args.fixUrl && dashDTO.meta.url && !playlistSrv.isPlaying) {\n          // check if the current url is correct (might be old slug)\n          const dashboardUrl = locationUtil.stripBaseFromUrl(dashDTO.meta.url);\n          const currentPath = locationService.getLocation().pathname;\n\n          if (dashboardUrl !== currentPath) {\n            // Spread current location to persist search params used for navigation\n            locationService.replace({\n              ...locationService.getLocation(),\n              pathname: dashboardUrl,\n            });\n            console.log('not correct url correcting', dashboardUrl, currentPath);\n          }\n        }\n        return dashDTO;\n      }\n      case DashboardRoutes.New: {\n        return getNewDashboardModelData(args.urlFolderId, args.panelType);\n      }\n      case DashboardRoutes.Path: {\n        const path = args.urlSlug ?? '';\n        return await dashboardLoaderSrv.loadDashboard(DashboardRoutes.Path, path, path);\n      }\n      default:\n        throw { message: 'Unknown route ' + args.routeName };\n    }\n  } catch (err) {\n    // Ignore cancelled errors\n    if (isFetchError(err) && err.cancelled) {\n      return null;\n    }\n\n    dispatch(dashboardInitFailed({ message: 'Failed to fetch dashboard', error: err }));\n    console.error(err);\n    return null;\n  }\n}\n\nconst getQueriesByDatasource = (\n  panels: PanelModel[],\n  queries: { [datasourceId: string]: DataQuery[] } = {}\n): { [datasourceId: string]: DataQuery[] } => {\n  panels.forEach((panel) => {\n    if (panel.panels) {\n      getQueriesByDatasource(panel.panels, queries);\n    } else if (panel.targets) {\n      panel.targets.forEach((target) => {\n        if (target.datasource?.type) {\n          if (queries[target.datasource.type]) {\n            queries[target.datasource.type].push(target);\n          } else {\n            queries[target.datasource.type] = [target];\n          }\n        }\n      });\n    }\n  });\n  return queries;\n};\n\n/**\n * This action (or saga) does everything needed to bootstrap a dashboard & dashboard model.\n * First it handles the process of fetching the dashboard, correcting the url if required (causing redirects/url updates)\n *\n * This is used both for single dashboard & solo panel routes, home & new dashboard routes.\n *\n * Then it handles the initializing of the old angular services that the dashboard components & panels still depend on\n *\n */\nexport function initDashboard(args: InitDashboardArgs): ThunkResult<void> {\n  return async (dispatch, getState) => {\n    // set fetching state\n    dispatch(dashboardInitFetching());\n\n    // fetch dashboard data\n    const dashDTO = await fetchDashboard(args, dispatch, getState);\n\n    // returns null if there was a redirect or error\n    if (!dashDTO) {\n      return;\n    }\n\n    // set initializing state\n    dispatch(dashboardInitServices());\n\n    // create model\n    let dashboard: DashboardModel;\n    try {\n      dashboard = new DashboardModel(dashDTO.dashboard, dashDTO.meta);\n    } catch (err) {\n      dispatch(dashboardInitFailed({ message: 'Failed create dashboard model', error: err }));\n      console.error(err);\n      return;\n    }\n\n    // add missing orgId query param\n    const storeState = getState();\n    const queryParams = locationService.getSearchObject();\n\n    if (!queryParams.orgId) {\n      // TODO this is currently not possible with the LocationService API\n      locationService.partial({ orgId: storeState.user.orgId }, true);\n    }\n\n    // init services\n    const timeSrv: TimeSrv = getTimeSrv();\n    const dashboardSrv: DashboardSrv = getDashboardSrv();\n\n    // legacy srv state, we need this value updated for built-in annotations\n    dashboardSrv.setCurrent(dashboard);\n\n    timeSrv.init(dashboard);\n\n    const dashboardUid = toStateKey(args.urlUid ?? dashboard.uid);\n    // template values service needs to initialize completely before the rest of the dashboard can load\n    await dispatch(initVariablesTransaction(dashboardUid, dashboard));\n\n    // DashboardQueryRunner needs to run after all variables have been resolved so that any annotation query including a variable\n    // will be correctly resolved\n    const runner = createDashboardQueryRunner({ dashboard, timeSrv });\n    runner.run({ dashboard, range: timeSrv.timeRange() });\n\n    if (getIfExistsLastKey(getState()) !== dashboardUid) {\n      // if a previous dashboard has slow running variable queries the batch uid will be the new one\n      // but the args.urlUid will be the same as before initVariablesTransaction was called so then we can't continue initializing\n      // the previous dashboard.\n      return;\n    }\n\n    // If dashboard is in a different init phase it means it cancelled during service init\n    if (getState().dashboard.initPhase !== DashboardInitPhase.Services) {\n      return;\n    }\n\n    try {\n      dashboard.processRepeats();\n\n      // handle auto fix experimental feature\n      if (queryParams.autofitpanels) {\n        dashboard.autoFitPanels(window.innerHeight, queryParams.kiosk);\n      }\n\n      args.keybindingSrv.setupDashboardBindings(dashboard);\n    } catch (err) {\n      if (err instanceof Error) {\n        dispatch(notifyApp(createErrorNotification('Dashboard init failed', err)));\n      }\n      console.error(err);\n    }\n\n    // send open dashboard event\n    if (args.routeName !== DashboardRoutes.New) {\n      emitDashboardViewEvent(dashboard);\n\n      // Listen for changes on the current dashboard\n      dashboardWatcher.watch(dashboard.uid);\n    } else {\n      dashboardWatcher.leave();\n    }\n\n    // set week start\n    if (dashboard.weekStart !== '') {\n      setWeekStart(dashboard.weekStart);\n    } else {\n      setWeekStart(config.bootData.user.weekStart);\n    }\n\n    // Propagate an app-wide event about the dashboard being loaded\n    appEvents.publish(\n      new DashboardLoadedEvent({\n        dashboardId: dashboard.uid,\n        orgId: storeState.user.orgId,\n        userId: storeState.user.user?.id,\n        grafanaVersion: config.buildInfo.version,\n        queries: getQueriesByDatasource(dashboard.panels),\n      })\n    );\n\n    // yay we are done\n    dispatch(dashboardInitCompleted(dashboard));\n  };\n}\n\nexport function getNewDashboardModelData(urlFolderId?: string, panelType?: string): any {\n  const data = {\n    meta: {\n      canStar: false,\n      canShare: false,\n      canDelete: false,\n      isNew: true,\n      folderId: 0,\n    },\n    dashboard: {\n      title: 'New dashboard',\n      panels: [\n        {\n          type: panelType ?? 'add-panel',\n          gridPos: { x: 0, y: 0, w: 12, h: 9 },\n          title: 'Panel Title',\n        },\n      ],\n    },\n  };\n\n  if (urlFolderId) {\n    data.meta.folderId = parseInt(urlFolderId, 10);\n  }\n\n  return data;\n}\n\nconst DASHBOARD_FROM_LS_KEY = 'DASHBOARD_FROM_LS_KEY';\n\nexport function setDashboardToFetchFromLocalStorage(model: DashboardDTO) {\n  store.setObject(DASHBOARD_FROM_LS_KEY, model);\n}\n\nexport function removeDashboardToFetchFromLocalStorage() {\n  store.delete(DASHBOARD_FROM_LS_KEY);\n}\n","import { reportMetaAnalytics, MetaAnalyticsEventName, DashboardViewEventPayload } from '@grafana/runtime';\n\nimport { DashboardModel } from './DashboardModel';\n\nexport function emitDashboardViewEvent(dashboard: DashboardModel) {\n  const eventData: DashboardViewEventPayload = {\n    dashboardId: dashboard.id,\n    dashboardName: dashboard.title,\n    dashboardUid: dashboard.uid,\n    folderName: dashboard.meta.folderTitle,\n    eventName: MetaAnalyticsEventName.DashboardView,\n    publicDashboardUid: dashboard.meta.publicDashboardUid,\n  };\n\n  reportMetaAnalytics(eventData);\n}\n","import { DataFrame, DataQuery, DataSourceRef } from '@grafana/data';\nimport { backendSrv } from 'app/core/services/backend_srv';\nimport {\n  getNewDashboardModelData,\n  setDashboardToFetchFromLocalStorage,\n} from 'app/features/dashboard/state/initDashboard';\nimport { DashboardDTO, ExplorePanelData } from 'app/types';\n\nexport enum AddToDashboardError {\n  FETCH_DASHBOARD = 'fetch-dashboard',\n  SET_DASHBOARD_LS = 'set-dashboard-ls-error',\n}\n\ninterface AddPanelToDashboardOptions {\n  queries: DataQuery[];\n  queryResponse: ExplorePanelData;\n  datasource?: DataSourceRef;\n  dashboardUid?: string;\n}\n\nfunction createDashboard(): DashboardDTO {\n  const dto = getNewDashboardModelData();\n\n  // getNewDashboardModelData adds by default the \"add-panel\" panel. We don't want that.\n  dto.dashboard.panels = [];\n\n  return dto;\n}\n\nexport async function setDashboardInLocalStorage(options: AddPanelToDashboardOptions) {\n  const panelType = getPanelType(options.queries, options.queryResponse);\n  const panel = {\n    targets: options.queries,\n    type: panelType,\n    title: 'New Panel',\n    gridPos: { x: 0, y: 0, w: 12, h: 8 },\n    datasource: options.datasource,\n  };\n\n  let dto: DashboardDTO;\n\n  if (options.dashboardUid) {\n    try {\n      dto = await backendSrv.getDashboardByUid(options.dashboardUid);\n    } catch (e) {\n      throw AddToDashboardError.FETCH_DASHBOARD;\n    }\n  } else {\n    dto = createDashboard();\n  }\n\n  dto.dashboard.panels = [panel, ...(dto.dashboard.panels ?? [])];\n\n  try {\n    setDashboardToFetchFromLocalStorage(dto);\n  } catch {\n    throw AddToDashboardError.SET_DASHBOARD_LS;\n  }\n}\n\nconst isVisible = (query: DataQuery) => !query.hide;\nconst hasRefId = (refId: DataFrame['refId']) => (frame: DataFrame) => frame.refId === refId;\n\nfunction getPanelType(queries: DataQuery[], queryResponse: ExplorePanelData) {\n  for (const { refId } of queries.filter(isVisible)) {\n    const hasQueryRefId = hasRefId(refId);\n    if (queryResponse.flameGraphFrames.some(hasQueryRefId)) {\n      return 'flamegraph';\n    }\n    if (queryResponse.graphFrames.some(hasQueryRefId)) {\n      return 'timeseries';\n    }\n    if (queryResponse.logsFrames.some(hasQueryRefId)) {\n      return 'logs';\n    }\n    if (queryResponse.nodeGraphFrames.some(hasQueryRefId)) {\n      return 'nodeGraph';\n    }\n    if (queryResponse.traceFrames.some(hasQueryRefId)) {\n      return 'traces';\n    }\n  }\n\n  // falling back to table\n  return 'table';\n}\n","import { partial } from 'lodash';\nimport React, { useEffect, useState } from 'react';\nimport { DeepMap, FieldError, useForm } from 'react-hook-form';\n\nimport { locationUtil, SelectableValue } from '@grafana/data';\nimport { config, locationService, reportInteraction } from '@grafana/runtime';\nimport { Alert, Button, Field, InputControl, Modal, RadioButtonGroup } from '@grafana/ui';\nimport { DashboardPicker } from 'app/core/components/Select/DashboardPicker';\nimport { contextSrv } from 'app/core/services/context_srv';\nimport { removeDashboardToFetchFromLocalStorage } from 'app/features/dashboard/state/initDashboard';\nimport { ExploreId, AccessControlAction, useSelector } from 'app/types';\n\nimport { getExploreItemSelector } from '../state/selectors';\n\nimport { setDashboardInLocalStorage, AddToDashboardError } from './addToDashboard';\n\nenum SaveTarget {\n  NewDashboard = 'new-dashboard',\n  ExistingDashboard = 'existing-dashboard',\n}\n\ninterface SaveTargetDTO {\n  saveTarget: SaveTarget;\n}\ninterface SaveToNewDashboardDTO extends SaveTargetDTO {\n  saveTarget: SaveTarget.NewDashboard;\n}\n\ninterface SaveToExistingDashboard extends SaveTargetDTO {\n  saveTarget: SaveTarget.ExistingDashboard;\n  dashboardUid: string;\n}\n\ntype FormDTO = SaveToNewDashboardDTO | SaveToExistingDashboard;\n\nfunction assertIsSaveToExistingDashboardError(\n  errors: DeepMap<FormDTO, FieldError>\n): asserts errors is DeepMap<SaveToExistingDashboard, FieldError> {\n  // the shape of the errors object is always compatible with the type above, but we need to\n  // explicitly assert its type so that TS can narrow down FormDTO to SaveToExistingDashboard\n  // when we use it in the form.\n}\n\nfunction getDashboardURL(dashboardUid?: string) {\n  return dashboardUid ? `d/${dashboardUid}` : 'dashboard/new';\n}\n\nenum GenericError {\n  UNKNOWN = 'unknown-error',\n  NAVIGATION = 'navigation-error',\n}\n\ninterface SubmissionError {\n  error: AddToDashboardError | GenericError;\n  message: string;\n}\n\ninterface Props {\n  onClose: () => void;\n  exploreId: ExploreId;\n}\n\nexport const AddToDashboardModal = ({ onClose, exploreId }: Props) => {\n  const exploreItem = useSelector(getExploreItemSelector(exploreId))!;\n  const [submissionError, setSubmissionError] = useState<SubmissionError | undefined>();\n  const {\n    handleSubmit,\n    control,\n    formState: { errors },\n    watch,\n  } = useForm<FormDTO>({\n    defaultValues: { saveTarget: SaveTarget.NewDashboard },\n  });\n\n  const canCreateDashboard = contextSrv.hasAccess(AccessControlAction.DashboardsCreate, contextSrv.isEditor);\n  const canWriteDashboard = contextSrv.hasAccess(AccessControlAction.DashboardsWrite, contextSrv.isEditor);\n\n  const saveTargets: Array<SelectableValue<SaveTarget>> = [];\n  if (canCreateDashboard) {\n    saveTargets.push({\n      label: 'New dashboard',\n      value: SaveTarget.NewDashboard,\n    });\n  }\n  if (canWriteDashboard) {\n    saveTargets.push({\n      label: 'Existing dashboard',\n      value: SaveTarget.ExistingDashboard,\n    });\n  }\n\n  const saveTarget = saveTargets.length > 1 ? watch('saveTarget') : saveTargets[0].value;\n\n  const modalTitle = `Add panel to ${saveTargets.length > 1 ? 'dashboard' : saveTargets[0].label!.toLowerCase()}`;\n\n  const onSubmit = async (openInNewTab: boolean, data: FormDTO) => {\n    setSubmissionError(undefined);\n    const dashboardUid = data.saveTarget === SaveTarget.ExistingDashboard ? data.dashboardUid : undefined;\n\n    reportInteraction('e_2_d_submit', {\n      newTab: openInNewTab,\n      saveTarget: data.saveTarget,\n      queries: exploreItem.queries.length,\n    });\n\n    try {\n      await setDashboardInLocalStorage({\n        dashboardUid,\n        datasource: exploreItem.datasourceInstance?.getRef(),\n        queries: exploreItem.queries,\n        queryResponse: exploreItem.queryResponse,\n      });\n    } catch (error) {\n      switch (error) {\n        case AddToDashboardError.FETCH_DASHBOARD:\n          setSubmissionError({ error, message: 'Could not fetch dashboard information. Please try again.' });\n          break;\n        case AddToDashboardError.SET_DASHBOARD_LS:\n          setSubmissionError({ error, message: 'Could not add panel to dashboard. Please try again.' });\n          break;\n        default:\n          setSubmissionError({ error: GenericError.UNKNOWN, message: 'Something went wrong. Please try again.' });\n      }\n      return;\n    }\n\n    const dashboardURL = getDashboardURL(dashboardUid);\n    if (!openInNewTab) {\n      onClose();\n      locationService.push(locationUtil.stripBaseFromUrl(dashboardURL));\n      return;\n    }\n\n    const didTabOpen = !!global.open(config.appUrl + dashboardURL, '_blank');\n    if (!didTabOpen) {\n      setSubmissionError({\n        error: GenericError.NAVIGATION,\n        message: 'Could not navigate to the selected dashboard. Please try again.',\n      });\n      removeDashboardToFetchFromLocalStorage();\n      return;\n    }\n    onClose();\n  };\n\n  useEffect(() => {\n    reportInteraction('e_2_d_open');\n  }, []);\n\n  return (\n    <Modal title={modalTitle} onDismiss={onClose} isOpen>\n      <form>\n        {saveTargets.length > 1 && (\n          <InputControl\n            control={control}\n            render={({ field: { ref, ...field } }) => (\n              <Field label=\"Target dashboard\" description=\"Choose where to add the panel.\">\n                <RadioButtonGroup options={saveTargets} {...field} id=\"e2d-save-target\" />\n              </Field>\n            )}\n            name=\"saveTarget\"\n          />\n        )}\n\n        {saveTarget === SaveTarget.ExistingDashboard &&\n          (() => {\n            assertIsSaveToExistingDashboardError(errors);\n            return (\n              <InputControl\n                render={({ field: { ref, value, onChange, ...field } }) => (\n                  <Field\n                    label=\"Dashboard\"\n                    description=\"Select in which dashboard the panel will be created.\"\n                    error={errors.dashboardUid?.message}\n                    invalid={!!errors.dashboardUid}\n                  >\n                    <DashboardPicker\n                      {...field}\n                      inputId=\"e2d-dashboard-picker\"\n                      defaultOptions\n                      onChange={(d) => onChange(d?.uid)}\n                    />\n                  </Field>\n                )}\n                control={control}\n                name=\"dashboardUid\"\n                shouldUnregister\n                rules={{ required: { value: true, message: 'This field is required.' } }}\n              />\n            );\n          })()}\n\n        {submissionError && (\n          <Alert severity=\"error\" title=\"Error adding the panel\">\n            {submissionError.message}\n          </Alert>\n        )}\n\n        <Modal.ButtonRow>\n          <Button type=\"reset\" onClick={onClose} fill=\"outline\" variant=\"secondary\">\n            Cancel\n          </Button>\n          <Button\n            type=\"submit\"\n            variant=\"secondary\"\n            onClick={handleSubmit(partial(onSubmit, true))}\n            icon=\"external-link-alt\"\n          >\n            Open in new tab\n          </Button>\n          <Button type=\"submit\" variant=\"primary\" onClick={handleSubmit(partial(onSubmit, false))} icon=\"apps\">\n            Open dashboard\n          </Button>\n        </Modal.ButtonRow>\n      </form>\n    </Modal>\n  );\n};\n","import React, { useState } from 'react';\n\nimport { ToolbarButton } from '@grafana/ui';\nimport { ExploreId, useSelector } from 'app/types';\n\nimport { getExploreItemSelector } from '../state/selectors';\n\nimport { AddToDashboardModal } from './AddToDashboardModal';\n\ninterface Props {\n  exploreId: ExploreId;\n}\n\nexport const AddToDashboard = ({ exploreId }: Props) => {\n  const [isOpen, setIsOpen] = useState(false);\n  const selectExploreItem = getExploreItemSelector(exploreId);\n  const explorePaneHasQueries = !!useSelector(selectExploreItem)?.queries?.length;\n\n  return (\n    <>\n      <ToolbarButton\n        icon=\"apps\"\n        onClick={() => setIsOpen(true)}\n        aria-label=\"Add to dashboard\"\n        disabled={!explorePaneHasQueries}\n      >\n        Add to dashboard\n      </ToolbarButton>\n\n      {isOpen && <AddToDashboardModal onClose={() => setIsOpen(false)} exploreId={exploreId} />}\n    </>\n  );\n};\n"],"names":["getQueriesByDatasource","panels","queries","forEach","panel","targets","target","datasource","type","push","initDashboard","args","async","dispatch","getState","dashboardInitFetching","dashDTO","model","store","DASHBOARD_FROM_LS_KEY","removeDashboardToFetchFromLocalStorage","routeName","DashboardRoutes","backendSrv","redirectUri","newUrl","locationUtil","locationService","meta","canSave","canShare","canStar","dashboardLoaderSrv","urlSlug","accessToken","urlType","urlUid","fixUrl","url","playlistSrv","dashboardUrl","currentPath","pathname","console","log","getNewDashboardModelData","urlFolderId","panelType","path","message","err","isFetchError","cancelled","dashboardInitFailed","error","fetchDashboard","dashboard","dashboardInitServices","DashboardModel","storeState","queryParams","orgId","user","timeSrv","getTimeSrv","getDashboardSrv","setCurrent","init","dashboardUid","toStateKey","uid","initVariablesTransaction","createDashboardQueryRunner","run","range","timeRange","getIfExistsLastKey","initPhase","DashboardInitPhase","processRepeats","autofitpanels","autoFitPanels","window","innerHeight","kiosk","keybindingSrv","setupDashboardBindings","Error","notifyApp","createErrorNotification","eventData","dashboardId","id","dashboardName","title","folderName","folderTitle","eventName","MetaAnalyticsEventName","publicDashboardUid","reportMetaAnalytics","emitDashboardViewEvent","dashboardWatcher","weekStart","setWeekStart","config","appEvents","DashboardLoadedEvent","userId","grafanaVersion","dashboardInitCompleted","data","canDelete","isNew","folderId","gridPos","x","y","w","h","parseInt","setDashboardToFetchFromLocalStorage","AddToDashboardError","setDashboardInLocalStorage","options","queryResponse","refId","filter","isVisible","hasQueryRefId","hasRefId","flameGraphFrames","some","graphFrames","logsFrames","nodeGraphFrames","traceFrames","getPanelType","dto","e","FETCH_DASHBOARD","createDashboard","SET_DASHBOARD_LS","query","hide","frame","SaveTarget","GenericError","AddToDashboardModal","onClose","exploreId","exploreItem","useSelector","getExploreItemSelector","submissionError","setSubmissionError","useState","handleSubmit","control","formState","errors","watch","useForm","defaultValues","saveTarget","NewDashboard","canCreateDashboard","contextSrv","AccessControlAction","canWriteDashboard","saveTargets","label","value","ExistingDashboard","length","modalTitle","toLowerCase","onSubmit","openInNewTab","undefined","reportInteraction","newTab","datasourceInstance","getRef","UNKNOWN","dashboardURL","getDashboardURL","global","open","NAVIGATION","useEffect","Modal","onDismiss","isOpen","InputControl","render","field","Field","description","RadioButtonGroup","name","onChange","invalid","DashboardPicker","inputId","defaultOptions","d","shouldUnregister","rules","required","Alert","severity","Button","onClick","fill","variant","partial","icon","AddToDashboard","setIsOpen","selectExploreItem","explorePaneHasQueries","ToolbarButton","disabled"],"sourceRoot":""}