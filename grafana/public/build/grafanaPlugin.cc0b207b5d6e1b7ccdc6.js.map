{"version":3,"file":"grafanaPlugin.cc0b207b5d6e1b7ccdc6.js","mappings":"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","sources":["webpack://grafana/./public/app/plugins/datasource/grafana/components/SearchEditor.tsx","webpack://grafana/./public/app/plugins/datasource/grafana/components/QueryEditor.tsx","webpack://grafana/./public/app/plugins/datasource/grafana/module.ts"],"sourcesContent":["import React, { useEffect, useState } from 'react';\n\nimport { InlineField, Input, InlineFieldRow, CodeEditor } from '@grafana/ui';\nimport { SearchQuery } from 'app/features/search/service';\n\ninterface Props {\n  value: SearchQuery;\n  onChange: (value: SearchQuery) => void;\n}\n\nexport default function SearchEditor({ value, onChange }: Props) {\n  const [json, setJSON] = useState('');\n  const [query, setQuery] = useState(value.query ?? '');\n\n  useEffect(() => {\n    const emptySearchQuery: SearchQuery = {\n      query: '*',\n      location: '', // general, etc\n      ds_uid: '',\n      sort: '',\n      tags: [],\n      kind: [],\n      explain: false,\n      facet: [{ field: 'kind' }, { field: 'tags' }],\n      from: 0,\n      limit: 20,\n    };\n\n    setJSON(JSON.stringify({ ...emptySearchQuery, ...value }, null, 2));\n  }, [value]);\n\n  const handleSearchBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    if (query !== value.query) {\n      onChange({ ...value, query });\n    }\n  };\n\n  const handleSearchEnterKey = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key !== 'Enter') {\n      return;\n    }\n    handleSearchBlur(e as any);\n  };\n\n  const onSaveSearchJSON = (rawSearchJSON: string) => {\n    try {\n      const searchQuery = JSON.parse(rawSearchJSON) as SearchQuery;\n      onChange(searchQuery);\n      setQuery(searchQuery.query ?? '');\n    } catch (ex) {\n      console.log('UNABLE TO parse search', rawSearchJSON, ex);\n    }\n  };\n\n  return (\n    <>\n      <InlineFieldRow>\n        <InlineField label=\"Query\" grow={true} labelWidth={12}>\n          <Input\n            placeholder=\"Everything\"\n            value={query}\n            onChange={(e) => setQuery(e.currentTarget.value)}\n            onKeyDown={handleSearchEnterKey}\n            onBlur={handleSearchBlur}\n            spellCheck={false}\n          />\n        </InlineField>\n      </InlineFieldRow>\n      <CodeEditor\n        height={300}\n        language=\"json\"\n        value={json}\n        onBlur={onSaveSearchJSON}\n        onSave={onSaveSearchJSON}\n        showMiniMap={false}\n        showLineNumbers={true}\n      />\n    </>\n  );\n}\n","import pluralize from 'pluralize';\nimport React, { PureComponent } from 'react';\n\nimport {\n  QueryEditorProps,\n  SelectableValue,\n  dataFrameFromJSON,\n  rangeUtil,\n  DataQueryRequest,\n  DataFrame,\n} from '@grafana/data';\nimport { config, getBackendSrv, getDataSourceSrv } from '@grafana/runtime';\nimport { InlineField, Select, Alert, Input, InlineFieldRow, InlineLabel } from '@grafana/ui';\nimport { hasAlphaPanels } from 'app/core/config';\nimport { SearchQuery } from 'app/features/search/service';\n\nimport { GrafanaDatasource } from '../datasource';\nimport { defaultQuery, GrafanaQuery, GrafanaQueryType } from '../types';\n\nimport SearchEditor from './SearchEditor';\n\ntype Props = QueryEditorProps<GrafanaDatasource, GrafanaQuery>;\n\nconst labelWidth = 12;\n\ninterface State {\n  channels: Array<SelectableValue<string>>;\n  channelFields: Record<string, Array<SelectableValue<string>>>;\n  folders?: Array<SelectableValue<string>>;\n}\n\nexport class QueryEditor extends PureComponent<Props, State> {\n  state: State = { channels: [], channelFields: {} };\n\n  queryTypes: Array<SelectableValue<GrafanaQueryType>> = [\n    {\n      label: 'Random Walk',\n      value: GrafanaQueryType.RandomWalk,\n      description: 'Random signal within the selected time range',\n    },\n    {\n      label: 'Live Measurements',\n      value: GrafanaQueryType.LiveMeasurements,\n      description: 'Stream real-time measurements from Grafana',\n    },\n    {\n      label: 'List public files',\n      value: GrafanaQueryType.List,\n      description: 'Show directory listings for public resources',\n    },\n  ];\n\n  constructor(props: Props) {\n    super(props);\n\n    if (config.featureToggles.panelTitleSearch && hasAlphaPanels) {\n      this.queryTypes.push({\n        label: 'Search',\n        value: GrafanaQueryType.Search,\n        description: 'Search for grafana resources',\n      });\n    }\n  }\n\n  loadChannelInfo() {\n    getBackendSrv()\n      .fetch({ url: 'api/live/list' })\n      .subscribe({\n        next: (v: any) => {\n          const channelInfo = v.data?.channels as any[];\n          if (channelInfo?.length) {\n            const channelFields: Record<string, Array<SelectableValue<string>>> = {};\n            const channels: Array<SelectableValue<string>> = channelInfo.map((c) => {\n              if (c.data) {\n                const distinctFields = new Set<string>();\n                const frame = dataFrameFromJSON(c.data);\n                for (const f of frame.fields) {\n                  distinctFields.add(f.name);\n                }\n                channelFields[c.channel] = Array.from(distinctFields).map((n) => ({\n                  value: n,\n                  label: n,\n                }));\n              }\n              return {\n                value: c.channel,\n                label: c.channel + ' [' + c.minute_rate + ' msg/min]',\n              };\n            });\n\n            this.setState({ channelFields, channels });\n          }\n        },\n      });\n  }\n\n  loadFolderInfo() {\n    const query: DataQueryRequest<GrafanaQuery> = {\n      targets: [{ queryType: GrafanaQueryType.List, refId: 'A' }],\n    } as any;\n\n    getDataSourceSrv()\n      .get('-- Grafana --')\n      .then((ds) => {\n        const gds = ds as GrafanaDatasource;\n        gds.query(query).subscribe({\n          next: (rsp) => {\n            if (rsp.data.length) {\n              const names = (rsp.data[0] as DataFrame).fields[0];\n              const folders = names.values.toArray().map((v) => ({\n                value: v,\n                label: v,\n              }));\n              this.setState({ folders });\n            }\n          },\n        });\n      });\n  }\n\n  componentDidMount() {\n    this.loadChannelInfo();\n  }\n\n  onQueryTypeChange = (sel: SelectableValue<GrafanaQueryType>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, queryType: sel.value! });\n    onRunQuery();\n\n    // Reload the channel list\n    this.loadChannelInfo();\n  };\n\n  onChannelChange = (sel: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, channel: sel?.value });\n    onRunQuery();\n  };\n\n  onFieldNamesChange = (item: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    let fields: string[] = [];\n    if (Array.isArray(item)) {\n      fields = item.map((v) => v.value);\n    } else if (item.value) {\n      fields = [item.value];\n    }\n\n    // When adding the first field, also add time (if it exists)\n    if (fields.length === 1 && !query.filter?.fields?.length && query.channel) {\n      const names = this.state.channelFields[query.channel] ?? [];\n      const tf = names.find((f) => f.value === 'time' || f.value === 'Time');\n      if (tf && tf.value && tf.value !== fields[0]) {\n        fields = [tf.value, ...fields];\n      }\n    }\n\n    onChange({\n      ...query,\n      filter: {\n        ...query.filter,\n        fields,\n      },\n    });\n    onRunQuery();\n  };\n\n  checkAndUpdateValue = (key: keyof GrafanaQuery, txt: string) => {\n    const { onChange, query, onRunQuery } = this.props;\n    if (key === 'buffer') {\n      let buffer: number | undefined;\n      if (txt) {\n        try {\n          buffer = rangeUtil.intervalToSeconds(txt) * 1000;\n        } catch (err) {\n          console.warn('ERROR', err);\n        }\n      }\n      onChange({\n        ...query,\n        buffer,\n      });\n    } else {\n      onChange({\n        ...query,\n        [key]: txt,\n      });\n    }\n    onRunQuery();\n  };\n\n  handleEnterKey = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    if (e.key !== 'Enter') {\n      return;\n    }\n    this.checkAndUpdateValue('buffer', (e.target as any).value);\n  };\n\n  handleBlur = (e: React.FocusEvent<HTMLInputElement>) => {\n    this.checkAndUpdateValue('buffer', e.target.value);\n  };\n\n  renderMeasurementsQuery() {\n    let { channel, filter, buffer } = this.props.query;\n    let { channels, channelFields } = this.state;\n    let currentChannel = channels.find((c) => c.value === channel);\n    if (channel && !currentChannel) {\n      currentChannel = {\n        value: channel,\n        label: channel,\n        description: `Connected to ${channel}`,\n      };\n      channels = [currentChannel, ...channels];\n    }\n\n    const distinctFields = new Set<string>();\n    const fields: Array<SelectableValue<string>> = channel ? channelFields[channel] ?? [] : [];\n    // if (data && data.series?.length) {\n    //   for (const frame of data.series) {\n    //     for (const field of frame.fields) {\n    //       if (distinctFields.has(field.name) || !field.name) {\n    //         continue;\n    //       }\n    //       fields.push({\n    //         value: field.name,\n    //         label: field.name,\n    //         description: `(${getFrameDisplayName(frame)} / ${field.type})`,\n    //       });\n    //       distinctFields.add(field.name);\n    //     }\n    //   }\n    // }\n    if (filter?.fields) {\n      for (const f of filter.fields) {\n        if (!distinctFields.has(f)) {\n          fields.push({\n            value: f,\n            label: `${f} (not loaded)`,\n            description: `Configured, but not found in the query results`,\n          });\n          distinctFields.add(f);\n        }\n      }\n    }\n\n    let formattedTime = '';\n    if (buffer) {\n      formattedTime = rangeUtil.secondsToHms(buffer / 1000);\n    }\n\n    return (\n      <>\n        <div className=\"gf-form\">\n          <InlineField label=\"Channel\" grow={true} labelWidth={labelWidth}>\n            <Select\n              options={channels}\n              value={currentChannel || ''}\n              onChange={this.onChannelChange}\n              allowCustomValue={true}\n              backspaceRemovesValue={true}\n              placeholder=\"Select measurements channel\"\n              isClearable={true}\n              noOptionsMessage=\"Enter channel name\"\n              formatCreateLabel={(input: string) => `Connect to: ${input}`}\n            />\n          </InlineField>\n        </div>\n        {channel && (\n          <div className=\"gf-form\">\n            <InlineField label=\"Fields\" grow={true} labelWidth={labelWidth}>\n              <Select\n                options={fields}\n                value={filter?.fields || []}\n                onChange={this.onFieldNamesChange}\n                allowCustomValue={true}\n                backspaceRemovesValue={true}\n                placeholder=\"All fields\"\n                isClearable={true}\n                noOptionsMessage=\"Unable to list all fields\"\n                formatCreateLabel={(input: string) => `Field: ${input}`}\n                isSearchable={true}\n                isMulti={true}\n              />\n            </InlineField>\n            <InlineField label=\"Buffer\">\n              <Input\n                placeholder=\"Auto\"\n                width={12}\n                defaultValue={formattedTime}\n                onKeyDown={this.handleEnterKey}\n                onBlur={this.handleBlur}\n                spellCheck={false}\n              />\n            </InlineField>\n          </div>\n        )}\n\n        <Alert title=\"Grafana Live - Measurements\" severity=\"info\">\n          This supports real-time event streams in Grafana core. This feature is under heavy development. Expect the\n          interfaces and structures to change as this becomes more production ready.\n        </Alert>\n      </>\n    );\n  }\n\n  onFolderChanged = (sel: SelectableValue<string>) => {\n    const { onChange, query, onRunQuery } = this.props;\n    onChange({ ...query, path: sel?.value });\n    onRunQuery();\n  };\n\n  renderListPublicFiles() {\n    let { path } = this.props.query;\n    let { folders } = this.state;\n    if (!folders) {\n      folders = [];\n      this.loadFolderInfo();\n    }\n    const currentFolder = folders.find((f) => f.value === path);\n    if (path && !currentFolder) {\n      folders = [\n        ...folders,\n        {\n          value: path,\n          label: path,\n        },\n      ];\n    }\n\n    return (\n      <InlineFieldRow>\n        <InlineField label=\"Path\" grow={true} labelWidth={labelWidth}>\n          <Select\n            options={folders}\n            value={currentFolder || ''}\n            onChange={this.onFolderChanged}\n            allowCustomValue={true}\n            backspaceRemovesValue={true}\n            placeholder=\"Select folder\"\n            isClearable={true}\n            formatCreateLabel={(input: string) => `Folder: ${input}`}\n          />\n        </InlineField>\n      </InlineFieldRow>\n    );\n  }\n\n  renderSnapshotQuery() {\n    const { query } = this.props;\n\n    return (\n      <InlineFieldRow>\n        <InlineField label=\"Snapshot\" grow={true} labelWidth={labelWidth}>\n          <InlineLabel>{pluralize('frame', query.snapshot?.length ?? 0, true)}</InlineLabel>\n        </InlineField>\n      </InlineFieldRow>\n    );\n  }\n\n  onSearchChange = (search: SearchQuery) => {\n    const { query, onChange, onRunQuery } = this.props;\n\n    onChange({\n      ...query,\n      search,\n    });\n    onRunQuery();\n  };\n\n  render() {\n    const query = {\n      ...defaultQuery,\n      ...this.props.query,\n    };\n\n    const { queryType } = query;\n\n    // Only show \"snapshot\" when it already exists\n    let queryTypes = this.queryTypes;\n    if (queryType === GrafanaQueryType.Snapshot) {\n      queryTypes = [\n        ...this.queryTypes,\n        {\n          label: 'Snapshot',\n          value: queryType,\n        },\n      ];\n    }\n\n    return (\n      <>\n        {queryType === GrafanaQueryType.Search && (\n          <Alert title=\"Grafana Search\" severity=\"info\">\n            Using this datasource to call the new search system is experimental, and subject to change at any time\n            without notice.\n          </Alert>\n        )}\n        <InlineFieldRow>\n          <InlineField label=\"Query type\" grow={true} labelWidth={labelWidth}>\n            <Select\n              options={queryTypes}\n              value={queryTypes.find((v) => v.value === queryType) || queryTypes[0]}\n              onChange={this.onQueryTypeChange}\n            />\n          </InlineField>\n        </InlineFieldRow>\n        {queryType === GrafanaQueryType.LiveMeasurements && this.renderMeasurementsQuery()}\n        {queryType === GrafanaQueryType.List && this.renderListPublicFiles()}\n        {queryType === GrafanaQueryType.Snapshot && this.renderSnapshotQuery()}\n        {queryType === GrafanaQueryType.Search && (\n          <SearchEditor value={query.search ?? {}} onChange={this.onSearchChange} />\n        )}\n      </>\n    );\n  }\n}\n","import { DataSourcePlugin } from '@grafana/data';\n\nimport { QueryEditor } from './components/QueryEditor';\nimport { GrafanaDatasource } from './datasource';\nimport { GrafanaQuery } from './types';\n\nexport const plugin = new DataSourcePlugin<GrafanaDatasource, GrafanaQuery>(GrafanaDatasource).setQueryEditor(\n  QueryEditor\n);\n"],"names":["SearchEditor","value","onChange","json","setJSON","useState","query","setQuery","useEffect","JSON","stringify","location","ds_uid","sort","tags","kind","explain","facet","field","from","limit","handleSearchBlur","e","onSaveSearchJSON","rawSearchJSON","searchQuery","parse","ex","console","log","InlineFieldRow","InlineField","label","grow","labelWidth","Input","I","placeholder","currentTarget","onKeyDown","key","onBlur","spellCheck","CodeEditor","height","language","onSave","showMiniMap","showLineNumbers","QueryEditor","PureComponent","constructor","props","super","channels","channelFields","GrafanaQueryType","description","sel","onRunQuery","this","queryType","loadChannelInfo","channel","item","fields","Array","isArray","map","v","length","filter","tf","state","find","f","txt","buffer","rangeUtil","err","warn","checkAndUpdateValue","target","path","search","config","hasAlphaPanels","queryTypes","push","getBackendSrv","fetch","url","subscribe","next","channelInfo","data","c","distinctFields","Set","frame","dataFrameFromJSON","add","name","n","minute_rate","setState","loadFolderInfo","targets","refId","getDataSourceSrv","get","then","ds","rsp","folders","values","toArray","componentDidMount","renderMeasurementsQuery","currentChannel","has","formattedTime","className","Select","options","onChannelChange","allowCustomValue","backspaceRemovesValue","isClearable","noOptionsMessage","formatCreateLabel","input","onFieldNamesChange","isSearchable","isMulti","width","defaultValue","handleEnterKey","handleBlur","Alert","title","severity","renderListPublicFiles","currentFolder","onFolderChanged","renderSnapshotQuery","InlineLabel","pluralize","snapshot","render","defaultQuery","onQueryTypeChange","onSearchChange","plugin","DataSourcePlugin","GrafanaDatasource","setQueryEditor"],"sourceRoot":""}