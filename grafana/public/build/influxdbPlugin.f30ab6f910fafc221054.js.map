{"version":3,"file":"influxdbPlugin.f30ab6f910fafc221054.js","mappings":"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","sources":["webpack://grafana/./public/app/plugins/datasource/influxdb/constants.ts","webpack://grafana/./public/app/plugins/datasource/influxdb/types.ts","webpack://grafana/./public/app/plugins/datasource/influxdb/components/ConfigEditor.tsx","webpack://grafana/./public/app/plugins/datasource/influxdb/components/InfluxCheatSheet.tsx","webpack://grafana/./public/app/plugins/datasource/influxdb/components/InfluxStartPage.tsx","webpack://grafana/./public/app/plugins/datasource/influxdb/query_part.ts","webpack://grafana/./public/app/plugins/datasource/influxdb/influx_query_model.ts","webpack://grafana/./public/app/plugins/datasource/influxdb/queryUtils.ts","webpack://grafana/./public/app/plugins/datasource/influxdb/components/FluxQueryEditor.tsx","webpack://grafana/./public/app/plugins/datasource/influxdb/components/QueryEditorModeSwitcher.tsx","webpack://grafana/./public/app/plugins/datasource/influxdb/components/constants.ts","webpack://grafana/./public/app/plugins/datasource/influxdb/components/useShadowedState.ts","webpack://grafana/./public/app/plugins/datasource/influxdb/components/RawInfluxQLEditor.tsx","webpack://grafana/./public/app/plugins/datasource/influxdb/query_builder.ts","webpack://grafana/./public/app/plugins/datasource/influxdb/influxQLMetadataQuery.ts","webpack://grafana/./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/styles.ts","webpack://grafana/./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/unwrap.ts","webpack://grafana/./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/FormatAsSection.tsx","webpack://grafana/./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/Seg.tsx","webpack://grafana/./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/toSelectableValue.ts","webpack://grafana/./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/FromSection.tsx","webpack://grafana/./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/InputSection.tsx","webpack://grafana/./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/OrderByTimeSection.tsx","webpack://grafana/./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/AddButton.tsx","webpack://grafana/./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/PartListSection.tsx","webpack://grafana/./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/tagUtils.ts","webpack://grafana/./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/TagsSection.tsx","webpack://grafana/./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/partListUtils.tsx","webpack://grafana/./public/app/plugins/datasource/influxdb/components/VisualInfluxQLEditor/Editor.tsx","webpack://grafana/./public/app/plugins/datasource/influxdb/components/VariableQueryEditor.tsx","webpack://grafana/./public/app/plugins/datasource/influxdb/components/AnnotationEditor.tsx","webpack://grafana/./public/app/plugins/datasource/influxdb/influx_series.ts","webpack://grafana/./public/app/plugins/datasource/influxdb/migrations.ts","webpack://grafana/./public/app/plugins/datasource/influxdb/response_parser.ts","webpack://grafana/./public/app/plugins/datasource/influxdb/datasource.ts","webpack://grafana/./public/app/plugins/datasource/influxdb/module.ts","webpack://grafana/./public/app/plugins/datasource/influxdb/components/QueryEditor.tsx"],"sourcesContent":["export const BROWSER_MODE_DISABLED_MESSAGE =\n  'Direct browser access in the InfluxDB datasource is no longer available. Switch to server access mode.';\n","import { DataQuery, DataSourceJsonData, AdHocVariableFilter } from '@grafana/data';\n\nexport enum InfluxVersion {\n  InfluxQL = 'InfluxQL',\n  Flux = 'Flux',\n}\n\nexport interface InfluxOptions extends DataSourceJsonData {\n  version?: InfluxVersion;\n\n  timeInterval?: string;\n  httpMode?: string;\n\n  // With Flux\n  organization?: string;\n  defaultBucket?: string;\n  maxSeries?: number;\n}\n\nexport interface InfluxSecureJsonData {\n  // For Flux\n  token?: string;\n\n  // In 1x a different password can be sent than then HTTP auth\n  password?: string;\n}\n\nexport interface InfluxQueryPart {\n  type: string;\n  params?: Array<string | number>;\n  // FIXME: `interval` does not seem to be used.\n  // check all the influxdb parts (query-generation etc.),\n  // if it is really so, and if yes, remove it\n  interval?: string;\n}\n\nexport interface InfluxQueryTag {\n  key: string;\n  operator?: string;\n  condition?: string;\n  value: string;\n}\n\nexport type ResultFormat = 'time_series' | 'table' | 'logs';\n\nexport interface InfluxQuery extends DataQuery {\n  policy?: string;\n  measurement?: string;\n  resultFormat?: ResultFormat;\n  orderByTime?: string;\n  tags?: InfluxQueryTag[];\n  groupBy?: InfluxQueryPart[];\n  select?: InfluxQueryPart[][];\n  limit?: string | number;\n  slimit?: string | number;\n  tz?: string;\n  // NOTE: `fill` is not used in the query-editor anymore, and is removed\n  // if any change happens in the query-editor. the query-generation still\n  // supports it for now.\n  fill?: string;\n  rawQuery?: boolean;\n  query?: string;\n  alias?: string;\n  // for migrated InfluxQL annotations\n  queryType?: string;\n  fromAnnotations?: boolean;\n  tagsColumn?: string;\n  textColumn?: string;\n  timeEndColumn?: string;\n  titleColumn?: string;\n  name?: string;\n  matchAny?: boolean;\n  type?: string;\n\n  textEditor?: boolean;\n  adhocFilters?: AdHocVariableFilter[];\n}\n","import { uniqueId } from 'lodash';\nimport React, { PureComponent } from 'react';\n\nimport {\n  DataSourcePluginOptionsEditorProps,\n  SelectableValue,\n  onUpdateDatasourceOption,\n  updateDatasourcePluginResetOption,\n  onUpdateDatasourceJsonDataOption,\n  onUpdateDatasourceJsonDataOptionSelect,\n  onUpdateDatasourceSecureJsonDataOption,\n  updateDatasourcePluginJsonDataOption,\n} from '@grafana/data';\nimport { Alert, DataSourceHttpSettings, InfoBox, InlineField, InlineFormLabel, LegacyForms, Select } from '@grafana/ui';\n\nconst { Input, SecretFormField } = LegacyForms;\nimport { BROWSER_MODE_DISABLED_MESSAGE } from '../constants';\nimport { InfluxOptions, InfluxSecureJsonData, InfluxVersion } from '../types';\n\nconst httpModes: SelectableValue[] = [\n  { label: 'GET', value: 'GET' },\n  { label: 'POST', value: 'POST' },\n];\n\nconst versions: Array<SelectableValue<InfluxVersion>> = [\n  {\n    label: 'InfluxQL',\n    value: InfluxVersion.InfluxQL,\n    description: 'The InfluxDB SQL-like query language.',\n  },\n  {\n    label: 'Flux',\n    value: InfluxVersion.Flux,\n    description: 'Advanced data scripting and query language.  Supported in InfluxDB 2.x and 1.8+',\n  },\n];\n\nexport type Props = DataSourcePluginOptionsEditorProps<InfluxOptions>;\ntype State = {\n  maxSeries: string | undefined;\n};\n\nexport class ConfigEditor extends PureComponent<Props, State> {\n  state = {\n    maxSeries: '',\n  };\n\n  htmlPrefix: string;\n\n  constructor(props: Props) {\n    super(props);\n    this.state.maxSeries = props.options.jsonData.maxSeries?.toString() || '';\n    this.htmlPrefix = uniqueId('influxdb-config');\n  }\n\n  // 1x\n  onResetPassword = () => {\n    updateDatasourcePluginResetOption(this.props, 'password');\n  };\n\n  // 2x\n  onResetToken = () => {\n    updateDatasourcePluginResetOption(this.props, 'token');\n  };\n\n  onVersionChanged = (selected: SelectableValue<InfluxVersion>) => {\n    const { options, onOptionsChange } = this.props;\n\n    const copy: any = {\n      ...options,\n      jsonData: {\n        ...options.jsonData,\n        version: selected.value,\n      },\n    };\n    if (selected.value === InfluxVersion.Flux) {\n      copy.access = 'proxy';\n      copy.basicAuth = true;\n      copy.jsonData.httpMode = 'POST';\n\n      // Remove old 1x configs\n      delete copy.user;\n      delete copy.database;\n    }\n\n    onOptionsChange(copy);\n  };\n\n  renderInflux2x() {\n    const { options } = this.props;\n    const { secureJsonFields } = options;\n    const secureJsonData = (options.secureJsonData || {}) as InfluxSecureJsonData;\n    const { htmlPrefix } = this;\n\n    return (\n      <>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel htmlFor={`${htmlPrefix}-org`} className=\"width-10\">\n              Organization\n            </InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                id={`${htmlPrefix}-org`}\n                className=\"width-20\"\n                value={options.jsonData.organization || ''}\n                onChange={onUpdateDatasourceJsonDataOption(this.props, 'organization')}\n              />\n            </div>\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <SecretFormField\n              isConfigured={Boolean(secureJsonFields && secureJsonFields.token)}\n              value={secureJsonData.token || ''}\n              label=\"Token\"\n              aria-label=\"Token\"\n              labelWidth={10}\n              inputWidth={20}\n              onReset={this.onResetToken}\n              onChange={onUpdateDatasourceSecureJsonDataOption(this.props, 'token')}\n            />\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel className=\"width-10\">Default Bucket</InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-20\"\n                placeholder=\"default bucket\"\n                value={options.jsonData.defaultBucket || ''}\n                onChange={onUpdateDatasourceJsonDataOption(this.props, 'defaultBucket')}\n              />\n            </div>\n          </div>\n        </div>\n\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              className=\"width-10\"\n              tooltip=\"A lower limit for the auto group by time interval. Recommended to be set to write frequency,\n\t\t\t\tfor example 1m if your data is written every minute.\"\n            >\n              Min time interval\n            </InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-10\"\n                placeholder=\"10s\"\n                value={options.jsonData.timeInterval || ''}\n                onChange={onUpdateDatasourceJsonDataOption(this.props, 'timeInterval')}\n              />\n            </div>\n          </div>\n        </div>\n      </>\n    );\n  }\n\n  renderInflux1x() {\n    const { options } = this.props;\n    const { secureJsonFields } = options;\n    const secureJsonData = (options.secureJsonData || {}) as InfluxSecureJsonData;\n    const { htmlPrefix } = this;\n\n    return (\n      <>\n        <InfoBox>\n          <h5>Database Access</h5>\n          <p>\n            Setting the database for this datasource does not deny access to other databases. The InfluxDB query syntax\n            allows switching the database in the query. For example:\n            <code>SHOW MEASUREMENTS ON _internal</code> or\n            <code>SELECT * FROM &quot;_internal&quot;..&quot;database&quot; LIMIT 10</code>\n            <br />\n            <br />\n            To support data isolation and security, make sure appropriate permissions are configured in InfluxDB.\n          </p>\n        </InfoBox>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel htmlFor={`${htmlPrefix}-db`} className=\"width-10\">\n              Database\n            </InlineFormLabel>\n            <div className=\"width-20\">\n              <Input\n                id={`${htmlPrefix}-db`}\n                className=\"width-20\"\n                value={options.database || ''}\n                onChange={onUpdateDatasourceOption(this.props, 'database')}\n              />\n            </div>\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel htmlFor={`${htmlPrefix}-user`} className=\"width-10\">\n              User\n            </InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                id={`${htmlPrefix}-user`}\n                className=\"width-20\"\n                value={options.user || ''}\n                onChange={onUpdateDatasourceOption(this.props, 'user')}\n              />\n            </div>\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <SecretFormField\n              isConfigured={Boolean(secureJsonFields && secureJsonFields.password)}\n              value={secureJsonData.password || ''}\n              label=\"Password\"\n              aria-label=\"Password\"\n              labelWidth={10}\n              inputWidth={20}\n              onReset={this.onResetPassword}\n              onChange={onUpdateDatasourceSecureJsonDataOption(this.props, 'password')}\n            />\n          </div>\n        </div>\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              htmlFor={`${htmlPrefix}-http-method`}\n              className=\"width-10\"\n              tooltip=\"You can use either GET or POST HTTP method to query your InfluxDB database. The POST\n          method allows you to perform heavy requests (with a lots of WHERE clause) while the GET method\n          will restrict you and return an error if the query is too large.\"\n            >\n              HTTP Method\n            </InlineFormLabel>\n            <Select\n              inputId={`${htmlPrefix}-http-method`}\n              className=\"width-10\"\n              value={httpModes.find((httpMode) => httpMode.value === options.jsonData.httpMode)}\n              options={httpModes}\n              defaultValue={options.jsonData.httpMode}\n              onChange={onUpdateDatasourceJsonDataOptionSelect(this.props, 'httpMode')}\n            />\n          </div>\n        </div>\n\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel\n              className=\"width-10\"\n              tooltip=\"A lower limit for the auto group by time interval. Recommended to be set to write frequency,\n\t\t\t\tfor example 1m if your data is written every minute.\"\n            >\n              Min time interval\n            </InlineFormLabel>\n            <div className=\"width-10\">\n              <Input\n                className=\"width-10\"\n                placeholder=\"10s\"\n                value={options.jsonData.timeInterval || ''}\n                onChange={onUpdateDatasourceJsonDataOption(this.props, 'timeInterval')}\n              />\n            </div>\n          </div>\n        </div>\n      </>\n    );\n  }\n\n  render() {\n    const { options, onOptionsChange } = this.props;\n    const isDirectAccess = options.access === 'direct';\n\n    return (\n      <>\n        <h3 className=\"page-heading\">Query Language</h3>\n        <div className=\"gf-form-group\">\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form\">\n              <Select\n                aria-label=\"Query language\"\n                className=\"width-30\"\n                value={options.jsonData.version === InfluxVersion.Flux ? versions[1] : versions[0]}\n                options={versions}\n                defaultValue={versions[0]}\n                onChange={this.onVersionChanged}\n              />\n            </div>\n          </div>\n        </div>\n\n        {options.jsonData.version === InfluxVersion.Flux && (\n          <InfoBox>\n            <h5>Support for Flux in Grafana is currently in beta</h5>\n            <p>\n              Please report any issues to: <br />\n              <a href=\"https://github.com/grafana/grafana/issues/new/choose\">\n                https://github.com/grafana/grafana/issues\n              </a>\n            </p>\n          </InfoBox>\n        )}\n\n        {isDirectAccess && (\n          <Alert title=\"Error\" severity=\"error\">\n            {BROWSER_MODE_DISABLED_MESSAGE}\n          </Alert>\n        )}\n\n        <DataSourceHttpSettings\n          showAccessOptions={isDirectAccess}\n          dataSourceConfig={options}\n          defaultUrl=\"http://localhost:8086\"\n          onChange={onOptionsChange}\n        />\n\n        <div className=\"gf-form-group\">\n          <div>\n            <h3 className=\"page-heading\">InfluxDB Details</h3>\n          </div>\n          {options.jsonData.version === InfluxVersion.Flux ? this.renderInflux2x() : this.renderInflux1x()}\n          <div className=\"gf-form-inline\">\n            <InlineField\n              labelWidth={20}\n              label=\"Max series\"\n              tooltip=\"Limit the number of series/tables that Grafana will process. Lower this number to prevent abuse, and increase it if you have lots of small time series and not all are shown. Defaults to 1000.\"\n            >\n              <Input\n                placeholder=\"1000\"\n                type=\"number\"\n                className=\"width-10\"\n                value={this.state.maxSeries}\n                onChange={(event) => {\n                  // We duplicate this state so that we allow to write freely inside the input. We don't have\n                  // any influence over saving so this seems to be only way to do this.\n                  this.setState({ maxSeries: event.currentTarget.value });\n                  const val = parseInt(event.currentTarget.value, 10);\n                  updateDatasourcePluginJsonDataOption(this.props, 'maxSeries', Number.isFinite(val) ? val : undefined);\n                }}\n              />\n            </InlineField>\n          </div>\n        </div>\n      </>\n    );\n  }\n}\n\nexport default ConfigEditor;\n","import React from 'react';\n\nconst CHEAT_SHEET_ITEMS = [\n  {\n    title: 'Getting started',\n    label:\n      'Start by selecting a measurement and field from the dropdown above. You can then use the tag selector to further narrow your search.',\n  },\n];\n\nconst InfluxCheatSheet = (props: any) => (\n  <div>\n    <h2>InfluxDB Cheat Sheet</h2>\n    {CHEAT_SHEET_ITEMS.map((item) => (\n      <div className=\"cheat-sheet-item\" key={item.title}>\n        <div className=\"cheat-sheet-item__title\">{item.title}</div>\n        <div className=\"cheat-sheet-item__label\">{item.label}</div>\n      </div>\n    ))}\n  </div>\n);\n\nexport default InfluxCheatSheet;\n","import React, { PureComponent } from 'react';\n\nimport { QueryEditorHelpProps } from '@grafana/data';\n\nimport InfluxCheatSheet from './InfluxCheatSheet';\n\nexport default class InfluxStartPage extends PureComponent<QueryEditorHelpProps> {\n  render() {\n    return <InfluxCheatSheet onClickExample={this.props.onClickExample} />;\n  }\n}\n","import { map, clone } from 'lodash';\n\nimport { QueryPartDef, QueryPart, functionRenderer, suffixRenderer } from 'app/features/alerting/state/query_part';\n\nconst index: any[] = [];\nconst categories: any = {\n  Aggregations: [],\n  Selectors: [],\n  Transformations: [],\n  Predictors: [],\n  Math: [],\n  Aliasing: [],\n  Fields: [],\n};\n\nfunction createPart(part: any): any {\n  const def = index[part.type];\n  if (!def) {\n    throw { message: 'Could not find query part ' + part.type };\n  }\n\n  return new QueryPart(part, def);\n}\n\nfunction register(options: any) {\n  index[options.type] = new QueryPartDef(options);\n  options.category.push(index[options.type]);\n}\n\nconst groupByTimeFunctions: any[] = [];\n\nfunction aliasRenderer(part: { params: string[] }, innerExpr: string) {\n  return innerExpr + ' AS ' + '\"' + part.params[0] + '\"';\n}\n\nfunction fieldRenderer(part: { params: string[] }, innerExpr: any) {\n  if (part.params[0] === '*') {\n    return '*';\n  }\n  return '\"' + part.params[0] + '\"';\n}\n\nfunction replaceAggregationAddStrategy(selectParts: any[], partModel: { def: { type: string } }) {\n  // look for existing aggregation\n  for (let i = 0; i < selectParts.length; i++) {\n    const part = selectParts[i];\n    if (part.def.category === categories.Aggregations) {\n      if (part.def.type === partModel.def.type) {\n        return;\n      }\n      // count distinct is allowed\n      if (part.def.type === 'count' && partModel.def.type === 'distinct') {\n        break;\n      }\n      // remove next aggregation if distinct was replaced\n      if (part.def.type === 'distinct') {\n        const morePartsAvailable = selectParts.length >= i + 2;\n        if (partModel.def.type !== 'count' && morePartsAvailable) {\n          const nextPart = selectParts[i + 1];\n          if (nextPart.def.category === categories.Aggregations) {\n            selectParts.splice(i + 1, 1);\n          }\n        } else if (partModel.def.type === 'count') {\n          if (!morePartsAvailable || selectParts[i + 1].def.type !== 'count') {\n            selectParts.splice(i + 1, 0, partModel);\n          }\n          return;\n        }\n      }\n      selectParts[i] = partModel;\n      return;\n    }\n    if (part.def.category === categories.Selectors) {\n      selectParts[i] = partModel;\n      return;\n    }\n  }\n\n  selectParts.splice(1, 0, partModel);\n}\n\nfunction addTransformationStrategy(selectParts: any[], partModel: any) {\n  let i;\n  // look for index to add transformation\n  for (i = 0; i < selectParts.length; i++) {\n    const part = selectParts[i];\n    if (part.def.category === categories.Math || part.def.category === categories.Aliasing) {\n      break;\n    }\n  }\n\n  selectParts.splice(i, 0, partModel);\n}\n\nfunction addMathStrategy(selectParts: any[], partModel: any) {\n  const partCount = selectParts.length;\n  if (partCount > 0) {\n    // if last is math, replace it\n    if (selectParts[partCount - 1].def.type === 'math') {\n      selectParts[partCount - 1] = partModel;\n      return;\n    }\n    // if next to last is math, replace it\n    if (partCount > 1 && selectParts[partCount - 2].def.type === 'math') {\n      selectParts[partCount - 2] = partModel;\n      return;\n    } else if (selectParts[partCount - 1].def.type === 'alias') {\n      // if last is alias add it before\n      selectParts.splice(partCount - 1, 0, partModel);\n      return;\n    }\n  }\n  selectParts.push(partModel);\n}\n\nfunction addAliasStrategy(selectParts: any[], partModel: any) {\n  const partCount = selectParts.length;\n  if (partCount > 0) {\n    // if last is alias, replace it\n    if (selectParts[partCount - 1].def.type === 'alias') {\n      selectParts[partCount - 1] = partModel;\n      return;\n    }\n  }\n  selectParts.push(partModel);\n}\n\nfunction addFieldStrategy(selectParts: any, partModel: any, query: { selectModels: any[][] }) {\n  // copy all parts\n  const parts = map(selectParts, (part: any) => {\n    return createPart({ type: part.def.type, params: clone(part.params) });\n  });\n\n  query.selectModels.push(parts);\n}\n\nregister({\n  type: 'field',\n  addStrategy: addFieldStrategy,\n  category: categories.Fields,\n  params: [{ type: 'field', dynamicLookup: true }],\n  defaultParams: ['value'],\n  renderer: fieldRenderer,\n});\n\n// Aggregations\nregister({\n  type: 'count',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'distinct',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'integral',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'mean',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'median',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'mode',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'sum',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Aggregations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\n// transformations\n\nregister({\n  type: 'derivative',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'spread',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'non_negative_derivative',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'difference',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'non_negative_difference',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'moving_average',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [{ name: 'window', type: 'int', options: [5, 10, 20, 30, 40] }],\n  defaultParams: [10],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'cumulative_sum',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'stddev',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'time',\n  category: groupByTimeFunctions,\n  params: [\n    {\n      name: 'interval',\n      type: 'time',\n      options: ['$__interval', '1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['$__interval'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'fill',\n  category: groupByTimeFunctions,\n  params: [\n    {\n      name: 'fill',\n      type: 'string',\n      options: ['none', 'null', '0', 'previous', 'linear'],\n    },\n  ],\n  defaultParams: ['null'],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'elapsed',\n  addStrategy: addTransformationStrategy,\n  category: categories.Transformations,\n  params: [\n    {\n      name: 'duration',\n      type: 'interval',\n      options: ['1s', '10s', '1m', '5m', '10m', '15m', '1h'],\n    },\n  ],\n  defaultParams: ['10s'],\n  renderer: functionRenderer,\n});\n\n// predictions\nregister({\n  type: 'holt_winters',\n  addStrategy: addTransformationStrategy,\n  category: categories.Predictors,\n  params: [\n    { name: 'number', type: 'int', options: [5, 10, 20, 30, 40] },\n    { name: 'season', type: 'int', options: [0, 1, 2, 5, 10] },\n  ],\n  defaultParams: [10, 2],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'holt_winters_with_fit',\n  addStrategy: addTransformationStrategy,\n  category: categories.Predictors,\n  params: [\n    { name: 'number', type: 'int', options: [5, 10, 20, 30, 40] },\n    { name: 'season', type: 'int', options: [0, 1, 2, 5, 10] },\n  ],\n  defaultParams: [10, 2],\n  renderer: functionRenderer,\n});\n\n// Selectors\nregister({\n  type: 'bottom',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [3],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'first',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'last',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'max',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'min',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [],\n  defaultParams: [],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'percentile',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'nth', type: 'int' }],\n  defaultParams: [95],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'top',\n  addStrategy: replaceAggregationAddStrategy,\n  category: categories.Selectors,\n  params: [{ name: 'count', type: 'int' }],\n  defaultParams: [3],\n  renderer: functionRenderer,\n});\n\nregister({\n  type: 'tag',\n  category: groupByTimeFunctions,\n  params: [{ name: 'tag', type: 'string', dynamicLookup: true }],\n  defaultParams: ['tag'],\n  renderer: fieldRenderer,\n});\n\nregister({\n  type: 'math',\n  addStrategy: addMathStrategy,\n  category: categories.Math,\n  params: [{ name: 'expr', type: 'string' }],\n  defaultParams: [' / 100'],\n  renderer: suffixRenderer,\n});\n\nregister({\n  type: 'alias',\n  addStrategy: addAliasStrategy,\n  category: categories.Aliasing,\n  params: [{ name: 'name', type: 'string', quote: 'double' }],\n  defaultParams: ['alias'],\n  renderMode: 'suffix',\n  renderer: aliasRenderer,\n});\n\nexport default {\n  create: createPart,\n  getCategories: () => {\n    return categories;\n  },\n  replaceAggregationAdd: replaceAggregationAddStrategy,\n};\n","import { map, find, filter, indexOf } from 'lodash';\n\nimport { ScopedVars } from '@grafana/data';\nimport { TemplateSrv } from '@grafana/runtime';\nimport kbn from 'app/core/utils/kbn';\n\nimport queryPart from './query_part';\nimport { InfluxQuery, InfluxQueryTag } from './types';\n\nexport default class InfluxQueryModel {\n  target: InfluxQuery;\n  selectModels: any[] = [];\n  queryBuilder: any;\n  groupByParts: any;\n  templateSrv: any;\n  scopedVars: any;\n  refId?: string;\n\n  /** @ngInject */\n  constructor(target: InfluxQuery, templateSrv?: TemplateSrv, scopedVars?: ScopedVars) {\n    this.target = target;\n    this.templateSrv = templateSrv;\n    this.scopedVars = scopedVars;\n\n    target.policy = target.policy || 'default';\n    target.resultFormat = target.resultFormat || 'time_series';\n    target.orderByTime = target.orderByTime || 'ASC';\n    target.tags = target.tags || [];\n    target.groupBy = target.groupBy || [\n      { type: 'time', params: ['$__interval'] },\n      { type: 'fill', params: ['null'] },\n    ];\n    target.select = target.select || [\n      [\n        { type: 'field', params: ['value'] },\n        { type: 'mean', params: [] },\n      ],\n    ];\n\n    this.updateProjection();\n  }\n\n  updateProjection() {\n    this.selectModels = map(this.target.select, (parts: any) => {\n      return map(parts, queryPart.create);\n    });\n    this.groupByParts = map(this.target.groupBy, queryPart.create);\n  }\n\n  updatePersistedParts() {\n    this.target.select = map(this.selectModels, (selectParts) => {\n      return map(selectParts, (part: any) => {\n        return { type: part.def.type, params: part.params };\n      });\n    });\n  }\n\n  hasGroupByTime() {\n    return find(this.target.groupBy, (g: any) => g.type === 'time');\n  }\n\n  hasFill() {\n    return find(this.target.groupBy, (g: any) => g.type === 'fill');\n  }\n\n  addGroupBy(value: string) {\n    let stringParts = value.match(/^(\\w+)\\((.*)\\)$/);\n\n    if (!stringParts || !this.target.groupBy) {\n      return;\n    }\n\n    const typePart = stringParts[1];\n    const arg = stringParts[2];\n    const partModel = queryPart.create({ type: typePart, params: [arg] });\n    const partCount = this.target.groupBy.length;\n\n    if (partCount === 0) {\n      this.target.groupBy.push(partModel.part);\n    } else if (typePart === 'time') {\n      this.target.groupBy.splice(0, 0, partModel.part);\n    } else if (typePart === 'tag') {\n      if (this.target.groupBy[partCount - 1].type === 'fill') {\n        this.target.groupBy.splice(partCount - 1, 0, partModel.part);\n      } else {\n        this.target.groupBy.push(partModel.part);\n      }\n    } else {\n      this.target.groupBy.push(partModel.part);\n    }\n\n    this.updateProjection();\n  }\n\n  removeGroupByPart(part: { def: { type: string } }, index: number) {\n    const categories = queryPart.getCategories();\n\n    if (part.def.type === 'time') {\n      // remove fill\n      this.target.groupBy = filter(this.target.groupBy, (g: any) => g.type !== 'fill');\n      // remove aggregations\n      this.target.select = map(this.target.select, (s: any) => {\n        return filter(s, (part: any) => {\n          const partModel = queryPart.create(part);\n          if (partModel.def.category === categories.Aggregations) {\n            return false;\n          }\n          if (partModel.def.category === categories.Selectors) {\n            return false;\n          }\n          return true;\n        });\n      });\n    }\n\n    this.target.groupBy!.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelect(index: number) {\n    this.target.select!.splice(index, 1);\n    this.updateProjection();\n  }\n\n  removeSelectPart(selectParts: any[], part: any) {\n    // if we remove the field remove the whole statement\n    if (part.def.type === 'field') {\n      if (this.selectModels.length > 1) {\n        const modelsIndex = indexOf(this.selectModels, selectParts);\n        this.selectModels.splice(modelsIndex, 1);\n      }\n    } else {\n      const partIndex = indexOf(selectParts, part);\n      selectParts.splice(partIndex, 1);\n    }\n\n    this.updatePersistedParts();\n  }\n\n  addSelectPart(selectParts: any[], type: string) {\n    const partModel = queryPart.create({ type: type });\n    partModel.def.addStrategy(selectParts, partModel, this);\n    this.updatePersistedParts();\n  }\n\n  private renderTagCondition(tag: InfluxQueryTag, index: number, interpolate?: boolean) {\n    // FIXME: merge this function with query_builder/renderTagCondition\n    let str = '';\n    let operator = tag.operator;\n    let value = tag.value;\n    if (index > 0) {\n      str = (tag.condition || 'AND') + ' ';\n    }\n\n    if (!operator) {\n      if (/^\\/.*\\/$/.test(value)) {\n        operator = '=~';\n      } else {\n        operator = '=';\n      }\n    }\n\n    // quote value unless regex\n    if (operator !== '=~' && operator !== '!~') {\n      if (interpolate) {\n        value = this.templateSrv.replace(value, this.scopedVars);\n      }\n      if (operator !== '>' && operator !== '<') {\n        value = \"'\" + value.replace(/\\\\/g, '\\\\\\\\').replace(/\\'/g, \"\\\\'\") + \"'\";\n      }\n    } else if (interpolate) {\n      value = this.templateSrv.replace(value, this.scopedVars, 'regex');\n    }\n\n    return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n  }\n\n  getMeasurementAndPolicy(interpolate: any) {\n    let policy = this.target.policy;\n    let measurement = this.target.measurement || 'measurement';\n\n    if (!measurement.match('^/.*/$')) {\n      measurement = '\"' + measurement + '\"';\n    } else if (interpolate) {\n      measurement = this.templateSrv.replace(measurement, this.scopedVars, 'regex');\n    }\n\n    if (policy !== 'default') {\n      policy = '\"' + this.target.policy + '\".';\n    } else {\n      policy = '';\n    }\n\n    return policy + measurement;\n  }\n\n  interpolateQueryStr(value: any[], variable: { multi: any; includeAll: any }, defaultFormatFn: any) {\n    // if no multi or include all do not regexEscape\n    if (!variable.multi && !variable.includeAll) {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return kbn.regexEscape(value);\n    }\n\n    const escapedValues = map(value, kbn.regexEscape);\n    return '(' + escapedValues.join('|') + ')';\n  }\n\n  render(interpolate?: boolean) {\n    const target = this.target;\n\n    if (target.rawQuery) {\n      if (interpolate) {\n        return this.templateSrv.replace(target.query, this.scopedVars, this.interpolateQueryStr);\n      } else {\n        return target.query;\n      }\n    }\n\n    let query = 'SELECT ';\n    let i, y;\n    for (i = 0; i < this.selectModels.length; i++) {\n      const parts = this.selectModels[i];\n      let selectText = '';\n      for (y = 0; y < parts.length; y++) {\n        const part = parts[y];\n        selectText = part.render(selectText);\n      }\n\n      if (i > 0) {\n        query += ', ';\n      }\n      query += selectText;\n    }\n\n    query += ' FROM ' + this.getMeasurementAndPolicy(interpolate) + ' WHERE ';\n    const conditions = map(target.tags, (tag, index) => {\n      return this.renderTagCondition(tag, index, interpolate);\n    });\n\n    if (conditions.length > 0) {\n      query += '(' + conditions.join(' ') + ') AND ';\n    }\n\n    query += '$timeFilter';\n\n    let groupBySection = '';\n    for (i = 0; i < this.groupByParts.length; i++) {\n      const part = this.groupByParts[i];\n      if (i > 0) {\n        // for some reason fill has no separator\n        groupBySection += part.def.type === 'fill' ? ' ' : ', ';\n      }\n      groupBySection += part.render('');\n    }\n\n    if (groupBySection.length) {\n      query += ' GROUP BY ' + groupBySection;\n    }\n\n    if (target.fill) {\n      query += ' fill(' + target.fill + ')';\n    }\n\n    if (target.orderByTime === 'DESC') {\n      query += ' ORDER BY time DESC';\n    }\n\n    if (target.limit) {\n      query += ' LIMIT ' + target.limit;\n    }\n\n    if (target.slimit) {\n      query += ' SLIMIT ' + target.slimit;\n    }\n\n    if (target.tz) {\n      query += \" tz('\" + target.tz + \"')\";\n    }\n\n    return query;\n  }\n\n  renderAdhocFilters(filters: any[]) {\n    const conditions = map(filters, (tag, index) => {\n      return this.renderTagCondition(tag, index, true);\n    });\n    return conditions.join(' ');\n  }\n}\n","import { cloneDeep } from 'lodash';\n\nimport InfluxQueryModel from './influx_query_model';\nimport { InfluxQuery } from './types';\n\n// FIXME: these functions are a beginning of a refactoring of influx_query_model.ts\n// into a simpler approach with full typescript types.\n// later we should be able to migrate the unit-tests\n// that relate to these functions here, and then perhaps even move the implementation\n// to this place\n\nexport function buildRawQuery(query: InfluxQuery): string {\n  const queryCopy = cloneDeep(query); // the query-model mutates the query\n  const model = new InfluxQueryModel(queryCopy);\n  return model.render(false);\n}\n\nexport function normalizeQuery(query: InfluxQuery): InfluxQuery {\n  // we return the original query if there is no need to update it\n  if (\n    query.policy !== undefined &&\n    query.resultFormat !== undefined &&\n    query.orderByTime !== undefined &&\n    query.tags !== undefined &&\n    query.groupBy !== undefined &&\n    query.select !== undefined\n  ) {\n    return query;\n  }\n\n  // FIXME: we should move the whole normalizeQuery logic here,\n  // and then have influxQueryModel call this function,\n  // to concentrate the whole logic here\n\n  const queryCopy = cloneDeep(query); // the query-model mutates the query\n  return new InfluxQueryModel(queryCopy).target;\n}\n\nexport function addNewSelectPart(query: InfluxQuery, type: string, index: number): InfluxQuery {\n  const queryCopy = cloneDeep(query); // the query-model mutates the query\n  const model = new InfluxQueryModel(queryCopy);\n  model.addSelectPart(model.selectModels[index], type);\n  return model.target;\n}\n\nexport function removeSelectPart(query: InfluxQuery, partIndex: number, index: number): InfluxQuery {\n  const queryCopy = cloneDeep(query); // the query-model mutates the query\n  const model = new InfluxQueryModel(queryCopy);\n  const selectModel = model.selectModels[index];\n  model.removeSelectPart(selectModel, selectModel[partIndex]);\n  return model.target;\n}\n\nexport function changeSelectPart(\n  query: InfluxQuery,\n  listIndex: number,\n  partIndex: number,\n  newParams: string[]\n): InfluxQuery {\n  // we need to make shallow copy of `query.select` down to `query.select[listIndex][partIndex]`\n  const newSel = [...(query.select ?? [])];\n  newSel[listIndex] = [...newSel[listIndex]];\n  newSel[listIndex][partIndex] = {\n    ...newSel[listIndex][partIndex],\n    params: newParams,\n  };\n  return { ...query, select: newSel };\n}\n\nexport function addNewGroupByPart(query: InfluxQuery, type: string): InfluxQuery {\n  const queryCopy = cloneDeep(query); // the query-model mutates the query\n  const model = new InfluxQueryModel(queryCopy);\n  model.addGroupBy(type);\n  return model.target;\n}\n\nexport function removeGroupByPart(query: InfluxQuery, partIndex: number): InfluxQuery {\n  const queryCopy = cloneDeep(query); // the query-model mutates the query\n  const model = new InfluxQueryModel(queryCopy);\n  model.removeGroupByPart(model.groupByParts[partIndex], partIndex);\n  return model.target;\n}\n\nexport function changeGroupByPart(query: InfluxQuery, partIndex: number, newParams: string[]): InfluxQuery {\n  // we need to make shallow copy of `query.groupBy` down to `query.groupBy[partIndex]`\n  const newGroupBy = [...(query.groupBy ?? [])];\n  newGroupBy[partIndex] = {\n    ...newGroupBy[partIndex],\n    params: newParams,\n  };\n  return { ...query, groupBy: newGroupBy };\n}\n","import { cx, css } from '@emotion/css';\nimport React, { PureComponent } from 'react';\n\nimport { SelectableValue, GrafanaTheme2 } from '@grafana/data';\nimport { getTemplateSrv } from '@grafana/runtime';\nimport {\n  InlineFormLabel,\n  LinkButton,\n  Segment,\n  CodeEditor,\n  MonacoEditor,\n  CodeEditorSuggestionItem,\n  CodeEditorSuggestionItemKind,\n  withTheme2,\n  Themeable2,\n} from '@grafana/ui';\n\nimport InfluxDatasource from '../datasource';\nimport { InfluxQuery } from '../types';\n\ninterface Props extends Themeable2 {\n  onChange: (query: InfluxQuery) => void;\n  onRunQuery: () => void;\n  query: InfluxQuery;\n  // `datasource` is not used internally, but this component is used at some places\n  // directly, where the `datasource` prop has to exist. later, when the whole\n  // query-editor gets converted to react we can stop using this component directly\n  // and then we can probably remove the datasource attribute.\n  datasource: InfluxDatasource;\n}\n\nconst samples: Array<SelectableValue<string>> = [\n  { label: 'Show buckets', description: 'List the available buckets (table)', value: 'buckets()' },\n  {\n    label: 'Simple query',\n    description: 'filter by measurement and field',\n    value: `from(bucket: \"db/rp\")\n  |> range(start: v.timeRangeStart, stop:v.timeRangeStop)\n  |> filter(fn: (r) =>\n    r._measurement == \"example-measurement\" and\n    r._field == \"example-field\"\n  )`,\n  },\n  {\n    label: 'Grouped Query',\n    description: 'Group by (min/max/sum/median)',\n    value: `// v.windowPeriod is a variable referring to the current optimized window period (currently: $interval)\nfrom(bucket: v.bucket)\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_measurement\"] == \"measurement1\" or r[\"_measurement\"] =~ /^.*?regex.*$/)\n  |> filter(fn: (r) => r[\"_field\"] == \"field2\" or r[\"_field\"] =~ /^.*?regex.*$/)\n  |> aggregateWindow(every: v.windowPeriod, fn: mean|median|max|count|derivative|sum)\n  |> yield(name: \"some-name\")`,\n  },\n  {\n    label: 'Filter by value',\n    description: 'Results between a min/max',\n    value: `// v.bucket, v.timeRangeStart, and v.timeRange stop are all variables supported by the flux plugin and influxdb\nfrom(bucket: v.bucket)\n  |> range(start: v.timeRangeStart, stop: v.timeRangeStop)\n  |> filter(fn: (r) => r[\"_value\"] >= 10 and r[\"_value\"] <= 20)`,\n  },\n  {\n    label: 'Schema Exploration: (measurements)',\n    description: 'Get a list of measurement using flux',\n    value: `import \"influxdata/influxdb/v1\"\nv1.measurements(bucket: v.bucket)`,\n  },\n  {\n    label: 'Schema Exploration: (fields)',\n    description: 'Return every possible key in a single table',\n    value: `from(bucket: v.bucket)\n  |> range(start: v.timeRangeStart, stop:v.timeRangeStop)\n  |> keys()\n  |> keep(columns: [\"_value\"])\n  |> group()\n  |> distinct()`,\n  },\n  {\n    label: 'Schema Exploration: (tag keys)',\n    description: 'Get a list of tag keys using flux',\n    value: `import \"influxdata/influxdb/v1\"\nv1.tagKeys(bucket: v.bucket)`,\n  },\n  {\n    label: 'Schema Exploration: (tag values)',\n    description: 'Get a list of tag values using flux',\n    value: `import \"influxdata/influxdb/v1\"\nv1.tagValues(\n    bucket: v.bucket,\n    tag: \"host\",\n    predicate: (r) => true,\n    start: -1d\n)`,\n  },\n];\n\nclass UnthemedFluxQueryEditor extends PureComponent<Props> {\n  onFluxQueryChange = (query: string) => {\n    this.props.onChange({ ...this.props.query, query });\n    this.props.onRunQuery();\n  };\n\n  onSampleChange = (val: SelectableValue<string>) => {\n    this.props.onChange({\n      ...this.props.query,\n      query: val.value!,\n    });\n\n    // Angular HACK: Since the target does not actually change!\n    this.forceUpdate();\n    this.props.onRunQuery();\n  };\n\n  getSuggestions = (): CodeEditorSuggestionItem[] => {\n    const sugs: CodeEditorSuggestionItem[] = [\n      {\n        label: 'v.timeRangeStart',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'The start time',\n      },\n      {\n        label: 'v.timeRangeStop',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'The stop time',\n      },\n      {\n        label: 'v.windowPeriod',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'based on max data points',\n      },\n      {\n        label: 'v.defaultBucket',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'bucket configured in the datsource',\n      },\n      {\n        label: 'v.organization',\n        kind: CodeEditorSuggestionItemKind.Property,\n        detail: 'org configured for the datsource',\n      },\n    ];\n\n    const templateSrv = getTemplateSrv();\n    templateSrv.getVariables().forEach((variable) => {\n      const label = '${' + variable.name + '}';\n      let val = templateSrv.replace(label);\n      if (val === label) {\n        val = '';\n      }\n      sugs.push({\n        label,\n        kind: CodeEditorSuggestionItemKind.Text,\n        detail: `(Template Variable) ${val}`,\n      });\n    });\n\n    return sugs;\n  };\n\n  // For some reason in angular, when this component gets re-mounted, the width\n  // is not set properly.  This forces the layout shortly after mount so that it\n  // displays OK.  Note: this is not an issue when used directly in react\n  editorDidMountCallbackHack = (editor: MonacoEditor) => {\n    setTimeout(() => editor.layout(), 100);\n  };\n\n  render() {\n    const { query, theme } = this.props;\n    const styles = getStyles(theme);\n\n    const helpTooltip = (\n      <div>\n        Type: <i>ctrl+space</i> to show template variable suggestions <br />\n        Many queries can be copied from Chronograf\n      </div>\n    );\n\n    return (\n      <>\n        <CodeEditor\n          height={'100%'}\n          containerStyles={styles.editorContainerStyles}\n          language=\"sql\"\n          value={query.query || ''}\n          onBlur={this.onFluxQueryChange}\n          onSave={this.onFluxQueryChange}\n          showMiniMap={false}\n          showLineNumbers={true}\n          getSuggestions={this.getSuggestions}\n          onEditorDidMount={this.editorDidMountCallbackHack}\n        />\n        <div className={cx('gf-form-inline', styles.editorActions)}>\n          <LinkButton\n            icon=\"external-link-alt\"\n            variant=\"secondary\"\n            target=\"blank\"\n            href=\"https://docs.influxdata.com/influxdb/latest/query-data/get-started/\"\n          >\n            Flux language syntax\n          </LinkButton>\n          <Segment options={samples} value=\"Sample Query\" onChange={this.onSampleChange} />\n          <div className=\"gf-form gf-form--grow\">\n            <div className=\"gf-form-label gf-form-label--grow\"></div>\n          </div>\n          <InlineFormLabel width={5} tooltip={helpTooltip}>\n            Help\n          </InlineFormLabel>\n        </div>\n      </>\n    );\n  }\n}\n\nconst getStyles = (theme: GrafanaTheme2) => ({\n  editorContainerStyles: css`\n    height: 200px;\n    max-width: 100%;\n    resize: vertical;\n    overflow: auto;\n    background-color: ${theme.isDark ? theme.colors.background.canvas : theme.colors.background.primary};\n    padding-bottom: ${theme.spacing(1)};\n  `,\n  editorActions: css`\n    margin-top: 6px;\n  `,\n});\n\nexport const FluxQueryEditor = withTheme2(UnthemedFluxQueryEditor);\n","import React, { useEffect, useState } from 'react';\n\nimport { Button, ConfirmModal } from '@grafana/ui';\n\ntype Props = {\n  isRaw: boolean;\n  onChange: (newIsRaw: boolean) => void;\n};\n\nexport const QueryEditorModeSwitcher = ({ isRaw, onChange }: Props): JSX.Element => {\n  const [isModalOpen, setModalOpen] = useState(false);\n\n  useEffect(() => {\n    // if the isRaw changes, we hide the modal\n    setModalOpen(false);\n  }, [isRaw]);\n\n  if (isRaw) {\n    return (\n      <>\n        <Button\n          aria-label=\"Switch to visual editor\"\n          icon=\"pen\"\n          variant=\"secondary\"\n          type=\"button\"\n          onClick={() => {\n            // we show the are-you-sure modal\n            setModalOpen(true);\n          }}\n        ></Button>\n        <ConfirmModal\n          isOpen={isModalOpen}\n          title=\"Switch to visual editor mode\"\n          body=\"Are you sure to switch to visual editor mode? You will lose the changes done in raw query mode.\"\n          confirmText=\"Yes, switch to editor mode\"\n          dismissText=\"No, stay in raw query mode\"\n          onConfirm={() => {\n            onChange(false);\n          }}\n          onDismiss={() => {\n            setModalOpen(false);\n          }}\n        />\n      </>\n    );\n  } else {\n    return (\n      <Button\n        aria-label=\"Switch to text editor\"\n        icon=\"pen\"\n        variant=\"secondary\"\n        type=\"button\"\n        onClick={() => {\n          onChange(true);\n        }}\n      ></Button>\n    );\n  }\n};\n","import { SelectableValue } from '@grafana/data';\n\nimport { ResultFormat } from '../types';\n\nexport const RESULT_FORMATS: Array<SelectableValue<ResultFormat>> = [\n  { label: 'Time series', value: 'time_series' },\n  { label: 'Table', value: 'table' },\n  { label: 'Logs', value: 'logs' },\n];\n\nexport const DEFAULT_RESULT_FORMAT: ResultFormat = 'time_series';\n","import { useState, useEffect } from 'react';\nimport { usePrevious } from 'react-use';\n\nexport function useShadowedState<T>(outsideVal: T): [T, (newVal: T) => void] {\n  const [currentVal, setCurrentVal] = useState(outsideVal);\n  const prevOutsideVal = usePrevious(outsideVal);\n\n  useEffect(() => {\n    const isOutsideValChanged = prevOutsideVal !== outsideVal;\n    // if the value changes from the outside, we accept it into the state\n    // (we only set it if it is different from the current value)\n    if (isOutsideValChanged && currentVal !== outsideVal) {\n      setCurrentVal(outsideVal);\n    }\n  }, [outsideVal, currentVal, prevOutsideVal]);\n\n  return [currentVal, setCurrentVal];\n}\n","import React from 'react';\n\nimport { TextArea, InlineFormLabel, Input, Select, HorizontalGroup } from '@grafana/ui';\n\nimport { InfluxQuery } from '../types';\n\nimport { RESULT_FORMATS, DEFAULT_RESULT_FORMAT } from './constants';\nimport { useShadowedState } from './useShadowedState';\nimport { useUniqueId } from './useUniqueId';\n\ntype Props = {\n  query: InfluxQuery;\n  onChange: (query: InfluxQuery) => void;\n  onRunQuery: () => void;\n};\n\n// we handle 3 fields: \"query\", \"alias\", \"resultFormat\"\n// \"resultFormat\" changes are applied immediately\n// \"query\" and \"alias\" changes only happen on onblur\nexport const RawInfluxQLEditor = ({ query, onChange, onRunQuery }: Props): JSX.Element => {\n  const [currentQuery, setCurrentQuery] = useShadowedState(query.query);\n  const [currentAlias, setCurrentAlias] = useShadowedState(query.alias);\n  const aliasElementId = useUniqueId();\n  const selectElementId = useUniqueId();\n\n  const resultFormat = query.resultFormat ?? DEFAULT_RESULT_FORMAT;\n\n  const applyDelayedChangesAndRunQuery = () => {\n    onChange({\n      ...query,\n      query: currentQuery,\n      alias: currentAlias,\n      resultFormat,\n    });\n    onRunQuery();\n  };\n\n  return (\n    <div>\n      <TextArea\n        aria-label=\"query\"\n        rows={3}\n        spellCheck={false}\n        placeholder=\"InfluxDB Query\"\n        onBlur={applyDelayedChangesAndRunQuery}\n        onChange={(e) => {\n          setCurrentQuery(e.currentTarget.value);\n        }}\n        value={currentQuery ?? ''}\n      />\n      <HorizontalGroup>\n        <InlineFormLabel htmlFor={selectElementId}>Format as</InlineFormLabel>\n        <Select\n          inputId={selectElementId}\n          onChange={(v) => {\n            onChange({ ...query, resultFormat: v.value });\n            onRunQuery();\n          }}\n          value={resultFormat}\n          options={RESULT_FORMATS}\n        />\n        <InlineFormLabel htmlFor={aliasElementId}>Alias by</InlineFormLabel>\n        <Input\n          id={aliasElementId}\n          type=\"text\"\n          spellCheck={false}\n          placeholder=\"Naming pattern\"\n          onBlur={applyDelayedChangesAndRunQuery}\n          onChange={(e) => {\n            setCurrentAlias(e.currentTarget.value);\n          }}\n          value={currentAlias ?? ''}\n        />\n      </HorizontalGroup>\n    </div>\n  );\n};\n","import { reduce } from 'lodash';\n\nimport kbn from 'app/core/utils/kbn';\n\nfunction renderTagCondition(tag: { operator: any; value: string; condition: any; key: string }, index: number) {\n  // FIXME: merge this function with influx_query_model/renderTagCondition\n  let str = '';\n  let operator = tag.operator;\n  let value = tag.value;\n  if (index > 0) {\n    str = (tag.condition || 'AND') + ' ';\n  }\n\n  if (!operator) {\n    if (/^\\/.*\\/$/.test(tag.value)) {\n      operator = '=~';\n    } else {\n      operator = '=';\n    }\n  }\n\n  // quote value unless regex or empty-string\n  // Influx versions before 0.13 had inconsistent requirements on if (numeric) tags are quoted or not.\n  if (value === '' || (operator !== '=~' && operator !== '!~')) {\n    value = \"'\" + value.replace(/\\\\/g, '\\\\\\\\').replace(/\\'/g, \"\\\\'\") + \"'\";\n  }\n\n  return str + '\"' + tag.key + '\" ' + operator + ' ' + value;\n}\n\nexport class InfluxQueryBuilder {\n  constructor(private target: { measurement: any; tags: any; policy?: any }, private database?: string) {}\n\n  buildExploreQuery(type: string, withKey?: string, withMeasurementFilter?: string): string {\n    let query = '';\n    let measurement;\n    let policy;\n\n    if (type === 'TAG_KEYS') {\n      query = 'SHOW TAG KEYS';\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n    } else if (type === 'TAG_VALUES') {\n      query = 'SHOW TAG VALUES';\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n    } else if (type === 'MEASUREMENTS') {\n      query = 'SHOW MEASUREMENTS';\n      if (withMeasurementFilter) {\n        // we do a case-insensitive regex-based lookup\n        query += ' WITH MEASUREMENT =~ /(?i)' + kbn.regexEscape(withMeasurementFilter) + '/';\n      }\n    } else if (type === 'FIELDS') {\n      measurement = this.target.measurement;\n      policy = this.target.policy;\n\n      if (!measurement.match('^/.*/')) {\n        measurement = '\"' + measurement + '\"';\n\n        if (policy && policy !== 'default') {\n          policy = '\"' + policy + '\"';\n          measurement = policy + '.' + measurement;\n        }\n      }\n\n      return 'SHOW FIELD KEYS FROM ' + measurement;\n    } else if (type === 'RETENTION POLICIES') {\n      query = 'SHOW RETENTION POLICIES on \"' + this.database + '\"';\n      return query;\n    }\n\n    if (measurement) {\n      if (!measurement.match('^/.*/') && !measurement.match(/^merge\\(.*\\)/)) {\n        measurement = '\"' + measurement + '\"';\n      }\n\n      if (policy && policy !== 'default') {\n        policy = '\"' + policy + '\"';\n        measurement = policy + '.' + measurement;\n      }\n\n      query += ' FROM ' + measurement;\n    }\n\n    if (withKey) {\n      query += ' WITH KEY = \"' + withKey + '\"';\n    }\n\n    if (this.target.tags && this.target.tags.length > 0) {\n      const whereConditions = reduce(\n        this.target.tags,\n        (memo, tag) => {\n          // do not add a condition for the key we want to explore for\n          if (tag.key === withKey) {\n            return memo;\n          }\n\n          // value operators not supported in these types of queries\n          if (tag.operator === '>' || tag.operator === '<') {\n            return memo;\n          }\n\n          memo.push(renderTagCondition(tag, memo.length));\n          return memo;\n        },\n        [] as string[]\n      );\n\n      if (whereConditions.length > 0) {\n        query += ' WHERE ' + whereConditions.join(' ');\n      }\n    }\n\n    if (type === 'MEASUREMENTS') {\n      query += ' LIMIT 100';\n      //Solve issue #2524 by limiting the number of measurements returned\n      //LIMIT must be after WITH MEASUREMENT and WHERE clauses\n      //This also could be used for TAG KEYS and TAG VALUES, if desired\n    }\n\n    return query;\n  }\n}\n","import InfluxDatasource from './datasource';\nimport { InfluxQueryBuilder } from './query_builder';\nimport { InfluxQueryTag } from './types';\n\nconst runExploreQuery = (\n  type: string,\n  withKey: string | undefined,\n  withMeasurementFilter: string | undefined,\n  target: { measurement: string | undefined; tags: InfluxQueryTag[]; policy: string | undefined },\n  datasource: InfluxDatasource\n): Promise<Array<{ text: string }>> => {\n  const builder = new InfluxQueryBuilder(target, datasource.database);\n  const q = builder.buildExploreQuery(type, withKey, withMeasurementFilter);\n  return datasource.metricFindQuery(q);\n};\n\nexport async function getAllPolicies(datasource: InfluxDatasource): Promise<string[]> {\n  const target = { tags: [], measurement: undefined, policy: undefined };\n  const data = await runExploreQuery('RETENTION POLICIES', undefined, undefined, target, datasource);\n  return data.map((item) => item.text);\n}\n\nexport async function getAllMeasurementsForTags(\n  measurementFilter: string | undefined,\n  tags: InfluxQueryTag[],\n  datasource: InfluxDatasource\n): Promise<string[]> {\n  const target = { tags, measurement: undefined, policy: undefined };\n  const data = await runExploreQuery('MEASUREMENTS', undefined, measurementFilter, target, datasource);\n  return data.map((item) => item.text);\n}\n\nexport async function getTagKeysForMeasurementAndTags(\n  measurement: string | undefined,\n  policy: string | undefined,\n  tags: InfluxQueryTag[],\n  datasource: InfluxDatasource\n): Promise<string[]> {\n  const target = { tags, measurement, policy };\n  const data = await runExploreQuery('TAG_KEYS', undefined, undefined, target, datasource);\n  return data.map((item) => item.text);\n}\n\nexport async function getTagValues(\n  tagKey: string,\n  measurement: string | undefined,\n  policy: string | undefined,\n  tags: InfluxQueryTag[],\n  datasource: InfluxDatasource\n): Promise<string[]> {\n  const target = { tags, measurement, policy };\n  const data = await runExploreQuery('TAG_VALUES', tagKey, undefined, target, datasource);\n  return data.map((item) => item.text);\n}\n\nexport async function getFieldKeysForMeasurement(\n  measurement: string,\n  policy: string | undefined,\n  datasource: InfluxDatasource\n): Promise<string[]> {\n  const target = { tags: [], measurement, policy };\n  const data = await runExploreQuery('FIELDS', undefined, undefined, target, datasource);\n  return data.map((item) => item.text);\n}\n","import { css } from '@emotion/css';\n\nexport const paddingRightClass = css({\n  paddingRight: '4px',\n});\n","export function unwrap<T>(value: T | null | undefined): T {\n  if (value == null) {\n    throw new Error('value must not be nullish');\n  }\n  return value;\n}\n","import { cx } from '@emotion/css';\nimport React from 'react';\n\nimport { Select } from '@grafana/ui';\n\nimport { ResultFormat } from '../../types';\nimport { RESULT_FORMATS } from '../constants';\n\nimport { paddingRightClass } from './styles';\nimport { unwrap } from './unwrap';\n\ntype Props = {\n  inputId?: string;\n  format: ResultFormat;\n  onChange: (newFormat: ResultFormat) => void;\n};\n\nconst className = cx('width-8', paddingRightClass);\n\nexport const FormatAsSection = ({ format, inputId, onChange }: Props): JSX.Element => {\n  return (\n    <Select<ResultFormat>\n      inputId={inputId}\n      className={className}\n      onChange={(v) => {\n        onChange(unwrap(v.value));\n      }}\n      value={format}\n      options={RESULT_FORMATS}\n    />\n  );\n};\n","import { cx, css } from '@emotion/css';\nimport debouncePromise from 'debounce-promise';\nimport React, { useState, useEffect } from 'react';\nimport { useAsyncFn } from 'react-use';\n\nimport { SelectableValue } from '@grafana/data';\nimport { InlineLabel, Select, AsyncSelect, Input } from '@grafana/ui';\n\nimport { useShadowedState } from '../useShadowedState';\n\n// this file is a simpler version of `grafana-ui / SegmentAsync.tsx`\n// with some changes:\n// 1. click-outside does not select the value. i think it's better to be explicit here.\n// 2. we set a min-width on the select-element to handle cases where the `value`\n//    is very short, like \"x\", and then you click on it and the select opens,\n//    and it tries to be as short as \"x\" and it does not work well.\n\n// NOTE: maybe these changes could be migrated into the SegmentAsync later\n\ntype SelVal = SelectableValue<string>;\n\n// when allowCustomValue is true, there is no way to enforce the selectableValue\n// enum-type, so i just go with `string`\n\ntype LoadOptions = (filter: string) => Promise<SelVal[]>;\n\ntype Props = {\n  value: string;\n  buttonClassName?: string;\n  loadOptions?: LoadOptions;\n  // if filterByLoadOptions is false,\n  // loadOptions is only executed once,\n  // when the select-box opens,\n  // and as you write, the list gets filtered\n  // by the select-box.\n  // if filterByLoadOptions is true,\n  // as you write the loadOptions is executed again and again,\n  // and it is relied on to filter the results.\n  filterByLoadOptions?: boolean;\n  onChange: (v: SelVal) => void;\n  allowCustomValue?: boolean;\n};\n\nconst selectClass = css({\n  minWidth: '160px',\n});\n\ntype SelProps = {\n  loadOptions: LoadOptions;\n  filterByLoadOptions?: boolean;\n  onClose: () => void;\n  onChange: (v: SelVal) => void;\n  allowCustomValue?: boolean;\n};\n\ntype SelReloadProps = {\n  loadOptions: (filter: string) => Promise<SelVal[]>;\n  onClose: () => void;\n  onChange: (v: SelVal) => void;\n  allowCustomValue?: boolean;\n};\n\n// when a custom value is written into a select-box,\n// by default the new value is prefixed with \"Create:\",\n// and that sounds confusing because here we do not create\n// anything. we change this to just be the entered string.\nconst formatCreateLabel = (v: string) => v;\n\nconst SelReload = ({ loadOptions, allowCustomValue, onChange, onClose }: SelReloadProps): JSX.Element => {\n  // here we rely on the fact that writing text into the <AsyncSelect/>\n  // does not cause a re-render of the current react component.\n  // this way there is only a single render-call,\n  // so there is only a single `debouncedLoadOptions`.\n  // if we want ot make this \"re-render safe,\n  // we will have to put the debounced call into an useRef,\n  // and probably have an useEffect\n  const debouncedLoadOptions = debouncePromise(loadOptions, 1000, { leading: true });\n  return (\n    <div className={selectClass}>\n      <AsyncSelect\n        formatCreateLabel={formatCreateLabel}\n        defaultOptions\n        autoFocus\n        isOpen\n        onCloseMenu={onClose}\n        allowCustomValue={allowCustomValue}\n        loadOptions={debouncedLoadOptions}\n        onChange={onChange}\n      />\n    </div>\n  );\n};\n\ntype SelSingleLoadProps = {\n  loadOptions: (filter: string) => Promise<SelVal[]>;\n  onClose: () => void;\n  onChange: (v: SelVal) => void;\n  allowCustomValue?: boolean;\n};\n\nconst SelSingleLoad = ({ loadOptions, allowCustomValue, onChange, onClose }: SelSingleLoadProps): JSX.Element => {\n  const [loadState, doLoad] = useAsyncFn(loadOptions, [loadOptions]);\n\n  useEffect(() => {\n    doLoad('');\n  }, [doLoad, loadOptions]);\n\n  return (\n    <div className={selectClass}>\n      <Select\n        isLoading={loadState.loading}\n        formatCreateLabel={formatCreateLabel}\n        autoFocus\n        isOpen={!loadState.loading}\n        onCloseMenu={onClose}\n        allowCustomValue={allowCustomValue}\n        options={loadState.value ?? []}\n        onChange={onChange}\n      />\n    </div>\n  );\n};\n\nconst Sel = ({ loadOptions, filterByLoadOptions, allowCustomValue, onChange, onClose }: SelProps): JSX.Element => {\n  // unfortunately <Segment/> and <SegmentAsync/> have somewhat different behavior,\n  // so the simplest approach was to just create two separate wrapper-components\n  return filterByLoadOptions ? (\n    <SelReload loadOptions={loadOptions} allowCustomValue={allowCustomValue} onChange={onChange} onClose={onClose} />\n  ) : (\n    <SelSingleLoad\n      loadOptions={loadOptions}\n      allowCustomValue={allowCustomValue}\n      onChange={onChange}\n      onClose={onClose}\n    />\n  );\n};\n\ntype InpProps = {\n  initialValue: string;\n  onChange: (newVal: string) => void;\n  onClose: () => void;\n};\n\nconst Inp = ({ initialValue, onChange, onClose }: InpProps): JSX.Element => {\n  const [currentValue, setCurrentValue] = useShadowedState(initialValue);\n\n  return (\n    <Input\n      autoFocus\n      type=\"text\"\n      spellCheck={false}\n      onBlur={onClose}\n      onKeyDown={(e) => {\n        if (e.key === 'Enter') {\n          onChange(currentValue);\n        }\n      }}\n      onChange={(e) => {\n        setCurrentValue(e.currentTarget.value);\n      }}\n      value={currentValue}\n    />\n  );\n};\n\nconst defaultButtonClass = css({\n  width: 'auto',\n  cursor: 'pointer',\n});\n\nexport const Seg = ({\n  value,\n  buttonClassName,\n  loadOptions,\n  filterByLoadOptions,\n  allowCustomValue,\n  onChange,\n}: Props): JSX.Element => {\n  const [isOpen, setOpen] = useState(false);\n  if (!isOpen) {\n    const className = cx(defaultButtonClass, buttonClassName);\n    return (\n      <InlineLabel\n        as=\"button\"\n        className={className}\n        onClick={() => {\n          setOpen(true);\n        }}\n      >\n        {value}\n      </InlineLabel>\n    );\n  } else {\n    if (loadOptions !== undefined) {\n      return (\n        <Sel\n          loadOptions={loadOptions}\n          filterByLoadOptions={filterByLoadOptions ?? false}\n          allowCustomValue={allowCustomValue}\n          onChange={(v) => {\n            setOpen(false);\n            onChange(v);\n          }}\n          onClose={() => {\n            setOpen(false);\n          }}\n        />\n      );\n    } else {\n      return (\n        <Inp\n          initialValue={value}\n          onClose={() => {\n            setOpen(false);\n          }}\n          onChange={(v) => {\n            setOpen(false);\n            onChange({ value: v, label: v });\n          }}\n        />\n      );\n    }\n  }\n};\n","import { SelectableValue } from '@grafana/data';\n\nexport function toSelectableValue<T extends string>(t: T): SelectableValue<T> {\n  return { label: t, value: t };\n}\n","import React from 'react';\n\nimport { Seg } from './Seg';\nimport { toSelectableValue } from './toSelectableValue';\n\nconst DEFAULT_POLICY = 'default';\n\n// we use the value \"default\" as a magic-value, it means\n// we use the default retention-policy.\n// unfortunately, IF the user has a retention-policy named \"default\",\n// and it is not the default-retention-policy in influxdb,\n// bad things will happen.\n// https://github.com/grafana/grafana/issues/4347 :-(\n// FIXME: we could maybe at least detect here that problem-is-happening,\n// and show an error message or something.\n// unfortunately, currently the ResponseParser does not return the\n// is-default info for the retention-policies, so that should change first.\n\ntype Props = {\n  onChange: (policy: string | undefined, measurement: string | undefined) => void;\n  policy: string | undefined;\n  measurement: string | undefined;\n  getPolicyOptions: () => Promise<string[]>;\n  getMeasurementOptions: (filter: string) => Promise<string[]>;\n};\n\nexport const FromSection = ({\n  policy,\n  measurement,\n  onChange,\n  getPolicyOptions,\n  getMeasurementOptions,\n}: Props): JSX.Element => {\n  const handlePolicyLoadOptions = async () => {\n    const allPolicies = await getPolicyOptions();\n    // if `default` does not exist in the list of policies, we add it\n    const allPoliciesWithDefault = allPolicies.some((p) => p === 'default')\n      ? allPolicies\n      : [DEFAULT_POLICY, ...allPolicies];\n\n    return allPoliciesWithDefault.map(toSelectableValue);\n  };\n\n  const handleMeasurementLoadOptions = async (filter: string) => {\n    const allMeasurements = await getMeasurementOptions(filter);\n    return allMeasurements.map(toSelectableValue);\n  };\n\n  return (\n    <>\n      <Seg\n        allowCustomValue\n        value={policy ?? 'using default policy'}\n        loadOptions={handlePolicyLoadOptions}\n        onChange={(v) => {\n          onChange(v.value, measurement);\n        }}\n      />\n      <Seg\n        allowCustomValue\n        value={measurement ?? 'select measurement'}\n        loadOptions={handleMeasurementLoadOptions}\n        filterByLoadOptions\n        onChange={(v) => {\n          onChange(policy, v.value);\n        }}\n      />\n    </>\n  );\n};\n","import { cx } from '@emotion/css';\nimport React from 'react';\n\nimport { Input } from '@grafana/ui';\n\nimport { useShadowedState } from '../useShadowedState';\n\nimport { paddingRightClass } from './styles';\n\ntype Props = {\n  value: string | undefined;\n  onChange: (value: string | undefined) => void;\n  isWide?: boolean;\n  placeholder?: string;\n};\n\nexport const InputSection = ({ value, onChange, isWide, placeholder }: Props): JSX.Element => {\n  const [currentValue, setCurrentValue] = useShadowedState(value);\n\n  const onBlur = () => {\n    // we send empty-string as undefined\n    const newValue = currentValue === '' ? undefined : currentValue;\n    onChange(newValue);\n  };\n\n  return (\n    <>\n      <Input\n        placeholder={placeholder}\n        className={cx(isWide ?? false ? 'width-14' : 'width-8', paddingRightClass)}\n        type=\"text\"\n        spellCheck={false}\n        onBlur={onBlur}\n        onChange={(e) => {\n          setCurrentValue(e.currentTarget.value);\n        }}\n        value={currentValue ?? ''}\n      />\n    </>\n  );\n};\n","import { cx } from '@emotion/css';\nimport React from 'react';\n\nimport { SelectableValue } from '@grafana/data';\nimport { Select } from '@grafana/ui';\n\nimport { paddingRightClass } from './styles';\nimport { unwrap } from './unwrap';\n\ntype Mode = 'ASC' | 'DESC';\n\nconst OPTIONS: Array<SelectableValue<Mode>> = [\n  { label: 'ascending', value: 'ASC' },\n  { label: 'descending', value: 'DESC' },\n];\n\nconst className = cx('width-9', paddingRightClass);\n\ntype Props = {\n  value: Mode;\n  onChange: (value: Mode) => void;\n  inputId?: string;\n};\n\nexport const OrderByTimeSection = ({ value, onChange, inputId }: Props): JSX.Element => {\n  return (\n    <>\n      <Select<Mode>\n        inputId={inputId}\n        className={className}\n        onChange={(v) => {\n          onChange(unwrap(v.value));\n        }}\n        value={value}\n        options={OPTIONS}\n      />\n    </>\n  );\n};\n","import React from 'react';\n\nimport { SelectableValue } from '@grafana/data';\n\nimport { Seg } from './Seg';\nimport { unwrap } from './unwrap';\n\ntype Props = {\n  loadOptions: () => Promise<SelectableValue[]>;\n  allowCustomValue?: boolean;\n  onAdd: (v: string) => void;\n};\n\nexport const AddButton = ({ loadOptions, allowCustomValue, onAdd }: Props): JSX.Element => {\n  return (\n    <Seg\n      value=\"+\"\n      loadOptions={loadOptions}\n      allowCustomValue={allowCustomValue}\n      onChange={(v) => {\n        onAdd(unwrap(v.value));\n      }}\n    />\n  );\n};\n","import { cx, css } from '@emotion/css';\nimport React, { useMemo } from 'react';\n\nimport { SelectableValue, GrafanaTheme2 } from '@grafana/data';\nimport { MenuItem, WithContextMenu, MenuGroup, useTheme2 } from '@grafana/ui';\n\nimport { AddButton } from './AddButton';\nimport { Seg } from './Seg';\nimport { toSelectableValue } from './toSelectableValue';\nimport { unwrap } from './unwrap';\n\nexport type PartParams = Array<{\n  value: string;\n  options: (() => Promise<string[]>) | null;\n}>;\n\ntype Props = {\n  parts: Array<{\n    name: string;\n    params: PartParams;\n  }>;\n  getNewPartOptions: () => Promise<SelectableValue[]>;\n  onChange: (partIndex: number, paramValues: string[]) => void;\n  onRemovePart: (index: number) => void;\n  onAddNewPart: (type: string) => void;\n};\n\nconst renderRemovableNameMenuItems = (onClick: () => void) => {\n  return (\n    <MenuGroup label=\"\">\n      <MenuItem label=\"remove\" onClick={onClick} />\n    </MenuGroup>\n  );\n};\n\nconst noRightMarginPaddingClass = css({\n  paddingRight: '0',\n  marginRight: '0',\n});\n\nconst RemovableName = ({ name, onRemove }: { name: string; onRemove: () => void }) => {\n  return (\n    <WithContextMenu renderMenuItems={() => renderRemovableNameMenuItems(onRemove)}>\n      {({ openMenu }) => (\n        <button className={cx('gf-form-label', noRightMarginPaddingClass)} onClick={openMenu}>\n          {name}\n        </button>\n      )}\n    </WithContextMenu>\n  );\n};\n\ntype PartProps = {\n  name: string;\n  params: PartParams;\n  onRemove: () => void;\n  onChange: (paramValues: string[]) => void;\n};\n\nconst noHorizMarginPaddingClass = css({\n  paddingLeft: '0',\n  paddingRight: '0',\n  marginLeft: '0',\n  marginRight: '0',\n});\n\nconst getPartClass = (theme: GrafanaTheme2) => {\n  return cx(\n    'gf-form-label',\n    css({\n      paddingLeft: '0',\n      // gf-form-label class makes certain css attributes incorrect\n      // for the selectbox-dropdown, so we have to \"reset\" them back\n      lineHeight: theme.typography.body.lineHeight,\n      fontSize: theme.typography.body.fontSize,\n    })\n  );\n};\n\nconst Part = ({ name, params, onChange, onRemove }: PartProps): JSX.Element => {\n  const theme = useTheme2();\n  const partClass = useMemo(() => getPartClass(theme), [theme]);\n\n  const onParamChange = (par: string, i: number) => {\n    const newParams = params.map((p) => p.value);\n    newParams[i] = par;\n    onChange(newParams);\n  };\n  return (\n    <div className={partClass}>\n      <RemovableName name={name} onRemove={onRemove} />(\n      {params.map((p, i) => {\n        const { value, options } = p;\n        const isLast = i === params.length - 1;\n        const loadOptions =\n          options !== null ? () => options().then((items) => items.map(toSelectableValue)) : undefined;\n        return (\n          <React.Fragment key={i}>\n            <Seg\n              allowCustomValue\n              value={value}\n              buttonClassName={noHorizMarginPaddingClass}\n              loadOptions={loadOptions}\n              onChange={(v) => {\n                onParamChange(unwrap(v.value), i);\n              }}\n            />\n            {!isLast && ','}\n          </React.Fragment>\n        );\n      })}\n      )\n    </div>\n  );\n};\n\nexport const PartListSection = ({\n  parts,\n  getNewPartOptions,\n  onAddNewPart,\n  onRemovePart,\n  onChange,\n}: Props): JSX.Element => {\n  return (\n    <>\n      {parts.map((part, index) => (\n        <Part\n          key={index}\n          name={part.name}\n          params={part.params}\n          onRemove={() => {\n            onRemovePart(index);\n          }}\n          onChange={(pars) => {\n            onChange(index, pars);\n          }}\n        />\n      ))}\n      <AddButton loadOptions={getNewPartOptions} onAdd={onAddNewPart} />\n    </>\n  );\n};\n","import { InfluxQueryTag } from '../../types';\n\nfunction isRegex(text: string): boolean {\n  return /^\\/.*\\/$/.test(text);\n}\n\n// FIXME: sync these to the query-string-generation-code\n// probably it's in influx_query_model.ts\nexport function getOperator(tag: InfluxQueryTag): string {\n  return tag.operator ?? (isRegex(tag.value) ? '=~' : '=');\n}\n\n// FIXME: sync these to the query-string-generation-code\n// probably it's in influx_query_model.ts\nexport function getCondition(tag: InfluxQueryTag, isFirst: boolean): string | undefined {\n  return isFirst ? undefined : tag.condition ?? 'AND';\n}\n\nexport function adjustOperatorIfNeeded(currentOperator: string, newTagValue: string): string {\n  const isCurrentOperatorRegex = currentOperator === '=~' || currentOperator === '!~';\n  const isNewTagValueRegex = isRegex(newTagValue);\n\n  if (isNewTagValueRegex) {\n    return isCurrentOperatorRegex ? currentOperator : '=~';\n  } else {\n    return isCurrentOperatorRegex ? '=' : currentOperator;\n  }\n}\n","import React from 'react';\n\nimport { SelectableValue } from '@grafana/data';\n\nimport { InfluxQueryTag } from '../../types';\n\nimport { AddButton } from './AddButton';\nimport { Seg } from './Seg';\nimport { adjustOperatorIfNeeded, getCondition, getOperator } from './tagUtils';\nimport { toSelectableValue } from './toSelectableValue';\n\ntype KnownOperator = '=' | '!=' | '<>' | '<' | '>' | '=~' | '!~';\nconst knownOperators: KnownOperator[] = ['=', '!=', '<>', '<', '>', '=~', '!~'];\n\ntype KnownCondition = 'AND' | 'OR';\nconst knownConditions: KnownCondition[] = ['AND', 'OR'];\n\nconst operatorOptions: Array<SelectableValue<KnownOperator>> = knownOperators.map(toSelectableValue);\nconst condititonOptions: Array<SelectableValue<KnownCondition>> = knownConditions.map(toSelectableValue);\n\ntype Props = {\n  tags: InfluxQueryTag[];\n  onChange: (tags: InfluxQueryTag[]) => void;\n  getTagKeyOptions: () => Promise<string[]>;\n  getTagValueOptions: (key: string) => Promise<string[]>;\n};\n\ntype TagProps = {\n  tag: InfluxQueryTag;\n  isFirst: boolean;\n  onRemove: () => void;\n  onChange: (tag: InfluxQueryTag) => void;\n  getTagKeyOptions: () => Promise<string[]>;\n  getTagValueOptions: (key: string) => Promise<string[]>;\n};\n\nconst loadConditionOptions = () => Promise.resolve(condititonOptions);\n\nconst loadOperatorOptions = () => Promise.resolve(operatorOptions);\n\nconst Tag = ({ tag, isFirst, onRemove, onChange, getTagKeyOptions, getTagValueOptions }: TagProps): JSX.Element => {\n  const operator = getOperator(tag);\n  const condition = getCondition(tag, isFirst);\n\n  const getTagKeySegmentOptions = () => {\n    return getTagKeyOptions()\n      .catch((err) => {\n        // in this UI element we add a special item to the list of options,\n        // that is used to remove the element.\n        // this causes a problem: if `getTagKeyOptions` fails with an error,\n        // the remove-filter option is never added to the list,\n        // and the UI element can not be removed.\n        // to avoid it, we catch any potential errors coming from `getTagKeyOptions`,\n        // log the error, and pretend that the list of options is an empty list.\n        // this way the remove-item option can always be added to the list.\n        console.error(err);\n        return [];\n      })\n      .then((tags) => [{ label: '-- remove filter --', value: undefined }, ...tags.map(toSelectableValue)]);\n  };\n\n  const getTagValueSegmentOptions = () => {\n    return getTagValueOptions(tag.key).then((tags) => tags.map(toSelectableValue));\n  };\n\n  return (\n    <div className=\"gf-form\">\n      {condition != null && (\n        <Seg\n          value={condition}\n          loadOptions={loadConditionOptions}\n          onChange={(v) => {\n            onChange({ ...tag, condition: v.value });\n          }}\n        />\n      )}\n      <Seg\n        allowCustomValue\n        value={tag.key}\n        loadOptions={getTagKeySegmentOptions}\n        onChange={(v) => {\n          const { value } = v;\n          if (value === undefined) {\n            onRemove();\n          } else {\n            onChange({ ...tag, key: value ?? '' });\n          }\n        }}\n      />\n      <Seg\n        value={operator}\n        loadOptions={loadOperatorOptions}\n        onChange={(op) => {\n          onChange({ ...tag, operator: op.value });\n        }}\n      />\n      <Seg\n        allowCustomValue\n        value={tag.value}\n        loadOptions={getTagValueSegmentOptions}\n        onChange={(v) => {\n          const value = v.value ?? '';\n          onChange({ ...tag, value, operator: adjustOperatorIfNeeded(operator, value) });\n        }}\n      />\n    </div>\n  );\n};\n\nexport const TagsSection = ({ tags, onChange, getTagKeyOptions, getTagValueOptions }: Props): JSX.Element => {\n  const onTagChange = (newTag: InfluxQueryTag, index: number) => {\n    const newTags = tags.map((tag, i) => {\n      return index === i ? newTag : tag;\n    });\n    onChange(newTags);\n  };\n\n  const onTagRemove = (index: number) => {\n    const newTags = tags.filter((t, i) => i !== index);\n    onChange(newTags);\n  };\n\n  const getTagKeySegmentOptions = () => {\n    return getTagKeyOptions().then((tags) => tags.map(toSelectableValue));\n  };\n\n  const addNewTag = (tagKey: string, isFirst: boolean) => {\n    const minimalTag: InfluxQueryTag = {\n      key: tagKey,\n      value: 'select tag value',\n    };\n\n    const newTag: InfluxQueryTag = {\n      key: minimalTag.key,\n      value: minimalTag.value,\n      operator: getOperator(minimalTag),\n      condition: getCondition(minimalTag, isFirst),\n    };\n\n    onChange([...tags, newTag]);\n  };\n\n  return (\n    <>\n      {tags.map((t, i) => (\n        <Tag\n          tag={t}\n          isFirst={i === 0}\n          key={i}\n          onChange={(newT) => {\n            onTagChange(newT, i);\n          }}\n          onRemove={() => {\n            onTagRemove(i);\n          }}\n          getTagKeyOptions={getTagKeyOptions}\n          getTagValueOptions={getTagValueOptions}\n        />\n      ))}\n      <AddButton\n        allowCustomValue\n        loadOptions={getTagKeySegmentOptions}\n        onAdd={(v) => {\n          addNewTag(v, tags.length === 0);\n        }}\n      />\n    </>\n  );\n};\n","import { SelectableValue } from '@grafana/data';\nimport { QueryPartDef } from 'app/features/alerting/state/query_part';\n\nimport InfluxQueryModel from '../../influx_query_model';\nimport queryPart from '../../query_part';\nimport { InfluxQuery, InfluxQueryPart } from '../../types';\n\nimport { PartParams } from './PartListSection';\nimport { toSelectableValue } from './toSelectableValue';\nimport { unwrap } from './unwrap';\n\ntype Categories = Record<string, QueryPartDef[]>;\n\nexport function getNewSelectPartOptions(): SelectableValue[] {\n  const categories: Categories = queryPart.getCategories();\n  const options: SelectableValue[] = [];\n\n  const keys = Object.keys(categories);\n\n  keys.forEach((key) => {\n    const children: SelectableValue[] = categories[key].map((x) => toSelectableValue(x.type));\n\n    options.push({\n      label: key,\n      options: children,\n    });\n  });\n\n  return options;\n}\n\nexport async function getNewGroupByPartOptions(\n  query: InfluxQuery,\n  getTagKeys: () => Promise<string[]>\n): Promise<Array<SelectableValue<string>>> {\n  const tagKeys = await getTagKeys();\n  const queryCopy = { ...query }; // the query-model mutates the query\n  const model = new InfluxQueryModel(queryCopy);\n  const options: Array<SelectableValue<string>> = [];\n  if (!model.hasFill()) {\n    options.push(toSelectableValue('fill(null)'));\n  }\n  if (!model.hasGroupByTime()) {\n    options.push(toSelectableValue('time($interval)'));\n  }\n  tagKeys.forEach((key) => {\n    options.push(toSelectableValue(`tag(${key})`));\n  });\n  return options;\n}\n\ntype Part = {\n  name: string;\n  params: PartParams;\n};\n\nfunction getPartParams(part: InfluxQueryPart, dynamicParamOptions: Map<string, () => Promise<string[]>>): PartParams {\n  // NOTE: the way the system is constructed,\n  // there always can only be one possible dynamic-lookup\n  // field. in case of select it is the field,\n  // in case of group-by it is the tag\n  const def = queryPart.create(part).def;\n\n  // we switch the numbers to strings, it will work that way too,\n  // and it makes the code simpler\n  const paramValues = (part.params ?? []).map((p) => p.toString());\n\n  if (paramValues.length !== def.params.length) {\n    throw new Error('Invalid query-segment');\n  }\n\n  return paramValues.map((val, index) => {\n    const defParam = def.params[index];\n    if (defParam.dynamicLookup) {\n      return {\n        value: val,\n        options: unwrap(dynamicParamOptions.get(`${def.type}_${index}`)),\n      };\n    }\n\n    if (defParam.options != null) {\n      return {\n        value: val,\n        options: () => Promise.resolve(defParam.options),\n      };\n    }\n\n    return {\n      value: val,\n      options: null,\n    };\n  });\n}\n\nexport function makePartList(\n  queryParts: InfluxQueryPart[],\n  dynamicParamOptions: Map<string, () => Promise<string[]>>\n): Part[] {\n  return queryParts.map((qp) => {\n    return {\n      name: qp.type,\n      params: getPartParams(qp, dynamicParamOptions),\n    };\n  });\n}\n","import { css } from '@emotion/css';\nimport React, { useMemo } from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { getTemplateSrv } from '@grafana/runtime';\nimport { InlineLabel, SegmentSection, useStyles2 } from '@grafana/ui';\n\nimport InfluxDatasource from '../../datasource';\nimport {\n  getAllMeasurementsForTags,\n  getAllPolicies,\n  getFieldKeysForMeasurement,\n  getTagKeysForMeasurementAndTags,\n  getTagValues,\n} from '../../influxQLMetadataQuery';\nimport {\n  normalizeQuery,\n  addNewSelectPart,\n  removeSelectPart,\n  addNewGroupByPart,\n  removeGroupByPart,\n  changeSelectPart,\n  changeGroupByPart,\n} from '../../queryUtils';\nimport { InfluxQuery, InfluxQueryTag } from '../../types';\nimport { DEFAULT_RESULT_FORMAT } from '../constants';\nimport { useUniqueId } from '../useUniqueId';\n\nimport { FormatAsSection } from './FormatAsSection';\nimport { FromSection } from './FromSection';\nimport { InputSection } from './InputSection';\nimport { OrderByTimeSection } from './OrderByTimeSection';\nimport { PartListSection } from './PartListSection';\nimport { TagsSection } from './TagsSection';\nimport { getNewSelectPartOptions, getNewGroupByPartOptions, makePartList } from './partListUtils';\n\ntype Props = {\n  query: InfluxQuery;\n  onChange: (query: InfluxQuery) => void;\n  onRunQuery: () => void;\n  datasource: InfluxDatasource;\n};\n\nfunction getTemplateVariableOptions() {\n  return (\n    getTemplateSrv()\n      .getVariables()\n      // we make them regex-params, i'm not 100% sure why.\n      // probably because this way multi-value variables work ok too.\n      .map((v) => `/^$${v.name}$/`)\n  );\n}\n\n// helper function to make it easy to call this from the widget-render-code\nfunction withTemplateVariableOptions(optionsPromise: Promise<string[]>): Promise<string[]> {\n  return optionsPromise.then((options) => [...getTemplateVariableOptions(), ...options]);\n}\n\n// it is possible to add fields into the `InfluxQueryTag` structures, and they do work,\n// but in some cases, when we do metadata queries, we have to remove them from the queries.\nfunction filterTags(parts: InfluxQueryTag[], allTagKeys: Set<string>): InfluxQueryTag[] {\n  return parts.filter((t) => allTagKeys.has(t.key));\n}\n\nexport const Editor = (props: Props): JSX.Element => {\n  const uniqueId = useUniqueId();\n  const formatAsId = `influxdb-qe-format-as-${uniqueId}`;\n  const orderByTimeId = `influxdb-qe-order-by${uniqueId}`;\n\n  const styles = useStyles2(getStyles);\n  const query = normalizeQuery(props.query);\n  const { datasource } = props;\n  const { measurement, policy } = query;\n\n  const allTagKeys = useMemo(() => {\n    return getTagKeysForMeasurementAndTags(measurement, policy, [], datasource).then((tags) => {\n      return new Set(tags);\n    });\n  }, [measurement, policy, datasource]);\n\n  const selectLists = useMemo(() => {\n    const dynamicSelectPartOptions = new Map([\n      [\n        'field_0',\n        () => {\n          return measurement !== undefined\n            ? getFieldKeysForMeasurement(measurement, policy, datasource)\n            : Promise.resolve([]);\n        },\n      ],\n    ]);\n    return (query.select ?? []).map((sel) => makePartList(sel, dynamicSelectPartOptions));\n  }, [measurement, policy, query.select, datasource]);\n\n  // the following function is not complicated enough to memoize, but it's result\n  // is used in both memoized and un-memoized parts, so we have no choice\n  const getTagKeys = useMemo(() => {\n    return () =>\n      allTagKeys.then((keys) =>\n        getTagKeysForMeasurementAndTags(measurement, policy, filterTags(query.tags ?? [], keys), datasource)\n      );\n  }, [measurement, policy, query.tags, datasource, allTagKeys]);\n\n  const groupByList = useMemo(() => {\n    const dynamicGroupByPartOptions = new Map([['tag_0', getTagKeys]]);\n\n    return makePartList(query.groupBy ?? [], dynamicGroupByPartOptions);\n  }, [getTagKeys, query.groupBy]);\n\n  const onAppliedChange = (newQuery: InfluxQuery) => {\n    props.onChange(newQuery);\n    props.onRunQuery();\n  };\n  const handleFromSectionChange = (p: string | undefined, m: string | undefined) => {\n    onAppliedChange({\n      ...query,\n      policy: p,\n      measurement: m,\n    });\n  };\n\n  const handleTagsSectionChange = (tags: InfluxQueryTag[]) => {\n    // we set empty-arrays to undefined\n    onAppliedChange({\n      ...query,\n      tags: tags.length === 0 ? undefined : tags,\n    });\n  };\n\n  return (\n    <div>\n      <SegmentSection label=\"FROM\" fill={true}>\n        <FromSection\n          policy={policy}\n          measurement={measurement}\n          getPolicyOptions={() => getAllPolicies(datasource)}\n          getMeasurementOptions={(filter) =>\n            withTemplateVariableOptions(\n              allTagKeys.then((keys) =>\n                getAllMeasurementsForTags(\n                  filter === '' ? undefined : filter,\n                  filterTags(query.tags ?? [], keys),\n                  datasource\n                )\n              )\n            )\n          }\n          onChange={handleFromSectionChange}\n        />\n        <InlineLabel width=\"auto\" className={styles.inlineLabel}>\n          WHERE\n        </InlineLabel>\n        <TagsSection\n          tags={query.tags ?? []}\n          onChange={handleTagsSectionChange}\n          getTagKeyOptions={getTagKeys}\n          getTagValueOptions={(key: string) =>\n            withTemplateVariableOptions(\n              allTagKeys.then((keys) =>\n                getTagValues(key, measurement, policy, filterTags(query.tags ?? [], keys), datasource)\n              )\n            )\n          }\n        />\n      </SegmentSection>\n      {selectLists.map((sel, index) => (\n        <SegmentSection key={index} label={index === 0 ? 'SELECT' : ''} fill={true}>\n          <PartListSection\n            parts={sel}\n            getNewPartOptions={() => Promise.resolve(getNewSelectPartOptions())}\n            onChange={(partIndex, newParams) => {\n              const newQuery = changeSelectPart(query, index, partIndex, newParams);\n              onAppliedChange(newQuery);\n            }}\n            onAddNewPart={(type) => {\n              onAppliedChange(addNewSelectPart(query, type, index));\n            }}\n            onRemovePart={(partIndex) => {\n              onAppliedChange(removeSelectPart(query, partIndex, index));\n            }}\n          />\n        </SegmentSection>\n      ))}\n      <SegmentSection label=\"GROUP BY\" fill={true}>\n        <PartListSection\n          parts={groupByList}\n          getNewPartOptions={() => getNewGroupByPartOptions(query, getTagKeys)}\n          onChange={(partIndex, newParams) => {\n            const newQuery = changeGroupByPart(query, partIndex, newParams);\n            onAppliedChange(newQuery);\n          }}\n          onAddNewPart={(type) => {\n            onAppliedChange(addNewGroupByPart(query, type));\n          }}\n          onRemovePart={(partIndex) => {\n            onAppliedChange(removeGroupByPart(query, partIndex));\n          }}\n        />\n      </SegmentSection>\n      <SegmentSection label=\"TIMEZONE\" fill={true}>\n        <InputSection\n          placeholder=\"(optional)\"\n          value={query.tz}\n          onChange={(tz) => {\n            onAppliedChange({ ...query, tz });\n          }}\n        />\n        <InlineLabel htmlFor={orderByTimeId} width=\"auto\" className={styles.inlineLabel}>\n          ORDER BY TIME\n        </InlineLabel>\n        <OrderByTimeSection\n          inputId={orderByTimeId}\n          value={query.orderByTime === 'DESC' ? 'DESC' : 'ASC' /* FIXME: make this shared with influx_query_model */}\n          onChange={(v) => {\n            onAppliedChange({ ...query, orderByTime: v });\n          }}\n        />\n      </SegmentSection>\n      {/* query.fill is ignored in the query-editor, and it is deleted whenever\n          query-editor changes. the influx_query_model still handles it, but the new\n          approach seem to be to handle \"fill\" inside query.groupBy. so, if you\n          have a panel where in the json you have query.fill, it will be applied,\n          as long as you do not edit that query. */}\n      <SegmentSection label=\"LIMIT\" fill={true}>\n        <InputSection\n          placeholder=\"(optional)\"\n          value={query.limit?.toString()}\n          onChange={(limit) => {\n            onAppliedChange({ ...query, limit });\n          }}\n        />\n        <InlineLabel width=\"auto\" className={styles.inlineLabel}>\n          SLIMIT\n        </InlineLabel>\n        <InputSection\n          placeholder=\"(optional)\"\n          value={query.slimit?.toString()}\n          onChange={(slimit) => {\n            onAppliedChange({ ...query, slimit });\n          }}\n        />\n      </SegmentSection>\n      <SegmentSection htmlFor={formatAsId} label=\"FORMAT AS\" fill={true}>\n        <FormatAsSection\n          inputId={formatAsId}\n          format={query.resultFormat ?? DEFAULT_RESULT_FORMAT}\n          onChange={(format) => {\n            onAppliedChange({ ...query, resultFormat: format });\n          }}\n        />\n        {query.resultFormat !== 'table' && (\n          <>\n            <InlineLabel width=\"auto\" className={styles.inlineLabel}>\n              ALIAS\n            </InlineLabel>\n            <InputSection\n              isWide\n              placeholder=\"Naming pattern\"\n              value={query.alias}\n              onChange={(alias) => {\n                onAppliedChange({ ...query, alias });\n              }}\n            />\n          </>\n        )}\n      </SegmentSection>\n    </div>\n  );\n};\n\nfunction getStyles(theme: GrafanaTheme2) {\n  return {\n    inlineLabel: css`\n      color: ${theme.colors.primary.text};\n    `,\n  };\n}\n","import React, { PureComponent } from 'react';\n\nimport { InlineFormLabel, TextArea } from '@grafana/ui';\n\nimport InfluxDatasource from '../datasource';\n\nimport { FluxQueryEditor } from './FluxQueryEditor';\n\ninterface Props {\n  query: string; // before flux, it was always a string\n  onChange: (query?: string) => void;\n  datasource: InfluxDatasource;\n}\n\nexport default class VariableQueryEditor extends PureComponent<Props> {\n  onRefresh = () => {\n    // noop\n  };\n\n  render() {\n    let { query, datasource, onChange } = this.props;\n    if (datasource.isFlux) {\n      return (\n        <FluxQueryEditor\n          datasource={datasource}\n          query={{\n            refId: 'A',\n            query,\n          }}\n          onRunQuery={this.onRefresh}\n          onChange={(v) => onChange(v.query)}\n        />\n      );\n    }\n\n    return (\n      <div className=\"gf-form-inline\">\n        <InlineFormLabel width={10}>Query</InlineFormLabel>\n        <div className=\"gf-form-inline gf-form--grow\">\n          <TextArea\n            defaultValue={query || ''}\n            placeholder=\"metric name or tags query\"\n            rows={1}\n            className=\"gf-form-input\"\n            onBlur={(e) => onChange(e.currentTarget.value)}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n","import React, { useState } from 'react';\n\nimport { QueryEditorProps } from '@grafana/data';\nimport { InlineFormLabel, Input } from '@grafana/ui';\n\nimport { InfluxQuery, InfluxOptions } from '../types';\n\nimport InfluxDatasource from './../datasource';\n\nexport const AnnotationEditor = (props: QueryEditorProps<InfluxDatasource, InfluxQuery, InfluxOptions>) => {\n  const { query, onChange } = props;\n  const [eventQuery, setEventQuery] = useState<string>(query.query ?? '');\n\n  const [textColumn, setTextColumn] = useState<string>(query.textColumn ?? '');\n  const [tagsColumn, setTagsColumn] = useState<string>(query.tagsColumn ?? '');\n  const [timeEndColumn, setTimeEndColumn] = useState<string>(query?.timeEndColumn ?? '');\n  const [titleColumn] = useState<string>(query?.titleColumn ?? '');\n  const updateValue = <K extends keyof InfluxQuery, V extends InfluxQuery[K]>(key: K, val: V) => {\n    onChange({\n      ...query,\n      [key]: val,\n      fromAnnotations: true,\n      textEditor: true,\n    });\n  };\n  return (\n    <div className=\"gf-form-group\">\n      <div className=\"gf-form\">\n        <InlineFormLabel width={12}>InfluxQL Query</InlineFormLabel>\n        <Input\n          value={eventQuery}\n          onChange={(e) => setEventQuery(e.currentTarget.value ?? '')}\n          onBlur={() => updateValue('query', eventQuery)}\n          placeholder=\"select text from events where $timeFilter limit 1000\"\n        />\n      </div>\n      <InlineFormLabel\n        width={12}\n        tooltip={\n          <div>\n            If your influxdb query returns more than one field you need to specify the column names below. An annotation\n            event is composed of a title, tags, and an additional text field. Optionally you can map the timeEnd column\n            for region annotation usage.\n          </div>\n        }\n      >\n        Field mappings\n      </InlineFormLabel>\n      <div className=\"gf-form-group\">\n        <div className=\"gf-form-inline\">\n          <div className=\"gf-form\">\n            <InlineFormLabel width={12}>Text</InlineFormLabel>\n            <Input\n              value={textColumn}\n              onChange={(e) => setTextColumn(e.currentTarget.value ?? '')}\n              onBlur={() => updateValue('textColumn', textColumn)}\n            />\n          </div>\n          <div className=\"gf-form\">\n            <InlineFormLabel width={12}>Tags</InlineFormLabel>\n            <Input\n              value={tagsColumn}\n              onChange={(e) => setTagsColumn(e.currentTarget.value ?? '')}\n              onBlur={() => updateValue('tagsColumn', tagsColumn)}\n            />\n          </div>\n          <div className=\"gf-form\">\n            <InlineFormLabel width={12}>TimeEnd</InlineFormLabel>\n            <Input\n              value={timeEndColumn}\n              onChange={(e) => setTimeEndColumn(e.currentTarget.value ?? '')}\n              onBlur={() => updateValue('timeEndColumn', timeEndColumn)}\n            />\n          </div>\n          <div className=\"gf-form ng-hide\">\n            <InlineFormLabel width={12}>Title</InlineFormLabel>\n            <Input defaultValue={titleColumn} />\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n","import { each, map, includes, flatten, keys } from 'lodash';\n\nimport { FieldType, QueryResultMeta, TimeSeries, TableData } from '@grafana/data';\nimport TableModel from 'app/core/TableModel';\n\nexport default class InfluxSeries {\n  refId?: string;\n  series: any;\n  alias: any;\n  annotation: any;\n  meta?: QueryResultMeta;\n\n  constructor(options: { series: any; alias?: any; annotation?: any; meta?: QueryResultMeta; refId?: string }) {\n    this.series = options.series;\n    this.alias = options.alias;\n    this.annotation = options.annotation;\n    this.meta = options.meta;\n    this.refId = options.refId;\n  }\n\n  getTimeSeries(): TimeSeries[] {\n    const output: TimeSeries[] = [];\n    let i, j;\n\n    if (this.series.length === 0) {\n      return output;\n    }\n\n    each(this.series, (series) => {\n      const columns = series.columns.length;\n      const tags = map(series.tags, (value, key) => {\n        return key + ': ' + value;\n      });\n\n      for (j = 1; j < columns; j++) {\n        let seriesName = series.name;\n        const columnName = series.columns[j];\n        if (columnName !== 'value') {\n          seriesName = seriesName + '.' + columnName;\n        }\n\n        if (this.alias) {\n          seriesName = this._getSeriesName(series, j);\n        } else if (series.tags) {\n          seriesName = seriesName + ' {' + tags.join(', ') + '}';\n        }\n\n        const datapoints = [];\n        if (series.values) {\n          for (i = 0; i < series.values.length; i++) {\n            datapoints[i] = [series.values[i][j], series.values[i][0]];\n          }\n        }\n\n        output.push({\n          title: seriesName,\n          target: seriesName,\n          datapoints: datapoints,\n          tags: series.tags,\n          meta: this.meta,\n          refId: this.refId,\n        });\n      }\n    });\n\n    return output;\n  }\n\n  _getSeriesName(series: any, index: number) {\n    const regex = /\\$(\\w+)|\\[\\[([\\s\\S]+?)\\]\\]/g;\n    const segments = series.name.split('.');\n\n    return this.alias.replace(regex, (match: any, g1: any, g2: any) => {\n      const group = g1 || g2;\n      const segIndex = parseInt(group, 10);\n\n      if (group === 'm' || group === 'measurement') {\n        return series.name;\n      }\n      if (group === 'col') {\n        return series.columns[index];\n      }\n      if (!isNaN(segIndex)) {\n        return segments[segIndex] ?? match;\n      }\n      if (group.indexOf('tag_') !== 0) {\n        return match;\n      }\n\n      const tag = group.replace('tag_', '');\n      if (!series.tags) {\n        return match;\n      }\n      return series.tags[tag];\n    });\n  }\n\n  getAnnotations() {\n    const list: any[] = [];\n\n    each(this.series, (series) => {\n      let titleCol: any = null;\n      let timeCol: any = null;\n      let timeEndCol: any = null;\n      const tagsCol: any = [];\n      let textCol: any = null;\n\n      each(series.columns, (column, index) => {\n        if (column === 'time') {\n          timeCol = index;\n          return;\n        }\n        if (column === 'sequence_number') {\n          return;\n        }\n        if (column === this.annotation.titleColumn) {\n          titleCol = index;\n          return;\n        }\n        if (includes((this.annotation.tagsColumn || '').replace(' ', '').split(','), column)) {\n          tagsCol.push(index);\n          return;\n        }\n        if (column === this.annotation.textColumn) {\n          textCol = index;\n          return;\n        }\n        if (column === this.annotation.timeEndColumn) {\n          timeEndCol = index;\n          return;\n        }\n        // legacy case\n        if (!titleCol && textCol !== index) {\n          titleCol = index;\n        }\n      });\n\n      each(series.values, (value) => {\n        const data = {\n          annotation: this.annotation,\n          time: +new Date(value[timeCol]),\n          title: value[titleCol],\n          timeEnd: value[timeEndCol],\n          // Remove empty values, then split in different tags for comma separated values\n          tags: flatten(\n            tagsCol\n              .filter((t: any) => {\n                return value[t];\n              })\n              .map((t: any) => {\n                return value[t].split(',');\n              })\n          ),\n          text: value[textCol],\n        };\n\n        list.push(data);\n      });\n    });\n\n    return list;\n  }\n\n  getTable(): TableData {\n    const table = new TableModel();\n    let i, j;\n\n    table.refId = this.refId;\n    table.meta = this.meta;\n\n    if (this.series.length === 0) {\n      return table;\n    }\n\n    // the order is:\n    // - first the first item from the value-array (this is often (always?) the timestamp)\n    // - then all the tag-values\n    // - then the rest of the value-array\n    //\n    // we have to keep this order both in table.columns and table.rows\n\n    each(this.series, (series: any, seriesIndex: number) => {\n      if (seriesIndex === 0) {\n        const firstCol = series.columns[0];\n        // Check the first column's name, if it is `time`, we\n        // mark it as having the type time\n        const firstTableCol = firstCol === 'time' ? { text: 'Time', type: FieldType.time } : { text: firstCol };\n        table.columns.push(firstTableCol);\n        each(keys(series.tags), (key) => {\n          table.columns.push({ text: key });\n        });\n        for (j = 1; j < series.columns.length; j++) {\n          table.columns.push({ text: series.columns[j] });\n        }\n      }\n\n      if (series.values) {\n        for (i = 0; i < series.values.length; i++) {\n          const values = series.values[i];\n          const reordered = [values[0]];\n          if (series.tags) {\n            for (const key in series.tags) {\n              if (series.tags.hasOwnProperty(key)) {\n                reordered.push(series.tags[key]);\n              }\n            }\n          }\n          for (j = 1; j < values.length; j++) {\n            reordered.push(values[j]);\n          }\n          table.rows.push(reordered);\n        }\n      }\n    });\n\n    return table;\n  }\n}\n","import { InfluxQuery, InfluxQueryTag } from './types';\n\ntype LegacyAnnotation = {\n  query?: string;\n  queryType?: string;\n  fromAnnotations?: boolean;\n  tagsColumn?: string;\n  textColumn?: string;\n  timeEndColumn?: string;\n  titleColumn?: string;\n  name?: string;\n  target?: {\n    limit?: string | number | undefined;\n    matchAny?: boolean;\n    tags?: InfluxQueryTag[];\n    type?: string;\n  };\n};\n\n// this becomes the target in the migrated annotations\nconst migrateLegacyAnnotation = (json: LegacyAnnotation) => {\n  // eslint-ignore-next-line\n  const target: InfluxQuery = {\n    refId: '',\n    query: json.query ?? '',\n    queryType: 'tags',\n    fromAnnotations: true,\n    tagsColumn: json.tagsColumn ?? '',\n    textColumn: json.textColumn ?? '',\n    timeEndColumn: json.timeEndColumn ?? '',\n    titleColumn: json.titleColumn ?? '',\n    name: json.name ?? '',\n  };\n\n  // handle json target fields\n  if (json.target && json.target.limit) {\n    target.limit = json.target.limit;\n  }\n\n  if (json.target && json.target.matchAny) {\n    target.matchAny = json.target.matchAny;\n  }\n\n  if (json.target && json.target.tags) {\n    target.tags = json.target.tags;\n  }\n\n  if (json.target && json.target.type) {\n    target.type = json.target.type;\n  }\n\n  return target;\n};\n\n// eslint-ignore-next-line\nexport const prepareAnnotation = (json: any) => {\n  // make sure that any additional target fields are migrated\n  json.target = json.target && !json.target?.query ? migrateLegacyAnnotation(json) : json.target;\n\n  return json;\n};\n","import { each, flatten, groupBy, isArray } from 'lodash';\n\nimport { AnnotationEvent, DataFrame, DataQuery, FieldType, QueryResultMeta } from '@grafana/data';\nimport { toDataQueryResponse } from '@grafana/runtime';\nimport TableModel from 'app/core/TableModel';\n\nimport { InfluxQuery } from './types';\n\nexport default class ResponseParser {\n  parse(query: string, results: { results: any }) {\n    if (!results?.results || results.results.length === 0) {\n      return [];\n    }\n\n    const influxResults = results.results[0];\n    if (!influxResults.series) {\n      return [];\n    }\n\n    const normalizedQuery = query.toLowerCase();\n    const isValueFirst =\n      normalizedQuery.indexOf('show field keys') >= 0 || normalizedQuery.indexOf('show retention policies') >= 0;\n\n    const res = new Set<string>();\n    each(influxResults.series, (serie) => {\n      each(serie.values, (value) => {\n        if (isArray(value)) {\n          // In general, there are 2 possible shapes for the returned value.\n          // The first one is a two-element array,\n          // where the first element is somewhat a metadata value:\n          // the tag name for SHOW TAG VALUES queries,\n          // the time field for SELECT queries, etc.\n          // The second shape is an one-element array,\n          // that is containing an immediate value.\n          // For example, SHOW FIELD KEYS queries return such shape.\n          // Note, pre-0.11 versions return\n          // the second shape for SHOW TAG VALUES queries\n          // (while the newer versionsfirst).\n\n          if (isValueFirst) {\n            addUnique(res, value[0]);\n          } else if (value[1] !== undefined) {\n            addUnique(res, value[1]);\n          } else {\n            addUnique(res, value[0]);\n          }\n        } else {\n          addUnique(res, value);\n        }\n      });\n    });\n\n    // NOTE: it is important to keep the order of items in the parsed output\n    // the same as it was in the influxdb-response.\n    // we use a `Set` to collect the unique-results, and `Set` iteration\n    // order is insertion-order, so this should be ok.\n    return Array.from(res).map((v) => ({ text: v }));\n  }\n\n  getTable(dfs: DataFrame[], target: InfluxQuery, meta: QueryResultMeta): TableModel {\n    let table = new TableModel();\n\n    if (dfs.length > 0) {\n      table.meta = {\n        ...meta,\n        executedQueryString: dfs[0].meta?.executedQueryString,\n      };\n\n      table.refId = target.refId;\n      table = getTableCols(dfs, table, target);\n\n      // if group by tag(s) added\n      if (dfs[0].fields[1] && dfs[0].fields[1].labels) {\n        let dfsByLabels: any = groupBy(dfs, (df: DataFrame) =>\n          df.fields[1].labels ? Object.values(df.fields[1].labels!) : null\n        );\n        const labels = Object.keys(dfsByLabels);\n        dfsByLabels = Object.values(dfsByLabels);\n\n        for (let i = 0; i < dfsByLabels.length; i++) {\n          table = getTableRows(dfsByLabels[i], table, [...labels[i].split(',')]);\n        }\n      } else {\n        table = getTableRows(dfs, table, []);\n      }\n    }\n\n    return table;\n  }\n\n  async transformAnnotationResponse(annotation: any, data: any, target: InfluxQuery): Promise<AnnotationEvent[]> {\n    const rsp = toDataQueryResponse(data, [target] as DataQuery[]);\n\n    if (rsp) {\n      const table = this.getTable(rsp.data, target, {});\n      const list: any[] = [];\n      let titleCol: any = null;\n      let timeCol: any = null;\n      let timeEndCol: any = null;\n      const tagsCol: any = [];\n      let textCol: any = null;\n\n      each(table.columns, (column, index) => {\n        if (column.text.toLowerCase() === 'time') {\n          timeCol = index;\n          return;\n        }\n        if (column.text === annotation.titleColumn) {\n          titleCol = index;\n          return;\n        }\n        if (colContainsTag(column.text, annotation.tagsColumn)) {\n          tagsCol.push(index);\n          return;\n        }\n        if (column.text.includes(annotation.textColumn)) {\n          textCol = index;\n          return;\n        }\n        if (column.text === annotation.timeEndColumn) {\n          timeEndCol = index;\n          return;\n        }\n        // legacy case\n        if (!titleCol && textCol !== index) {\n          titleCol = index;\n        }\n      });\n\n      each(table.rows, (value) => {\n        const data = {\n          annotation: annotation,\n          time: +new Date(value[timeCol]),\n          title: value[titleCol],\n          timeEnd: value[timeEndCol],\n          // Remove empty values, then split in different tags for comma separated values\n          tags: flatten(\n            tagsCol\n              .filter((t: any) => {\n                return value[t];\n              })\n              .map((t: any) => {\n                return value[t].split(',');\n              })\n          ),\n          text: value[textCol],\n        };\n\n        list.push(data);\n      });\n\n      return list;\n    }\n    return [];\n  }\n}\n\nfunction colContainsTag(colText: string, tagsColumn: string): boolean {\n  const tags = (tagsColumn || '').replace(' ', '').split(',');\n  for (const tag of tags) {\n    if (tag !== '' && colText.includes(tag)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction getTableCols(dfs: DataFrame[], table: TableModel, target: InfluxQuery): TableModel {\n  const selectedParams = getSelectedParams(target);\n\n  dfs[0].fields.forEach((field) => {\n    // Time col\n    if (field.name === 'time') {\n      table.columns.push({ text: 'Time', type: FieldType.time });\n    }\n\n    // Group by (label) column(s)\n    else if (field.name === 'value') {\n      if (field.labels) {\n        Object.keys(field.labels).forEach((key) => {\n          table.columns.push({ text: key });\n        });\n      }\n    }\n  });\n\n  // Get cols for annotationQuery\n  if (dfs[0].refId === 'metricFindQuery') {\n    dfs.forEach((field) => {\n      if (field.name) {\n        table.columns.push({ text: field.name });\n      }\n    });\n  }\n\n  // Select (metric) column(s)\n  for (let i = 0; i < selectedParams.length; i++) {\n    table.columns.push({ text: selectedParams[i] });\n  }\n\n  return table;\n}\n\nfunction getTableRows(dfs: DataFrame[], table: TableModel, labels: string[]): TableModel {\n  const values = dfs[0].fields[0].values.toArray();\n\n  for (let i = 0; i < values.length; i++) {\n    const time = values[i];\n    const metrics = dfs.map((df: DataFrame) => {\n      return df.fields[1] ? df.fields[1].values.toArray()[i] : null;\n    });\n    if (metrics.indexOf(null) < 0) {\n      table.rows.push([time, ...labels, ...metrics]);\n    }\n  }\n  return table;\n}\n\nexport function getSelectedParams(target: InfluxQuery): string[] {\n  let allParams: string[] = [];\n  target.select?.forEach((select) => {\n    const selector = select.filter((x) => x.type !== 'field');\n    if (selector.length > 0) {\n      allParams.push(selector[0].type);\n    } else {\n      if (select[0] && select[0].params && select[0].params[0]) {\n        allParams.push(select[0].params[0].toString());\n      }\n    }\n  });\n\n  let uniqueParams: string[] = [];\n  allParams.forEach((param) => {\n    uniqueParams.push(incrementName(param, param, uniqueParams, 0));\n  });\n\n  return uniqueParams;\n}\n\nfunction incrementName(name: string, nameIncremenet: string, params: string[], index: number): string {\n  if (params.indexOf(nameIncremenet) > -1) {\n    index++;\n    return incrementName(name, name + '_' + index, params, index);\n  }\n  return nameIncremenet;\n}\n\nfunction addUnique(s: Set<string>, value: string | number) {\n  s.add(value.toString());\n}\n","import { cloneDeep, extend, groupBy, has, isString, map as _map, omit, pick, reduce } from 'lodash';\nimport { lastValueFrom, merge, Observable, of, throwError } from 'rxjs';\nimport { catchError, map } from 'rxjs/operators';\n\nimport {\n  AnnotationEvent,\n  ArrayVector,\n  DataFrame,\n  DataQueryError,\n  DataQueryRequest,\n  DataQueryResponse,\n  DataSourceInstanceSettings,\n  dateMath,\n  FieldType,\n  MetricFindValue,\n  QueryResultMeta,\n  ScopedVars,\n  TIME_SERIES_TIME_FIELD_NAME,\n  TIME_SERIES_VALUE_FIELD_NAME,\n  TimeSeries,\n  toDataFrame,\n} from '@grafana/data';\nimport {\n  BackendDataSourceResponse,\n  DataSourceWithBackend,\n  FetchResponse,\n  frameToMetricFindValue,\n  getBackendSrv,\n} from '@grafana/runtime';\nimport config from 'app/core/config';\nimport { getTemplateSrv, TemplateSrv } from 'app/features/templating/template_srv';\n\nimport { AnnotationEditor } from './components/AnnotationEditor';\nimport { FluxQueryEditor } from './components/FluxQueryEditor';\nimport { BROWSER_MODE_DISABLED_MESSAGE } from './constants';\nimport InfluxQueryModel from './influx_query_model';\nimport InfluxSeries from './influx_series';\nimport { prepareAnnotation } from './migrations';\nimport { buildRawQuery } from './queryUtils';\nimport { InfluxQueryBuilder } from './query_builder';\nimport ResponseParser from './response_parser';\nimport { InfluxOptions, InfluxQuery, InfluxVersion } from './types';\n\n// we detect the field type based on the value-array\nfunction getFieldType(values: unknown[]): FieldType {\n  // the values-array may contain a lot of nulls.\n  // we need the first not-null item\n  const firstNotNull = values.find((v) => v !== null);\n\n  if (firstNotNull === undefined) {\n    // we could not find any not-null values\n    return FieldType.number;\n  }\n\n  const valueType = typeof firstNotNull;\n\n  switch (valueType) {\n    case 'string':\n      return FieldType.string;\n    case 'boolean':\n      return FieldType.boolean;\n    case 'number':\n      return FieldType.number;\n    default:\n      // this should never happen, influxql values\n      // can only be numbers, strings and booleans.\n      throw new Error(`InfluxQL: invalid value type ${valueType}`);\n  }\n}\n\n// this conversion function is specialized to work with the timeseries\n// data returned by InfluxDatasource.getTimeSeries()\nfunction timeSeriesToDataFrame(timeSeries: TimeSeries): DataFrame {\n  const times: number[] = [];\n  const values: unknown[] = [];\n\n  // the data we process here is not correctly typed.\n  // the typescript types say every data-point is number|null,\n  // but in fact it can be string or boolean too.\n\n  const points = timeSeries.datapoints;\n  for (const point of points) {\n    values.push(point[0]);\n    times.push(point[1] as number);\n  }\n\n  const timeField = {\n    name: TIME_SERIES_TIME_FIELD_NAME,\n    type: FieldType.time,\n    config: {},\n    values: new ArrayVector<number>(times),\n  };\n\n  const valueField = {\n    name: TIME_SERIES_VALUE_FIELD_NAME,\n    type: getFieldType(values),\n    config: {\n      displayNameFromDS: timeSeries.title,\n    },\n    values: new ArrayVector<unknown>(values),\n    labels: timeSeries.tags,\n  };\n\n  const fields = [timeField, valueField];\n\n  return {\n    name: timeSeries.target,\n    refId: timeSeries.refId,\n    meta: timeSeries.meta,\n    fields,\n    length: values.length,\n  };\n}\n\nexport default class InfluxDatasource extends DataSourceWithBackend<InfluxQuery, InfluxOptions> {\n  type: string;\n  urls: string[];\n  username: string;\n  password: string;\n  name: string;\n  database: any;\n  basicAuth: any;\n  withCredentials: any;\n  access: 'direct' | 'proxy';\n  interval: any;\n  responseParser: any;\n  httpMode: string;\n  isFlux: boolean;\n  isProxyAccess: boolean;\n\n  constructor(\n    instanceSettings: DataSourceInstanceSettings<InfluxOptions>,\n    private readonly templateSrv: TemplateSrv = getTemplateSrv()\n  ) {\n    super(instanceSettings);\n\n    this.type = 'influxdb';\n    this.urls = (instanceSettings.url ?? '').split(',').map((url) => {\n      return url.trim();\n    });\n\n    this.username = instanceSettings.username ?? '';\n    this.password = instanceSettings.password ?? '';\n    this.name = instanceSettings.name;\n    this.database = instanceSettings.database;\n    this.basicAuth = instanceSettings.basicAuth;\n    this.withCredentials = instanceSettings.withCredentials;\n    this.access = instanceSettings.access;\n    const settingsData = instanceSettings.jsonData || ({} as InfluxOptions);\n    this.interval = settingsData.timeInterval;\n    this.httpMode = settingsData.httpMode || 'GET';\n    this.responseParser = new ResponseParser();\n    this.isFlux = settingsData.version === InfluxVersion.Flux;\n    this.isProxyAccess = instanceSettings.access === 'proxy';\n\n    if (this.isFlux) {\n      // When flux, use an annotation processor rather than the `annotationQuery` lifecycle\n      this.annotations = {\n        QueryEditor: FluxQueryEditor,\n      };\n    } else {\n      this.annotations = {\n        QueryEditor: AnnotationEditor,\n        prepareAnnotation,\n      };\n    }\n  }\n\n  query(request: DataQueryRequest<InfluxQuery>): Observable<DataQueryResponse> {\n    if (!this.isProxyAccess) {\n      const error = new Error(BROWSER_MODE_DISABLED_MESSAGE);\n      return throwError(() => error);\n    }\n    // for not-flux queries we call `this.classicQuery`, and that\n    // handles the is-hidden situation.\n    // for the flux-case, we do the filtering here\n    const filteredRequest = {\n      ...request,\n      targets: request.targets.filter((t) => t.hide !== true),\n    };\n\n    if (this.isFlux) {\n      return super.query(filteredRequest);\n    }\n\n    if (this.isMigrationToggleOnAndIsAccessProxy()) {\n      return super.query(filteredRequest).pipe(\n        map((res) => {\n          if (res.error) {\n            throw {\n              message: 'InfluxDB Error: ' + res.error.message,\n              res,\n            };\n          }\n\n          const seriesList: any[] = [];\n\n          const groupedFrames = groupBy(res.data, (x) => x.refId);\n          if (Object.keys(groupedFrames).length > 0) {\n            filteredRequest.targets.forEach((target) => {\n              const filteredFrames = groupedFrames[target.refId] ?? [];\n              switch (target.resultFormat) {\n                case 'logs':\n                case 'table':\n                  seriesList.push(\n                    this.responseParser.getTable(filteredFrames, target, {\n                      preferredVisualisationType: target.resultFormat,\n                    })\n                  );\n                  break;\n                default: {\n                  for (let i = 0; i < filteredFrames.length; i++) {\n                    seriesList.push(filteredFrames[i]);\n                  }\n                  break;\n                }\n              }\n            });\n          }\n\n          return { data: seriesList };\n        })\n      );\n    }\n\n    // Fallback to classic query support\n    return this.classicQuery(request);\n  }\n\n  getQueryDisplayText(query: InfluxQuery) {\n    if (this.isFlux) {\n      return query.query;\n    }\n    return new InfluxQueryModel(query).render(false);\n  }\n\n  /**\n   * Returns false if the query should be skipped\n   */\n  filterQuery(query: InfluxQuery): boolean {\n    if (this.isFlux) {\n      return !!query.query;\n    }\n    return true;\n  }\n\n  applyTemplateVariables(query: InfluxQuery, scopedVars: ScopedVars): Record<string, any> {\n    // We want to interpolate these variables on backend\n    const { __interval, __interval_ms, ...rest } = scopedVars;\n\n    if (this.isFlux) {\n      return {\n        ...query,\n        query: this.templateSrv.replace(query.query ?? '', rest), // The raw query text\n      };\n    }\n\n    if (config.featureToggles.influxdbBackendMigration && this.access === 'proxy') {\n      query = this.applyVariables(query, scopedVars, rest);\n    }\n\n    return query;\n  }\n\n  /**\n   * The unchanged pre 7.1 query implementation\n   */\n  classicQuery(options: any): Observable<DataQueryResponse> {\n    // migrate annotations\n    if (options.targets.some((target: InfluxQuery) => target.fromAnnotations)) {\n      const streams: Array<Observable<DataQueryResponse>> = [];\n\n      for (const target of options.targets) {\n        if (target.query) {\n          streams.push(\n            new Observable((subscriber) => {\n              this.annotationEvents(options, target)\n                .then((events) => subscriber.next({ data: [toDataFrame(events)] }))\n                .catch((ex) => subscriber.error(new Error(ex)))\n                .finally(() => subscriber.complete());\n            })\n          );\n        }\n      }\n\n      return merge(...streams);\n    }\n\n    let timeFilter = this.getTimeFilter(options);\n    const scopedVars = options.scopedVars;\n    const targets = cloneDeep(options.targets);\n    const queryTargets: any[] = [];\n\n    let i, y;\n\n    let allQueries = _map(targets, (target) => {\n      if (target.hide) {\n        return '';\n      }\n\n      queryTargets.push(target);\n\n      // backward compatibility\n      scopedVars.interval = scopedVars.__interval;\n\n      return new InfluxQueryModel(target, this.templateSrv, scopedVars).render(true);\n    }).reduce((acc, current) => {\n      if (current !== '') {\n        acc += ';' + current;\n      }\n      return acc;\n    });\n\n    if (allQueries === '') {\n      return of({ data: [] });\n    }\n\n    // add global adhoc filters to timeFilter\n    const adhocFilters = this.templateSrv.getAdhocFilters(this.name);\n    const adhocFiltersFromDashboard = options.targets.flatMap((target: InfluxQuery) => target.adhocFilters ?? []);\n    if (adhocFilters?.length || adhocFiltersFromDashboard?.length) {\n      const ahFilters = adhocFilters?.length ? adhocFilters : adhocFiltersFromDashboard;\n      const tmpQuery = new InfluxQueryModel({ refId: 'A' }, this.templateSrv, scopedVars);\n      timeFilter += ' AND ' + tmpQuery.renderAdhocFilters(ahFilters);\n    }\n    // replace grafana variables\n    scopedVars.timeFilter = { value: timeFilter };\n\n    // replace templated variables\n    allQueries = this.templateSrv.replace(allQueries, scopedVars);\n\n    return this._seriesQuery(allQueries, options).pipe(\n      map((data: any) => {\n        if (!data || !data.results) {\n          return { data: [] };\n        }\n\n        const seriesList = [];\n        for (i = 0; i < data.results.length; i++) {\n          const result = data.results[i];\n          if (!result || !result.series) {\n            continue;\n          }\n\n          const target = queryTargets[i];\n          let alias = target.alias;\n          if (alias) {\n            alias = this.templateSrv.replace(target.alias, options.scopedVars);\n          }\n\n          const meta: QueryResultMeta = {\n            executedQueryString: data.executedQueryString,\n          };\n\n          const influxSeries = new InfluxSeries({\n            refId: target.refId,\n            series: data.results[i].series,\n            alias: alias,\n            meta,\n          });\n\n          switch (target.resultFormat) {\n            case 'logs':\n              meta.preferredVisualisationType = 'logs';\n            case 'table': {\n              seriesList.push(influxSeries.getTable());\n              break;\n            }\n            default: {\n              const timeSeries = influxSeries.getTimeSeries();\n              for (y = 0; y < timeSeries.length; y++) {\n                seriesList.push(timeSeriesToDataFrame(timeSeries[y]));\n              }\n              break;\n            }\n          }\n        }\n\n        return { data: seriesList };\n      })\n    );\n  }\n\n  async annotationEvents(options: DataQueryRequest, annotation: InfluxQuery): Promise<AnnotationEvent[]> {\n    if (this.isFlux) {\n      return Promise.reject({\n        message: 'Flux requires the standard annotation query',\n      });\n    }\n\n    // InfluxQL puts a query string on the annotation\n    if (!annotation.query) {\n      return Promise.reject({\n        message: 'Query missing in annotation definition',\n      });\n    }\n\n    if (config.featureToggles.influxdbBackendMigration && this.access === 'proxy') {\n      // We want to send our query to the backend as a raw query\n      const target: InfluxQuery = {\n        refId: 'metricFindQuery',\n        datasource: this.getRef(),\n        query: this.templateSrv.replace(annotation.query, undefined, 'regex'),\n        rawQuery: true,\n      };\n\n      return lastValueFrom(\n        getBackendSrv()\n          .fetch<BackendDataSourceResponse>({\n            url: '/api/ds/query',\n            method: 'POST',\n            headers: this.getRequestHeaders(),\n            data: {\n              from: options.range.from.valueOf().toString(),\n              to: options.range.to.valueOf().toString(),\n              queries: [target],\n            },\n            requestId: annotation.name,\n          })\n          .pipe(\n            map(\n              async (res: FetchResponse<BackendDataSourceResponse>) =>\n                await this.responseParser.transformAnnotationResponse(annotation, res, target)\n            )\n          )\n      );\n    }\n\n    const timeFilter = this.getTimeFilter({ rangeRaw: options.range.raw, timezone: options.timezone });\n    let query = annotation.query.replace('$timeFilter', timeFilter);\n    query = this.templateSrv.replace(query, undefined, 'regex');\n\n    return lastValueFrom(this._seriesQuery(query, options)).then((data: any) => {\n      if (!data || !data.results || !data.results[0]) {\n        throw { message: 'No results in response from InfluxDB' };\n      }\n      return new InfluxSeries({\n        series: data.results[0].series,\n        annotation: annotation,\n      }).getAnnotations();\n    });\n  }\n\n  targetContainsTemplate(target: any) {\n    // for flux-mode we just take target.query,\n    // for influxql-mode we use InfluxQueryModel to create the text-representation\n    const queryText = this.isFlux ? target.query : buildRawQuery(target);\n\n    return this.templateSrv.containsTemplate(queryText);\n  }\n\n  interpolateVariablesInQueries(queries: InfluxQuery[], scopedVars: ScopedVars): InfluxQuery[] {\n    if (!queries || queries.length === 0) {\n      return [];\n    }\n\n    return queries.map((query) => {\n      if (this.isFlux) {\n        return {\n          ...query,\n          datasource: this.getRef(),\n          query: this.templateSrv.replace(query.query ?? '', scopedVars, 'regex'), // The raw query text\n        };\n      }\n\n      return {\n        ...query,\n        datasource: this.getRef(),\n        ...this.applyVariables(query, scopedVars, scopedVars),\n      };\n    });\n  }\n\n  applyVariables(query: InfluxQuery, scopedVars: ScopedVars, rest: ScopedVars) {\n    const expandedQuery = { ...query };\n    if (query.groupBy) {\n      expandedQuery.groupBy = query.groupBy.map((groupBy) => {\n        return {\n          ...groupBy,\n          params: groupBy.params?.map((param) => {\n            return this.templateSrv.replace(param.toString(), undefined, 'regex');\n          }),\n        };\n      });\n    }\n\n    if (query.select) {\n      expandedQuery.select = query.select.map((selects) => {\n        return selects.map((select: any) => {\n          return {\n            ...select,\n            params: select.params?.map((param: any) => {\n              return this.templateSrv.replace(param.toString(), undefined, 'regex');\n            }),\n          };\n        });\n      });\n    }\n\n    if (query.tags) {\n      expandedQuery.tags = query.tags.map((tag) => {\n        return {\n          ...tag,\n          value: this.templateSrv.replace(tag.value, scopedVars, 'regex'),\n        };\n      });\n    }\n\n    return {\n      ...expandedQuery,\n      adhocFilters: this.templateSrv.getAdhocFilters(this.name) ?? [],\n      query: this.templateSrv.replace(query.query ?? '', rest, 'regex'), // The raw query text\n      alias: this.templateSrv.replace(query.alias ?? '', scopedVars),\n      limit: this.templateSrv.replace(query.limit?.toString() ?? '', scopedVars, 'regex'),\n      measurement: this.templateSrv.replace(query.measurement ?? '', scopedVars, 'regex'),\n      policy: this.templateSrv.replace(query.policy ?? '', scopedVars, 'regex'),\n      slimit: this.templateSrv.replace(query.slimit?.toString() ?? '', scopedVars, 'regex'),\n      tz: this.templateSrv.replace(query.tz ?? '', scopedVars),\n    };\n  }\n\n  async metricFindQuery(query: string, options?: any): Promise<MetricFindValue[]> {\n    if (this.isFlux || this.isMigrationToggleOnAndIsAccessProxy()) {\n      const target: InfluxQuery = {\n        refId: 'metricFindQuery',\n        query,\n        rawQuery: true,\n      };\n      return lastValueFrom(\n        super.query({\n          ...options, // includes 'range'\n          targets: [target],\n        } as DataQueryRequest)\n      ).then((rsp) => {\n        if (rsp.data?.length) {\n          return frameToMetricFindValue(rsp.data[0]);\n        }\n        return [];\n      });\n    }\n\n    const interpolated = this.templateSrv.replace(query, undefined, 'regex');\n\n    return lastValueFrom(this._seriesQuery(interpolated, options)).then((resp) => {\n      return this.responseParser.parse(query, resp);\n    });\n  }\n\n  getTagKeys(options: any = {}) {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_KEYS');\n    return this.metricFindQuery(query, options);\n  }\n\n  getTagValues(options: any = {}) {\n    const queryBuilder = new InfluxQueryBuilder({ measurement: options.measurement || '', tags: [] }, this.database);\n    const query = queryBuilder.buildExploreQuery('TAG_VALUES', options.key);\n    return this.metricFindQuery(query, options);\n  }\n\n  _seriesQuery(query: string, options?: any) {\n    if (!query) {\n      return of({ results: [] });\n    }\n\n    if (options && options.range) {\n      const timeFilter = this.getTimeFilter({ rangeRaw: options.range, timezone: options.timezone });\n      query = query.replace('$timeFilter', timeFilter);\n    }\n\n    return this._influxRequest(this.httpMode, '/query', { q: query, epoch: 'ms' }, options);\n  }\n\n  serializeParams(params: any) {\n    if (!params) {\n      return '';\n    }\n\n    return reduce(\n      params,\n      (memo, value, key) => {\n        if (value === null || value === undefined) {\n          return memo;\n        }\n        memo.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));\n        return memo;\n      },\n      [] as string[]\n    ).join('&');\n  }\n\n  _influxRequest(method: string, url: string, data: any, options?: any) {\n    const currentUrl = this.urls.shift()!;\n    this.urls.push(currentUrl);\n\n    const params: any = {};\n\n    if (this.username) {\n      params.u = this.username;\n      params.p = this.password;\n    }\n\n    if (options && options.database) {\n      params.db = options.database;\n    } else if (this.database) {\n      params.db = this.database;\n    }\n\n    const { q } = data;\n\n    if (method === 'POST' && has(data, 'q')) {\n      // verb is POST and 'q' param is defined\n      extend(params, omit(data, ['q']));\n      data = this.serializeParams(pick(data, ['q']));\n    } else if (method === 'GET' || method === 'POST') {\n      // verb is GET, or POST without 'q' param\n      extend(params, data);\n      data = null;\n    }\n\n    const req: any = {\n      method: method,\n      url: currentUrl + url,\n      params: params,\n      data: data,\n      precision: 'ms',\n      inspect: { type: 'influxdb' },\n      paramSerializer: this.serializeParams,\n    };\n\n    req.headers = req.headers || {};\n    if (this.basicAuth || this.withCredentials) {\n      req.withCredentials = true;\n    }\n    if (this.basicAuth) {\n      req.headers.Authorization = this.basicAuth;\n    }\n\n    if (method === 'POST') {\n      req.headers['Content-type'] = 'application/x-www-form-urlencoded';\n    }\n\n    return getBackendSrv()\n      .fetch(req)\n      .pipe(\n        map((result: any) => {\n          const { data } = result;\n          if (data) {\n            data.executedQueryString = q;\n            if (data.results) {\n              const errors = result.data.results.filter((elem: any) => elem.error);\n\n              if (errors.length > 0) {\n                throw {\n                  message: 'InfluxDB Error: ' + errors[0].error,\n                  data,\n                };\n              }\n            }\n          }\n          return data;\n        }),\n        catchError((err) => {\n          if (err.cancelled) {\n            return of(err);\n          }\n\n          return throwError(this.handleErrors(err));\n        })\n      );\n  }\n\n  handleErrors(err: any) {\n    const error: DataQueryError = {\n      message:\n        (err && err.status) ||\n        (err && err.message) ||\n        'Unknown error during query transaction. Please check JS console logs.',\n    };\n\n    if ((Number.isInteger(err.status) && err.status !== 0) || err.status >= 300) {\n      if (err.data && err.data.error) {\n        error.message = 'InfluxDB Error: ' + err.data.error;\n        error.data = err.data;\n        // @ts-ignore\n        error.config = err.config;\n      } else {\n        error.message = 'Network Error: ' + err.statusText + '(' + err.status + ')';\n        error.data = err.data;\n        // @ts-ignore\n        error.config = err.config;\n      }\n    }\n\n    return error;\n  }\n\n  getTimeFilter(options: any) {\n    const from = this.getInfluxTime(options.rangeRaw.from, false, options.timezone);\n    const until = this.getInfluxTime(options.rangeRaw.to, true, options.timezone);\n\n    return 'time >= ' + from + ' and time <= ' + until;\n  }\n\n  getInfluxTime(date: any, roundUp: any, timezone: any) {\n    if (isString(date)) {\n      if (date === 'now') {\n        return 'now()';\n      }\n\n      const parts = /^now-(\\d+)([dhms])$/.exec(date);\n      if (parts) {\n        const amount = parseInt(parts[1], 10);\n        const unit = parts[2];\n        return 'now() - ' + amount + unit;\n      }\n      date = dateMath.parse(date, roundUp, timezone);\n    }\n\n    return date.valueOf() + 'ms';\n  }\n\n  isMigrationToggleOnAndIsAccessProxy() {\n    return config.featureToggles.influxdbBackendMigration && this.access === 'proxy';\n  }\n}\n","import { DataSourcePlugin } from '@grafana/data';\n\nimport ConfigEditor from './components/ConfigEditor';\nimport InfluxStartPage from './components/InfluxStartPage';\nimport { QueryEditor } from './components/QueryEditor';\nimport VariableQueryEditor from './components/VariableQueryEditor';\nimport InfluxDatasource from './datasource';\n\nexport const plugin = new DataSourcePlugin(InfluxDatasource)\n  .setConfigEditor(ConfigEditor)\n  .setQueryEditor(QueryEditor)\n  .setVariableQueryEditor(VariableQueryEditor)\n  .setQueryEditorHelp(InfluxStartPage);\n","import { css } from '@emotion/css';\nimport React from 'react';\n\nimport { QueryEditorProps } from '@grafana/data';\n\nimport InfluxDatasource from '../datasource';\nimport { buildRawQuery } from '../queryUtils';\nimport { InfluxOptions, InfluxQuery } from '../types';\n\nimport { FluxQueryEditor } from './FluxQueryEditor';\nimport { QueryEditorModeSwitcher } from './QueryEditorModeSwitcher';\nimport { RawInfluxQLEditor } from './RawInfluxQLEditor';\nimport { Editor as VisualInfluxQLEditor } from './VisualInfluxQLEditor/Editor';\n\ntype Props = QueryEditorProps<InfluxDatasource, InfluxQuery, InfluxOptions>;\n\nexport const QueryEditor = ({ query, onChange, onRunQuery, datasource, range, data }: Props): JSX.Element => {\n  if (datasource.isFlux) {\n    return (\n      <div className=\"gf-form-query-content\">\n        <FluxQueryEditor query={query} onChange={onChange} onRunQuery={onRunQuery} datasource={datasource} />\n      </div>\n    );\n  }\n\n  return (\n    <div className={css({ display: 'flex' })}>\n      <div className={css({ flexGrow: 1 })}>\n        {query.rawQuery ? (\n          <RawInfluxQLEditor query={query} onChange={onChange} onRunQuery={onRunQuery} />\n        ) : (\n          <VisualInfluxQLEditor query={query} onChange={onChange} onRunQuery={onRunQuery} datasource={datasource} />\n        )}\n      </div>\n      <QueryEditorModeSwitcher\n        isRaw={query.rawQuery ?? false}\n        onChange={(value) => {\n          onChange({ ...query, query: buildRawQuery(query), rawQuery: value });\n          onRunQuery();\n        }}\n      />\n    </div>\n  );\n};\n"],"names":["BROWSER_MODE_DISABLED_MESSAGE","InfluxVersion","Input","SecretFormField","LegacyForms","httpModes","label","value","versions","InfluxQL","description","Flux","ConfigEditor","PureComponent","constructor","props","super","maxSeries","updateDatasourcePluginResetOption","this","selected","options","onOptionsChange","copy","jsonData","version","access","basicAuth","httpMode","user","database","state","toString","htmlPrefix","uniqueId","renderInflux2x","secureJsonFields","secureJsonData","className","htmlFor","id","organization","onChange","onUpdateDatasourceJsonDataOption","isConfigured","Boolean","token","labelWidth","inputWidth","onReset","onResetToken","onUpdateDatasourceSecureJsonDataOption","placeholder","defaultBucket","tooltip","timeInterval","renderInflux1x","InfoBox","onUpdateDatasourceOption","password","onResetPassword","Select","inputId","find","defaultValue","onUpdateDatasourceJsonDataOptionSelect","render","isDirectAccess","onVersionChanged","href","Alert","title","severity","DataSourceHttpSettings","showAccessOptions","dataSourceConfig","defaultUrl","InlineField","type","event","setState","currentTarget","val","parseInt","updateDatasourcePluginJsonDataOption","Number","isFinite","undefined","CHEAT_SHEET_ITEMS","map","item","InfluxStartPage","onClickExample","index","categories","Aggregations","Selectors","Transformations","Predictors","Math","Aliasing","Fields","createPart","part","def","message","QueryPart","register","QueryPartDef","category","push","groupByTimeFunctions","fieldRenderer","innerExpr","params","replaceAggregationAddStrategy","selectParts","partModel","i","length","morePartsAvailable","splice","addTransformationStrategy","addStrategy","query","parts","clone","selectModels","dynamicLookup","defaultParams","renderer","functionRenderer","name","partCount","suffixRenderer","quote","renderMode","create","getCategories","replaceAggregationAdd","InfluxQueryModel","target","templateSrv","scopedVars","policy","resultFormat","orderByTime","tags","groupBy","select","updateProjection","queryPart","groupByParts","updatePersistedParts","hasGroupByTime","g","hasFill","addGroupBy","stringParts","match","typePart","arg","removeGroupByPart","filter","s","removeSelect","removeSelectPart","modelsIndex","indexOf","partIndex","addSelectPart","renderTagCondition","tag","interpolate","str","operator","condition","test","replace","key","getMeasurementAndPolicy","measurement","interpolateQueryStr","variable","defaultFormatFn","multi","includeAll","kbn","join","rawQuery","y","selectText","conditions","groupBySection","fill","limit","slimit","tz","renderAdhocFilters","filters","buildRawQuery","queryCopy","cloneDeep","samples","UnthemedFluxQueryEditor","onRunQuery","forceUpdate","sugs","kind","CodeEditorSuggestionItemKind","detail","getTemplateSrv","getVariables","forEach","editor","setTimeout","layout","theme","styles","getStyles","helpTooltip","CodeEditor","height","containerStyles","editorContainerStyles","language","onBlur","onFluxQueryChange","onSave","showMiniMap","showLineNumbers","getSuggestions","onEditorDidMount","editorDidMountCallbackHack","cx","editorActions","icon","variant","Segment","onSampleChange","width","css","isDark","colors","background","canvas","primary","spacing","FluxQueryEditor","withTheme2","QueryEditorModeSwitcher","isRaw","isModalOpen","setModalOpen","useState","useEffect","Button","onClick","ConfirmModal","isOpen","body","confirmText","dismissText","onConfirm","onDismiss","RESULT_FORMATS","DEFAULT_RESULT_FORMAT","useShadowedState","outsideVal","currentVal","setCurrentVal","prevOutsideVal","usePrevious","RawInfluxQLEditor","currentQuery","setCurrentQuery","currentAlias","setCurrentAlias","alias","aliasElementId","useUniqueId","selectElementId","applyDelayedChangesAndRunQuery","TextArea","rows","spellCheck","e","v","I","InfluxQueryBuilder","buildExploreQuery","withKey","withMeasurementFilter","whereConditions","reduce","memo","runExploreQuery","datasource","q","metricFindQuery","async","getTagKeysForMeasurementAndTags","text","paddingRightClass","paddingRight","unwrap","Error","FormatAsSection","format","selectClass","minWidth","formatCreateLabel","SelReload","loadOptions","allowCustomValue","onClose","debouncedLoadOptions","debouncePromise","leading","defaultOptions","autoFocus","onCloseMenu","SelSingleLoad","loadState","doLoad","useAsyncFn","isLoading","loading","Sel","filterByLoadOptions","Inp","initialValue","currentValue","setCurrentValue","onKeyDown","defaultButtonClass","cursor","Seg","buttonClassName","setOpen","InlineLabel","as","toSelectableValue","t","FromSection","getPolicyOptions","getMeasurementOptions","allPolicies","some","p","InputSection","isWide","OPTIONS","OrderByTimeSection","AddButton","onAdd","noRightMarginPaddingClass","marginRight","RemovableName","onRemove","WithContextMenu","renderMenuItems","renderRemovableNameMenuItems","MenuGroup","MenuItem","openMenu","noHorizMarginPaddingClass","paddingLeft","marginLeft","Part","useTheme2","partClass","useMemo","lineHeight","typography","fontSize","getPartClass","isLast","then","items","par","newParams","onParamChange","PartListSection","getNewPartOptions","onAddNewPart","onRemovePart","pars","isRegex","getOperator","getCondition","isFirst","adjustOperatorIfNeeded","currentOperator","newTagValue","isCurrentOperatorRegex","operatorOptions","condititonOptions","loadConditionOptions","Promise","resolve","loadOperatorOptions","Tag","getTagKeyOptions","getTagValueOptions","catch","err","console","error","op","TagsSection","newT","newTag","newTags","onTagChange","onTagRemove","tagKey","minimalTag","addNewTag","getPartParams","dynamicParamOptions","paramValues","defParam","get","makePartList","queryParts","qp","withTemplateVariableOptions","optionsPromise","filterTags","allTagKeys","has","Editor","formatAsId","orderByTimeId","useStyles2","normalizeQuery","Set","selectLists","dynamicSelectPartOptions","Map","getFieldKeysForMeasurement","sel","getTagKeys","keys","groupByList","dynamicGroupByPartOptions","onAppliedChange","newQuery","SegmentSection","getAllPolicies","measurementFilter","getAllMeasurementsForTags","m","inlineLabel","getTagValues","Object","children","x","getNewSelectPartOptions","listIndex","newSel","changeSelectPart","model","addNewSelectPart","selectModel","tagKeys","getNewGroupByPartOptions","newGroupBy","changeGroupByPart","addNewGroupByPart","VariableQueryEditor","isFlux","refId","onRefresh","AnnotationEditor","eventQuery","setEventQuery","textColumn","setTextColumn","tagsColumn","setTagsColumn","timeEndColumn","setTimeEndColumn","titleColumn","updateValue","fromAnnotations","textEditor","InfluxSeries","series","annotation","meta","getTimeSeries","output","j","each","columns","seriesName","columnName","_getSeriesName","datapoints","values","segments","split","g1","g2","group","segIndex","isNaN","getAnnotations","list","titleCol","timeCol","timeEndCol","tagsCol","textCol","column","includes","data","time","Date","timeEnd","flatten","getTable","table","TableModel","seriesIndex","firstCol","firstTableCol","FieldType","reordered","hasOwnProperty","prepareAnnotation","json","queryType","matchAny","migrateLegacyAnnotation","ResponseParser","parse","results","influxResults","normalizedQuery","toLowerCase","isValueFirst","res","serie","isArray","addUnique","Array","from","dfs","executedQueryString","selectedParams","allParams","selector","uniqueParams","param","incrementName","getSelectedParams","fields","field","labels","getTableCols","dfsByLabels","df","getTableRows","rsp","toDataQueryResponse","colText","colContainsTag","toArray","metrics","nameIncremenet","add","getFieldType","firstNotNull","valueType","timeSeriesToDataFrame","timeSeries","times","points","point","TIME_SERIES_TIME_FIELD_NAME","config","ArrayVector","TIME_SERIES_VALUE_FIELD_NAME","displayNameFromDS","InfluxDatasource","DataSourceWithBackend","instanceSettings","urls","url","trim","username","withCredentials","settingsData","interval","responseParser","isProxyAccess","annotations","QueryEditor","request","throwError","filteredRequest","targets","hide","isMigrationToggleOnAndIsAccessProxy","pipe","seriesList","groupedFrames","filteredFrames","preferredVisualisationType","classicQuery","getQueryDisplayText","filterQuery","applyTemplateVariables","rest","applyVariables","streams","Observable","subscriber","annotationEvents","events","next","toDataFrame","ex","finally","complete","merge","timeFilter","getTimeFilter","queryTargets","allQueries","_map","__interval","acc","current","of","adhocFilters","getAdhocFilters","adhocFiltersFromDashboard","flatMap","ahFilters","_seriesQuery","result","influxSeries","reject","getRef","lastValueFrom","getBackendSrv","fetch","method","headers","getRequestHeaders","range","valueOf","to","queries","requestId","transformAnnotationResponse","rangeRaw","raw","timezone","targetContainsTemplate","queryText","containsTemplate","interpolateVariablesInQueries","expandedQuery","selects","frameToMetricFindValue","interpolated","resp","_influxRequest","epoch","serializeParams","encodeURIComponent","currentUrl","shift","u","db","extend","omit","pick","req","precision","inspect","paramSerializer","Authorization","errors","elem","catchError","cancelled","handleErrors","status","isInteger","statusText","getInfluxTime","date","roundUp","isString","exec","dateMath","plugin","DataSourcePlugin","setConfigEditor","setQueryEditor","display","flexGrow","setVariableQueryEditor","setQueryEditorHelp"],"sourceRoot":""}