{"version":3,"file":"heatmapPanelOLD.623c9ec1b559167f5d7b.js","mappings":"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","sources":["webpack://grafana/./public/app/angular/AngularLocationWrapper.ts","webpack://grafana/./public/app/angular/panel/metrics_panel_ctrl.ts","webpack://grafana/./public/app/angular/panel/panel_ctrl.ts","webpack://grafana/./public/app/angular/panel/query_ctrl.ts","webpack://grafana/./public/app/plugins/panel/graph/data_processor.ts","webpack://grafana/./public/app/plugins/panel/heatmap-old/color_scale.ts","webpack://grafana/./public/app/plugins/panel/heatmap-old/color_legend.ts","webpack://grafana/./public/app/plugins/panel/heatmap-old/axes_editor.ts","webpack://grafana/./public/app/plugins/panel/heatmap-old/display_editor.ts","webpack://grafana/./public/app/plugins/panel/heatmap-old/heatmap_data_converter.ts","webpack://grafana/./public/app/plugins/panel/heatmap-old/heatmap_tooltip.ts","webpack://grafana/./public/app/plugins/panel/heatmap-old/rendering.ts","webpack://grafana/./public/app/plugins/panel/heatmap-old/heatmap_ctrl.ts","webpack://grafana/./public/app/plugins/sdk.ts"],"sourcesContent":["import { deprecationWarning, urlUtil } from '@grafana/data';\nimport { locationSearchToObject, locationService, navigationLogger } from '@grafana/runtime';\n\n// Ref: https://github.com/angular/angular.js/blob/ae8e903edf88a83fedd116ae02c0628bf72b150c/src/ng/location.js#L5\nconst DEFAULT_PORTS: Record<string, number> = { http: 80, https: 443, ftp: 21 };\n\nexport class AngularLocationWrapper {\n  constructor() {\n    this.absUrl = this.wrapInDeprecationWarning(this.absUrl);\n    this.hash = this.wrapInDeprecationWarning(this.hash);\n    this.host = this.wrapInDeprecationWarning(this.host);\n    this.path = this.wrapInDeprecationWarning(this.path);\n    this.port = this.wrapInDeprecationWarning(this.port, 'window.location');\n    this.protocol = this.wrapInDeprecationWarning(this.protocol, 'window.location');\n    this.replace = this.wrapInDeprecationWarning(this.replace);\n    this.search = this.wrapInDeprecationWarning(this.search);\n    this.state = this.wrapInDeprecationWarning(this.state);\n    this.url = this.wrapInDeprecationWarning(this.url);\n  }\n\n  wrapInDeprecationWarning(fn: Function, replacement?: string) {\n    let self = this;\n\n    return function wrapper() {\n      deprecationWarning('$location', fn.name, replacement || 'locationService');\n      return fn.apply(self, arguments);\n    };\n  }\n\n  absUrl(): string {\n    return `${window.location.origin}${this.url()}`;\n  }\n\n  hash(newHash?: string | null) {\n    navigationLogger('AngularLocationWrapper', false, 'Angular compat layer: hash');\n\n    if (!newHash) {\n      return locationService.getLocation().hash.slice(1);\n    } else {\n      throw new Error('AngularLocationWrapper method not implemented.');\n    }\n  }\n\n  host(): string {\n    return new URL(window.location.href).hostname;\n  }\n\n  path(pathname?: any) {\n    navigationLogger('AngularLocationWrapper', false, 'Angular compat layer: path');\n\n    const location = locationService.getLocation();\n\n    if (pathname !== undefined && pathname !== null) {\n      let parsedPath = String(pathname);\n      parsedPath = parsedPath.startsWith('/') ? parsedPath : `/${parsedPath}`;\n      const url = new URL(`${window.location.origin}${parsedPath}`);\n\n      locationService.push({\n        pathname: url.pathname,\n        search: url.search.length > 0 ? url.search : location.search,\n        hash: url.hash.length > 0 ? url.hash : location.hash,\n      });\n      return this;\n    }\n\n    if (pathname === null) {\n      locationService.push('/');\n      return this;\n    }\n\n    return location.pathname;\n  }\n\n  port(): number | null {\n    const url = new URL(window.location.href);\n    return parseInt(url.port, 10) || DEFAULT_PORTS[url.protocol] || null;\n  }\n\n  protocol(): string {\n    return new URL(window.location.href).protocol.slice(0, -1);\n  }\n\n  replace() {\n    throw new Error('AngularLocationWrapper method not implemented.');\n  }\n\n  search(search?: any, paramValue?: any) {\n    navigationLogger('AngularLocationWrapper', false, 'Angular compat layer: search');\n    if (!search) {\n      return locationService.getSearchObject();\n    }\n\n    if (search && arguments.length > 1) {\n      locationService.partial({\n        [search]: paramValue,\n      });\n\n      return this;\n    }\n\n    if (search) {\n      let newQuery;\n\n      if (typeof search === 'object') {\n        newQuery = { ...search };\n      } else {\n        newQuery = locationSearchToObject(search);\n      }\n\n      for (const key of Object.keys(newQuery)) {\n        // removing params with null | undefined\n        if (newQuery[key] === null || newQuery[key] === undefined) {\n          delete newQuery[key];\n        }\n      }\n\n      const updatedUrl = urlUtil.renderUrl(locationService.getLocation().pathname, newQuery);\n      locationService.push(updatedUrl);\n    }\n\n    return this;\n  }\n\n  state(state?: any) {\n    navigationLogger('AngularLocationWrapper', false, 'Angular compat layer: state');\n    throw new Error('AngularLocationWrapper method not implemented.');\n  }\n\n  url(newUrl?: any) {\n    navigationLogger('AngularLocationWrapper', false, 'Angular compat layer: url');\n\n    if (newUrl !== undefined) {\n      if (newUrl.startsWith('#')) {\n        locationService.push({ ...locationService.getLocation(), hash: newUrl });\n      } else if (newUrl.startsWith('?')) {\n        locationService.push({ ...locationService.getLocation(), search: newUrl });\n      } else if (newUrl.trim().length === 0) {\n        locationService.push('/');\n      } else {\n        locationService.push(newUrl);\n      }\n\n      return locationService;\n    }\n\n    const location = locationService.getLocation();\n    return `${location.pathname}${location.search}${location.hash}`;\n  }\n}\n","import { isArray } from 'lodash';\nimport { Unsubscribable } from 'rxjs';\n\nimport {\n  DataFrame,\n  DataQueryResponse,\n  DataSourceApi,\n  LegacyResponseData,\n  LoadingState,\n  PanelData,\n  PanelEvents,\n  TimeRange,\n  toDataFrameDTO,\n  toLegacyResponseData,\n} from '@grafana/data';\nimport { PanelCtrl } from 'app/angular/panel/panel_ctrl';\nimport { ContextSrv } from 'app/core/services/context_srv';\nimport { PanelModel } from 'app/features/dashboard/state';\nimport { applyPanelTimeOverrides } from 'app/features/dashboard/utils/panel';\n\nimport { PanelQueryRunner } from '../../features/query/state/PanelQueryRunner';\n\nclass MetricsPanelCtrl extends PanelCtrl {\n  declare datasource: DataSourceApi;\n  declare range: TimeRange;\n\n  contextSrv: ContextSrv;\n  datasourceSrv: any;\n  timeSrv: any;\n  templateSrv: any;\n  interval: any;\n  intervalMs: any;\n  resolution: any;\n  timeInfo?: string;\n  skipDataOnInit = false;\n  dataList: LegacyResponseData[] = [];\n  querySubscription?: Unsubscribable | null;\n  useDataFrames = false;\n  panelData?: PanelData;\n\n  constructor($scope: any, $injector: any) {\n    super($scope, $injector);\n\n    this.contextSrv = $injector.get('contextSrv');\n    this.datasourceSrv = $injector.get('datasourceSrv');\n    this.timeSrv = $injector.get('timeSrv');\n    this.templateSrv = $injector.get('templateSrv');\n    this.panel.datasource = this.panel.datasource || null;\n\n    this.events.on(PanelEvents.refresh, this.onMetricsPanelRefresh.bind(this));\n    this.events.on(PanelEvents.panelTeardown, this.onPanelTearDown.bind(this));\n    this.events.on(PanelEvents.componentDidMount, this.onMetricsPanelMounted.bind(this));\n  }\n\n  private onMetricsPanelMounted() {\n    const queryRunner = this.panel.getQueryRunner() as PanelQueryRunner;\n    this.querySubscription = queryRunner\n      .getData({ withTransforms: true, withFieldConfig: true })\n      .subscribe(this.panelDataObserver);\n  }\n\n  private onPanelTearDown() {\n    if (this.querySubscription) {\n      this.querySubscription.unsubscribe();\n      this.querySubscription = null;\n    }\n  }\n\n  private onMetricsPanelRefresh() {\n    // ignore fetching data if another panel is in fullscreen\n    if (this.otherPanelInFullscreenMode()) {\n      return;\n    }\n\n    // if we have snapshot data use that\n    if (this.panel.snapshotData) {\n      this.updateTimeRange();\n      let data = this.panel.snapshotData;\n      // backward compatibility\n      if (!isArray(data)) {\n        data = data.data;\n      }\n\n      this.panelData = {\n        state: LoadingState.Done,\n        series: data,\n        timeRange: this.range,\n      };\n\n      // Defer panel rendering till the next digest cycle.\n      // For some reason snapshot panels don't init at this time, so this helps to avoid rendering issues.\n      return this.$timeout(() => {\n        this.events.emit(PanelEvents.dataSnapshotLoad, data);\n      });\n    }\n\n    // clear loading/error state\n    delete this.error;\n    this.loading = true;\n\n    // load datasource service\n    return this.datasourceSrv\n      .get(this.panel.datasource, this.panel.scopedVars)\n      .then(this.issueQueries.bind(this))\n      .catch((err: any) => {\n        this.processDataError(err);\n      });\n  }\n\n  processDataError(err: any) {\n    // if canceled  keep loading set to true\n    if (err.cancelled) {\n      console.log('Panel request cancelled', err);\n      return;\n    }\n\n    this.error = err.message || 'Request Error';\n\n    if (err.data) {\n      if (err.data.message) {\n        this.error = err.data.message;\n      } else if (err.data.error) {\n        this.error = err.data.error;\n      }\n    }\n\n    this.angularDirtyCheck();\n  }\n\n  angularDirtyCheck() {\n    if (!this.$scope.$root.$$phase) {\n      this.$scope.$digest();\n    }\n  }\n\n  // Updates the response with information from the stream\n  panelDataObserver = {\n    next: (data: PanelData) => {\n      this.panelData = data;\n\n      if (data.state === LoadingState.Error) {\n        this.loading = false;\n        this.processDataError(data.error);\n      }\n\n      // Ignore data in loading state\n      if (data.state === LoadingState.Loading) {\n        this.loading = true;\n        this.angularDirtyCheck();\n        return;\n      }\n\n      if (data.request) {\n        const { timeInfo } = data.request;\n        if (timeInfo) {\n          this.timeInfo = timeInfo;\n        }\n      }\n\n      if (data.timeRange) {\n        this.range = data.timeRange;\n      }\n\n      if (this.useDataFrames) {\n        this.handleDataFrames(data.series);\n      } else {\n        // Make the results look as if they came directly from a <6.2 datasource request\n        const legacy = data.series.map((v) => toLegacyResponseData(v));\n        this.handleQueryResult({ data: legacy });\n      }\n\n      this.angularDirtyCheck();\n    },\n  };\n\n  updateTimeRange(datasource?: DataSourceApi) {\n    this.datasource = datasource || this.datasource;\n    this.range = this.timeSrv.timeRange();\n\n    const newTimeData = applyPanelTimeOverrides(this.panel, this.range);\n    this.timeInfo = newTimeData.timeInfo;\n    this.range = newTimeData.timeRange;\n  }\n\n  issueQueries(datasource: DataSourceApi) {\n    this.updateTimeRange(datasource);\n\n    this.datasource = datasource;\n\n    const panel = this.panel as PanelModel;\n    const queryRunner = panel.getQueryRunner();\n\n    return queryRunner.run({\n      datasource: panel.datasource,\n      queries: panel.targets,\n      panelId: panel.id,\n      dashboardId: this.dashboard.id,\n      timezone: this.dashboard.getTimezone(),\n      timeInfo: this.timeInfo,\n      timeRange: this.range,\n      maxDataPoints: panel.maxDataPoints || this.width,\n      minInterval: panel.interval,\n      publicDashboardAccessToken: this.dashboard.meta.publicDashboardAccessToken,\n      scopedVars: panel.scopedVars,\n      cacheTimeout: panel.cacheTimeout,\n      transformations: panel.transformations,\n    });\n  }\n\n  handleDataFrames(data: DataFrame[]) {\n    this.loading = false;\n\n    if (this.dashboard && this.dashboard.snapshot) {\n      this.panel.snapshotData = data.map((frame) => toDataFrameDTO(frame));\n    }\n\n    try {\n      this.events.emit(PanelEvents.dataFramesReceived, data);\n    } catch (err) {\n      this.processDataError(err);\n    }\n  }\n\n  handleQueryResult(result: DataQueryResponse) {\n    this.loading = false;\n\n    if (this.dashboard.snapshot) {\n      this.panel.snapshotData = result.data;\n    }\n\n    if (!result || !result.data) {\n      console.log('Data source query result invalid, missing data field:', result);\n      result = { data: [] };\n    }\n\n    try {\n      this.events.emit(PanelEvents.dataReceived, result.data);\n    } catch (err) {\n      this.processDataError(err);\n    }\n  }\n}\n\nexport { MetricsPanelCtrl };\n","import { auto } from 'angular';\nimport { isString } from 'lodash';\n\nimport {\n  AppEvent,\n  PanelEvents,\n  PanelPluginMeta,\n  AngularPanelMenuItem,\n  EventBusExtended,\n  EventBusSrv,\n} from '@grafana/data';\nimport { AngularLocationWrapper } from 'app/angular/AngularLocationWrapper';\nimport config from 'app/core/config';\nimport { profiler } from 'app/core/core';\n\nimport { DashboardModel } from '../../features/dashboard/state';\n\nexport class PanelCtrl {\n  panel: any;\n  error: any;\n  declare dashboard: DashboardModel;\n  pluginName = '';\n  pluginId = '';\n  editorTabs: any;\n  $scope: any;\n  $injector: auto.IInjectorService;\n  $timeout: any;\n  editModeInitiated = false;\n  declare height: number;\n  declare width: number;\n  containerHeight: any;\n  events: EventBusExtended;\n  loading = false;\n  timing: any;\n  $location: AngularLocationWrapper;\n\n  constructor($scope: any, $injector: auto.IInjectorService) {\n    this.panel = this.panel ?? $scope.$parent.panel;\n    this.dashboard = this.dashboard ?? $scope.$parent.dashboard;\n    this.$injector = $injector;\n    this.$scope = $scope;\n    this.$timeout = $injector.get('$timeout');\n    this.editorTabs = [];\n    this.$location = new AngularLocationWrapper();\n    this.events = new EventBusSrv();\n    this.timing = {}; // not used but here to not break plugins\n\n    const plugin = config.panels[this.panel.type];\n    if (plugin) {\n      this.pluginId = plugin.id;\n      this.pluginName = plugin.name;\n    }\n\n    $scope.$on(PanelEvents.componentDidMount.name, () => this.panelDidMount());\n  }\n\n  panelDidMount() {\n    this.events.emit(PanelEvents.componentDidMount);\n    this.events.emit(PanelEvents.initialized);\n    this.dashboard.panelInitialized(this.panel);\n  }\n\n  renderingCompleted() {\n    profiler.renderingCompleted();\n  }\n\n  refresh() {\n    this.panel.refresh();\n  }\n\n  publishAppEvent<T>(event: AppEvent<T>, payload?: T) {\n    this.$scope.$root.appEvent(event, payload);\n  }\n\n  initEditMode() {\n    if (!this.editModeInitiated) {\n      this.editModeInitiated = true;\n      this.events.emit(PanelEvents.editModeInitialized);\n    }\n  }\n\n  addEditorTab(title: string, directiveFn: any, index?: number, icon?: any) {\n    const editorTab = { title, directiveFn, icon };\n\n    if (isString(directiveFn)) {\n      editorTab.directiveFn = () => {\n        return { templateUrl: directiveFn };\n      };\n    }\n\n    if (index) {\n      this.editorTabs.splice(index, 0, editorTab);\n    } else {\n      this.editorTabs.push(editorTab);\n    }\n  }\n\n  getExtendedMenu() {\n    const menu: AngularPanelMenuItem[] = [];\n    this.events.emit(PanelEvents.initPanelActions, menu);\n    return menu;\n  }\n\n  // Override in sub-class to add items before extended menu\n  async getAdditionalMenuItems(): Promise<any[]> {\n    return [];\n  }\n\n  otherPanelInFullscreenMode() {\n    return this.dashboard.otherPanelInFullscreen(this.panel);\n  }\n\n  render(payload?: any) {\n    this.events.emit(PanelEvents.render, payload);\n  }\n\n  // overriden from react\n  onPluginTypeChange = (plugin: PanelPluginMeta) => {};\n}\n","import { auto } from 'angular';\nimport { indexOf } from 'lodash';\n\nexport class QueryCtrl<T = any> {\n  target!: T;\n  datasource!: any;\n  panelCtrl!: any;\n  panel: any;\n  hasRawMode!: boolean;\n  error?: string | null;\n  isLastQuery: boolean;\n\n  constructor(public $scope: any, public $injector: auto.IInjectorService) {\n    this.panelCtrl = this.panelCtrl ?? $scope.ctrl.panelCtrl;\n    this.target = this.target ?? $scope.ctrl.target;\n    this.datasource = this.datasource ?? $scope.ctrl.datasource;\n    this.panel = this.panelCtrl?.panel ?? $scope.ctrl.panelCtrl.panel;\n    this.isLastQuery = indexOf(this.panel.targets, this.target) === this.panel.targets.length - 1;\n  }\n\n  refresh() {\n    this.panelCtrl.refresh();\n  }\n}\n","import { find } from 'lodash';\n\nimport { DataFrame, dateTime, Field, FieldType, getFieldDisplayName, getTimeField, TimeRange } from '@grafana/data';\nimport { colors } from '@grafana/ui';\nimport { applyNullInsertThreshold } from '@grafana/ui/src/components/GraphNG/nullInsertThreshold';\nimport config from 'app/core/config';\nimport TimeSeries from 'app/core/time_series2';\n\ntype Options = {\n  dataList: DataFrame[];\n  range?: TimeRange;\n};\n\nexport class DataProcessor {\n  constructor(private panel: any) {}\n\n  getSeriesList(options: Options): TimeSeries[] {\n    const list: TimeSeries[] = [];\n    const { dataList, range } = options;\n\n    if (!dataList || !dataList.length) {\n      return list;\n    }\n\n    for (let i = 0; i < dataList.length; i++) {\n      let series = dataList[i];\n      let { timeField } = getTimeField(series);\n\n      if (!timeField) {\n        continue;\n      }\n\n      series = applyNullInsertThreshold({ frame: series, refFieldName: timeField.name });\n      timeField = getTimeField(series).timeField!; // use updated length\n\n      for (let j = 0; j < series.fields.length; j++) {\n        const field = series.fields[j];\n\n        if (field.type !== FieldType.number) {\n          continue;\n        }\n        const name = getFieldDisplayName(field, series, dataList);\n        const datapoints = [];\n\n        for (let r = 0; r < series.length; r++) {\n          datapoints.push([field.values.get(r), dateTime(timeField.values.get(r)).valueOf()]);\n        }\n\n        list.push(this.toTimeSeries(field, name, i, j, datapoints, list.length, range));\n      }\n    }\n\n    // Merge all the rows if we want to show a histogram\n    if (this.panel.xaxis.mode === 'histogram' && !this.panel.stack && list.length > 1) {\n      const first = list[0];\n      first.alias = first.aliasEscaped = 'Count';\n\n      for (let i = 1; i < list.length; i++) {\n        first.datapoints = first.datapoints.concat(list[i].datapoints);\n      }\n\n      return [first];\n    }\n\n    return list;\n  }\n\n  private toTimeSeries(\n    field: Field,\n    alias: string,\n    dataFrameIndex: number,\n    fieldIndex: number,\n    datapoints: any[][],\n    index: number,\n    range?: TimeRange\n  ) {\n    const colorIndex = index % colors.length;\n    const color = this.panel.aliasColors[alias] || colors[colorIndex];\n\n    const series = new TimeSeries({\n      datapoints: datapoints || [],\n      alias: alias,\n      color: config.theme2.visualization.getColorByName(color),\n      unit: field.config ? field.config.unit : undefined,\n      dataFrameIndex,\n      fieldIndex,\n    });\n\n    if (datapoints && datapoints.length > 0 && range) {\n      const last = datapoints[datapoints.length - 1][1];\n      const from = range.from;\n\n      if (last - from.valueOf() < -10000) {\n        // If the data is in reverse order\n        const first = datapoints[0][1];\n        if (first - from.valueOf() < -10000) {\n          series.isOutsideRange = true;\n        }\n      }\n    }\n    return series;\n  }\n\n  setPanelDefaultsForNewXAxisMode() {\n    switch (this.panel.xaxis.mode) {\n      case 'time': {\n        this.panel.bars = false;\n        this.panel.lines = true;\n        this.panel.points = false;\n        this.panel.legend.show = true;\n        this.panel.tooltip.shared = true;\n        this.panel.xaxis.values = [];\n        break;\n      }\n      case 'series': {\n        this.panel.bars = true;\n        this.panel.lines = false;\n        this.panel.points = false;\n        this.panel.stack = false;\n        this.panel.legend.show = false;\n        this.panel.tooltip.shared = false;\n        this.panel.xaxis.values = ['total'];\n        break;\n      }\n      case 'histogram': {\n        this.panel.bars = true;\n        this.panel.lines = false;\n        this.panel.points = false;\n        this.panel.stack = false;\n        this.panel.legend.show = false;\n        this.panel.tooltip.shared = false;\n        break;\n      }\n    }\n  }\n\n  validateXAxisSeriesValue() {\n    switch (this.panel.xaxis.mode) {\n      case 'series': {\n        if (this.panel.xaxis.values.length === 0) {\n          this.panel.xaxis.values = ['total'];\n          return;\n        }\n\n        const validOptions = this.getXAxisValueOptions({});\n        const found: any = find(validOptions, { value: this.panel.xaxis.values[0] });\n        if (!found) {\n          this.panel.xaxis.values = ['total'];\n        }\n        return;\n      }\n    }\n  }\n\n  getXAxisValueOptions(options: any) {\n    switch (this.panel.xaxis.mode) {\n      case 'series': {\n        return [\n          { text: 'Avg', value: 'avg' },\n          { text: 'Min', value: 'min' },\n          { text: 'Max', value: 'max' },\n          { text: 'Total', value: 'total' },\n          { text: 'Count', value: 'count' },\n        ];\n      }\n    }\n\n    return [];\n  }\n\n  pluckDeep(obj: any, property: string) {\n    const propertyParts = property.split('.');\n    let value = obj;\n    for (let i = 0; i < propertyParts.length; ++i) {\n      if (value[propertyParts[i]]) {\n        value = value[propertyParts[i]];\n      } else {\n        return undefined;\n      }\n    }\n    return value;\n  }\n}\n","import * as d3 from 'd3';\nimport * as d3ScaleChromatic from 'd3-scale-chromatic';\n\nexport function getColorScale(colorScheme: any, lightTheme: boolean, maxValue: number, minValue = 0): (d: any) => any {\n  //@ts-ignore\n  const colorInterpolator = d3ScaleChromatic[colorScheme.value];\n  const colorScaleInverted = colorScheme.invert === 'always' || colorScheme.invert === (lightTheme ? 'light' : 'dark');\n\n  const start = colorScaleInverted ? maxValue : minValue;\n  const end = colorScaleInverted ? minValue : maxValue;\n\n  return d3.scaleSequential(colorInterpolator).domain([start, end]);\n}\n\nexport function getOpacityScale(\n  options: { cardColor?: null; colorScale?: any; exponent?: any },\n  maxValue: number,\n  minValue = 0\n): any {\n  let legendOpacityScale;\n  if (options.colorScale === 'linear') {\n    legendOpacityScale = d3.scaleLinear().domain([minValue, maxValue]).range([0, 1]);\n  } else if (options.colorScale === 'sqrt') {\n    legendOpacityScale = d3.scalePow().exponent(options.exponent).domain([minValue, maxValue]).range([0, 1]);\n  }\n  return legendOpacityScale;\n}\n","import * as d3 from 'd3';\nimport $ from 'jquery';\nimport { find, isEmpty, isNil, sortBy, uniq } from 'lodash';\n\nimport { PanelEvents } from '@grafana/data';\nimport coreModule from 'app/angular/core_module';\nimport { config } from 'app/core/config';\nimport { contextSrv } from 'app/core/core';\nimport { tickStep } from 'app/core/utils/ticks';\n\nimport { getColorScale, getOpacityScale } from './color_scale';\n\nconst LEGEND_HEIGHT_PX = 6;\nconst LEGEND_WIDTH_PX = 100;\nconst LEGEND_TICK_SIZE = 0;\nconst LEGEND_VALUE_MARGIN = 0;\nconst LEGEND_PADDING_LEFT = 10;\nconst LEGEND_SEGMENT_WIDTH = 10;\n\n/**\n * Color legend for heatmap editor.\n */\ncoreModule.directive('colorLegend', () => {\n  return {\n    restrict: 'E',\n    template: '<div class=\"heatmap-color-legend\"><svg width=\"16.5rem\" height=\"24px\"></svg></div>',\n    link: (scope: any, elem, attrs) => {\n      const ctrl = scope.ctrl;\n      const panel = scope.ctrl.panel;\n\n      render();\n\n      ctrl.events.on(PanelEvents.render, () => {\n        render();\n      });\n\n      function render() {\n        const legendElem = $(elem).find('svg');\n        const legendWidth = Math.floor(legendElem.outerWidth() ?? 10);\n\n        if (panel.color.mode === 'spectrum') {\n          const colorScheme: any = find(ctrl.colorSchemes, {\n            value: panel.color.colorScheme,\n          });\n          const colorScale = getColorScale(colorScheme, contextSrv.user.lightTheme, legendWidth);\n          drawSimpleColorLegend(elem, colorScale);\n        } else if (panel.color.mode === 'opacity') {\n          const colorOptions = panel.color;\n          drawSimpleOpacityLegend(elem, colorOptions);\n        }\n      }\n    },\n  };\n});\n\n/**\n * Heatmap legend with scale values.\n */\ncoreModule.directive('heatmapLegend', () => {\n  return {\n    restrict: 'E',\n    template: `<div class=\"heatmap-color-legend\"><svg width=\"${LEGEND_WIDTH_PX}px\" height=\"${LEGEND_HEIGHT_PX}px\"></svg></div>`,\n    link: (scope: any, elem, attrs) => {\n      const ctrl = scope.ctrl;\n      const panel = scope.ctrl.panel;\n\n      render();\n      ctrl.events.on(PanelEvents.render, () => {\n        render();\n      });\n\n      function render() {\n        clearLegend(elem);\n        if (!isEmpty(ctrl.data) && !isEmpty(ctrl.data.cards)) {\n          const cardStats = ctrl.data.cardStats;\n          const rangeFrom = isNil(panel.color.min) ? Math.max(cardStats.min, 0) : panel.color.min;\n          const rangeTo = isNil(panel.color.max) ? cardStats.max : panel.color.max;\n          const maxValue = cardStats.max;\n          const minValue = cardStats.min;\n\n          if (panel.color.mode === 'spectrum') {\n            const colorScheme: any = find(ctrl.colorSchemes, {\n              value: panel.color.colorScheme,\n            });\n            drawColorLegend(elem, colorScheme, rangeFrom, rangeTo, maxValue, minValue);\n          } else if (panel.color.mode === 'opacity') {\n            const colorOptions = panel.color;\n            drawOpacityLegend(elem, colorOptions, rangeFrom, rangeTo, maxValue, minValue);\n          }\n        }\n      }\n    },\n  };\n});\n\nfunction drawColorLegend(\n  elem: JQuery,\n  colorScheme: any,\n  rangeFrom: number,\n  rangeTo: number,\n  maxValue: number,\n  minValue: number\n) {\n  const legendElem = $(elem).find('svg');\n  const legendDomElement = legendElem.get(0);\n  if (legendDomElement) {\n    const legend = d3.select(legendDomElement);\n    clearLegend(elem);\n\n    const legendWidth = Math.floor(legendElem.outerWidth() ?? 10) - 30;\n    const legendHeight = legendElem.attr('height') as any;\n\n    const rangeStep = ((rangeTo - rangeFrom) / legendWidth) * LEGEND_SEGMENT_WIDTH;\n    const widthFactor = legendWidth / (rangeTo - rangeFrom);\n    const valuesRange = d3.range(rangeFrom, rangeTo, rangeStep);\n\n    const colorScale = getColorScale(colorScheme, contextSrv.user.lightTheme, rangeTo, rangeFrom);\n    legend\n      .append('g')\n      .attr('class', 'legend-color-bar')\n      .attr('transform', 'translate(' + LEGEND_PADDING_LEFT + ',0)')\n      .selectAll('.heatmap-color-legend-rect')\n      .data(valuesRange)\n      .enter()\n      .append('rect')\n      .attr('x', (d) => Math.round((d - rangeFrom) * widthFactor))\n      .attr('y', 0)\n      .attr('width', Math.round(rangeStep * widthFactor + 1)) // Overlap rectangles to prevent gaps\n      .attr('height', legendHeight)\n      .attr('stroke-width', 0)\n      .attr('fill', (d) => colorScale(d));\n\n    drawLegendValues(elem, rangeFrom, rangeTo, maxValue, minValue, legendWidth, valuesRange);\n  }\n}\n\nfunction drawOpacityLegend(\n  elem: JQuery,\n  options: { cardColor: null },\n  rangeFrom: number,\n  rangeTo: number,\n  maxValue: any,\n  minValue: number\n) {\n  const legendElem = $(elem).find('svg');\n  const legendDomElement = legendElem.get(0);\n  if (legendDomElement) {\n    const legend = d3.select(legendDomElement);\n    clearLegend(elem);\n\n    const legendWidth = Math.floor(legendElem.outerWidth() ?? 30) - 30;\n    const legendHeight = legendElem.attr('height') as any;\n\n    const rangeStep = ((rangeTo - rangeFrom) / legendWidth) * LEGEND_SEGMENT_WIDTH;\n    const widthFactor = legendWidth / (rangeTo - rangeFrom);\n    const valuesRange = d3.range(rangeFrom, rangeTo, rangeStep);\n\n    const opacityScale = getOpacityScale(options, rangeTo, rangeFrom);\n    legend\n      .append('g')\n      .attr('class', 'legend-color-bar')\n      .attr('transform', 'translate(' + LEGEND_PADDING_LEFT + ',0)')\n      .selectAll('.heatmap-opacity-legend-rect')\n      .data(valuesRange)\n      .enter()\n      .append('rect')\n      .attr('x', (d) => Math.round((d - rangeFrom) * widthFactor))\n      .attr('y', 0)\n      .attr('width', Math.round(rangeStep * widthFactor))\n      .attr('height', legendHeight)\n      .attr('stroke-width', 0)\n      .attr('fill', options.cardColor)\n      .style('opacity', (d) => opacityScale(d));\n\n    drawLegendValues(elem, rangeFrom, rangeTo, maxValue, minValue, legendWidth, valuesRange);\n  }\n}\n\nfunction drawLegendValues(\n  elem: JQuery,\n  rangeFrom: number,\n  rangeTo: number,\n  maxValue: any,\n  minValue: any,\n  legendWidth: number,\n  valuesRange: number[]\n) {\n  const legendElem = $(elem).find('svg');\n  const legendDomElement = legendElem.get(0);\n  if (legendDomElement) {\n    const legend = d3.select(legendDomElement);\n\n    if (legendWidth <= 0 || legendDomElement.childNodes.length === 0) {\n      return;\n    }\n\n    const legendValueScale = d3.scaleLinear().domain([rangeFrom, rangeTo]).range([0, legendWidth]);\n\n    const ticks = buildLegendTicks(rangeFrom, rangeTo, maxValue, minValue);\n    const xAxis = d3.axisBottom(legendValueScale).tickValues(ticks).tickSize(LEGEND_TICK_SIZE);\n\n    const colorRect = legendElem.find(':first-child');\n    const posY = getSvgElemHeight(legendElem) + LEGEND_VALUE_MARGIN;\n    const posX = getSvgElemX(colorRect) + LEGEND_PADDING_LEFT;\n\n    d3.select(legendDomElement)\n      .append('g')\n      .attr('class', 'axis')\n      .attr('transform', 'translate(' + posX + ',' + posY + ')')\n      .call(xAxis);\n\n    legend.select('.axis').select('.domain').remove();\n  }\n}\n\nfunction drawSimpleColorLegend(elem: JQuery, colorScale: any) {\n  const legendElem = $(elem).find('svg');\n  clearLegend(elem);\n\n  const legendWidth = Math.floor(legendElem.outerWidth() ?? 30);\n  const legendHeight = legendElem.attr('height') as any;\n\n  if (legendWidth) {\n    const valuesNumber = Math.floor(legendWidth / 2);\n    const rangeStep = Math.floor(legendWidth / valuesNumber);\n    const valuesRange = d3.range(0, legendWidth, rangeStep);\n\n    const legendDomElement = legendElem.get(0);\n    if (legendDomElement) {\n      const legend = d3.select(legendDomElement);\n      const legendRects = legend.selectAll('.heatmap-color-legend-rect').data(valuesRange);\n\n      legendRects\n        .enter()\n        .append('rect')\n        .attr('x', (d) => d)\n        .attr('y', 0)\n        .attr('width', rangeStep + 1) // Overlap rectangles to prevent gaps\n        .attr('height', legendHeight)\n        .attr('stroke-width', 0)\n        .attr('fill', (d) => colorScale(d));\n    }\n  }\n}\n\nfunction drawSimpleOpacityLegend(elem: JQuery, options: { colorScale: string; exponent: number; cardColor: string }) {\n  const legendElem = $(elem).find('svg');\n  const legendDomElement = legendElem.get(0);\n  if (legendDomElement) {\n    clearLegend(elem);\n\n    const legend = d3.select(legendDomElement);\n    const legendWidth = Math.floor(legendElem.outerWidth() ?? 30);\n    const legendHeight = legendElem.attr('height') as any;\n\n    if (legendWidth) {\n      let legendOpacityScale: any;\n      if (options.colorScale === 'linear') {\n        legendOpacityScale = d3.scaleLinear().domain([0, legendWidth]).range([0, 1]);\n      } else if (options.colorScale === 'sqrt') {\n        legendOpacityScale = d3.scalePow().exponent(options.exponent).domain([0, legendWidth]).range([0, 1]);\n      }\n\n      const rangeStep = 10;\n      const valuesRange = d3.range(0, legendWidth, rangeStep);\n      const legendRects = legend.selectAll('.heatmap-opacity-legend-rect').data(valuesRange);\n\n      legendRects\n        .enter()\n        .append('rect')\n        .attr('x', (d) => d)\n        .attr('y', 0)\n        .attr('width', rangeStep)\n        .attr('height', legendHeight)\n        .attr('stroke-width', 0)\n        .attr('fill', config.theme2.visualization.getColorByName(options.cardColor))\n        .style('opacity', (d) => legendOpacityScale(d));\n    }\n  }\n}\n\nfunction clearLegend(elem: JQuery) {\n  const legendElem = $(elem).find('svg');\n  legendElem.empty();\n}\n\nfunction getSvgElemX(elem: JQuery) {\n  const svgElem: any = elem.get(0) as any;\n  if (svgElem && svgElem.x && svgElem.x.baseVal) {\n    return svgElem.x.baseVal.value;\n  } else {\n    return 0;\n  }\n}\n\nfunction getSvgElemHeight(elem: JQuery<any>) {\n  const svgElem: any = elem.get(0);\n  if (svgElem && svgElem.height && svgElem.height.baseVal) {\n    return svgElem.height.baseVal.value;\n  } else {\n    return 0;\n  }\n}\n\nfunction buildLegendTicks(rangeFrom: number, rangeTo: number, maxValue: number, minValue: number) {\n  const range = rangeTo - rangeFrom;\n  const tickStepSize = tickStep(rangeFrom, rangeTo, 3);\n  const ticksNum = Math.ceil(range / tickStepSize);\n  const firstTick = getFirstCloseTick(rangeFrom, tickStepSize);\n  let ticks = [];\n\n  for (let i = 0; i < ticksNum; i++) {\n    const current = firstTick + tickStepSize * i;\n    // Add user-defined min and max if it had been set\n    if (isValueCloseTo(minValue, current, tickStepSize)) {\n      ticks.push(minValue);\n      continue;\n    } else if (minValue < current) {\n      ticks.push(minValue);\n    }\n    if (isValueCloseTo(maxValue, current, tickStepSize)) {\n      ticks.push(maxValue);\n      continue;\n    } else if (maxValue < current) {\n      ticks.push(maxValue);\n    }\n    ticks.push(current);\n  }\n  if (!isValueCloseTo(maxValue, rangeTo, tickStepSize)) {\n    ticks.push(maxValue);\n  }\n  ticks.push(rangeTo);\n  ticks = sortBy(uniq(ticks));\n  return ticks;\n}\n\nfunction isValueCloseTo(val: number, valueTo: number, step: number) {\n  const diff = Math.abs(val - valueTo);\n  return diff < step * 0.3;\n}\n\nfunction getFirstCloseTick(minValue: number, step: number) {\n  if (minValue < 0) {\n    return Math.floor(minValue / step) * step;\n  }\n  return 0;\n}\n","export class AxesEditorCtrl {\n  panel: any;\n  panelCtrl: any;\n  logScales: any;\n  dataFormats: any;\n  yBucketBoundModes: any;\n\n  /** @ngInject */\n  constructor($scope: any, uiSegmentSrv: any) {\n    $scope.editor = this;\n    this.panelCtrl = $scope.ctrl;\n    this.panel = this.panelCtrl.panel;\n\n    this.logScales = {\n      linear: 1,\n      'log (base 2)': 2,\n      'log (base 10)': 10,\n      'log (base 32)': 32,\n      'log (base 1024)': 1024,\n    };\n\n    this.dataFormats = {\n      'Time series': 'timeseries',\n      'Time series buckets': 'tsbuckets',\n    };\n\n    this.yBucketBoundModes = {\n      Auto: 'auto',\n      Upper: 'upper',\n      Lower: 'lower',\n      Middle: 'middle',\n    };\n  }\n\n  setUnitFormat = (unit: string) => {\n    this.panel.yAxis.format = unit;\n    this.panelCtrl.render();\n  };\n}\n\n/** @ngInject */\nexport function axesEditor() {\n  'use strict';\n  return {\n    restrict: 'E',\n    scope: true,\n    templateUrl: 'public/app/plugins/panel/heatmap/partials/axes_editor.html',\n    controller: AxesEditorCtrl,\n  };\n}\n","export class HeatmapDisplayEditorCtrl {\n  panel: any;\n  panelCtrl: any;\n\n  /** @ngInject */\n  constructor($scope: any) {\n    $scope.editor = this;\n    this.panelCtrl = $scope.ctrl;\n    this.panel = this.panelCtrl.panel;\n  }\n}\n\n/** @ngInject */\nexport function heatmapDisplayEditor() {\n  'use strict';\n  return {\n    restrict: 'E',\n    scope: true,\n    templateUrl: 'public/app/plugins/panel/heatmap/partials/display_editor.html',\n    controller: HeatmapDisplayEditorCtrl,\n  };\n}\n","import { concat, forEach, isEmpty, isEqual, isNumber, sortBy } from 'lodash';\n\nimport { TimeSeries } from 'app/core/core';\n\nimport { Bucket, HeatmapCard, HeatmapCardStats, YBucket, XBucket } from './types';\n\nconst VALUE_INDEX = 0;\nconst TIME_INDEX = 1;\n\n/**\n * Convert histogram represented by the list of series to heatmap object.\n * @param seriesList List of time series\n */\nfunction histogramToHeatmap(seriesList: TimeSeries[]) {\n  const heatmap: any = {};\n\n  for (let i = 0; i < seriesList.length; i++) {\n    const series = seriesList[i];\n    const bound = i;\n    if (isNaN(bound)) {\n      return heatmap;\n    }\n\n    for (const point of series.datapoints) {\n      const count = point[VALUE_INDEX];\n      const time = point[TIME_INDEX];\n\n      if (!isNumber(count)) {\n        continue;\n      }\n\n      let bucket = heatmap[time];\n      if (!bucket) {\n        bucket = heatmap[time] = { x: time, buckets: {} };\n      }\n\n      bucket.buckets[bound] = {\n        y: bound,\n        count: count,\n        bounds: {\n          top: null,\n          bottom: bound,\n        },\n        values: [],\n        points: [],\n      };\n    }\n  }\n\n  return heatmap;\n}\n\n/**\n * Sort series representing histogram by label value.\n */\nfunction sortSeriesByLabel(s1: { label: string }, s2: { label: string }) {\n  let label1, label2;\n\n  try {\n    // fail if not integer. might happen with bad queries\n    label1 = parseHistogramLabel(s1.label);\n    label2 = parseHistogramLabel(s2.label);\n  } catch (err) {\n    console.error(err instanceof Error ? err.message : err);\n    return 0;\n  }\n\n  if (label1 > label2) {\n    return 1;\n  }\n\n  if (label1 < label2) {\n    return -1;\n  }\n\n  return 0;\n}\n\nfunction parseHistogramLabel(label: string): number {\n  if (label === '+Inf' || label === 'inf') {\n    return +Infinity;\n  }\n  const value = Number(label);\n  if (isNaN(value)) {\n    throw new Error(`Error parsing histogram label: ${label} is not a number`);\n  }\n  return value;\n}\n\n/**\n * Convert buckets into linear array of \"cards\" - objects, represented heatmap elements.\n * @param  {Object} buckets\n * @returns {Object}          Array of \"card\" objects and stats\n */\nfunction convertToCards(buckets: any, hideZero = false): { cards: HeatmapCard[]; cardStats: HeatmapCardStats } {\n  let min = 0,\n    max = 0;\n  const cards: HeatmapCard[] = [];\n  forEach(buckets, (xBucket) => {\n    forEach(xBucket.buckets, (yBucket) => {\n      const card: HeatmapCard = {\n        x: xBucket.x,\n        y: yBucket.y,\n        yBounds: yBucket.bounds,\n        values: yBucket.values,\n        count: yBucket.count,\n      };\n      if (!hideZero || card.count !== 0) {\n        cards.push(card);\n      }\n\n      if (cards.length === 1) {\n        min = yBucket.count;\n        max = yBucket.count;\n      }\n\n      min = yBucket.count < min ? yBucket.count : min;\n      max = yBucket.count > max ? yBucket.count : max;\n    });\n  });\n\n  const cardStats = { min, max };\n  return { cards, cardStats };\n}\n\n/**\n * Special method for log scales. When series converted into buckets with log scale,\n * for simplification, 0 values are converted into 0, not into -Infinity. On the other hand, we mean\n * that all values less than series minimum, is 0 values, and we create special \"minimum\" bucket for\n * that values (actually, there're no values less than minimum, so this bucket is empty).\n *  8-16|    | ** |    |  * |  **|\n *   4-8|  * |*  *|*   |** *| *  |\n *   2-4| * *|    | ***|    |*   |\n *   1-2|*   |    |    |    |    | This bucket contains minimum series value\n * 0.5-1|____|____|____|____|____| This bucket should be displayed as 0 on graph\n *     0|____|____|____|____|____| This bucket is for 0 values (should actually be -Infinity)\n * So we should merge two bottom buckets into one (0-value bucket).\n *\n * @param  {Object} buckets  Heatmap buckets\n * @param  {Number} minValue Minimum series value\n * @returns {Object}          Transformed buckets\n */\nfunction mergeZeroBuckets(buckets: any, minValue: number) {\n  forEach(buckets, (xBucket) => {\n    const yBuckets = xBucket.buckets;\n\n    const emptyBucket: any = {\n      bounds: { bottom: 0, top: 0 },\n      values: [],\n      points: [],\n      count: 0,\n    };\n\n    const nullBucket = yBuckets[0] || emptyBucket;\n    const minBucket = yBuckets[minValue] || emptyBucket;\n\n    const newBucket: any = {\n      y: 0,\n      bounds: { bottom: minValue, top: minBucket.bounds.top || minValue },\n      values: [],\n      points: [],\n      count: 0,\n    };\n\n    newBucket.points = nullBucket.points.concat(minBucket.points);\n    newBucket.values = nullBucket.values.concat(minBucket.values);\n    newBucket.count = newBucket.values.length;\n\n    if (newBucket.count === 0) {\n      return;\n    }\n\n    delete yBuckets[minValue];\n    yBuckets[0] = newBucket;\n  });\n\n  return buckets;\n}\n\n/**\n * Convert set of time series into heatmap buckets\n * @returns {Object}    Heatmap object:\n * {\n *   xBucketBound_1: {\n *     x: xBucketBound_1,\n *     buckets: {\n *       yBucketBound_1: {\n *         y: yBucketBound_1,\n *         bounds: {bottom, top}\n *         values: [val_1, val_2, ..., val_K],\n *         points: [[val_Y, val_X, series_name], ..., [...]],\n *         seriesStat: {seriesName_1: val_1, seriesName_2: val_2}\n *       },\n *       ...\n *       yBucketBound_M: {}\n *     },\n *     values: [val_1, val_2, ..., val_K],\n *     points: [\n *       [val_Y, val_X, series_name], (point_1)\n *       ...\n *       [...] (point_K)\n *     ]\n *   },\n *   xBucketBound_2: {},\n *   ...\n *   xBucketBound_N: {}\n * }\n */\nfunction convertToHeatMap(seriesList: TimeSeries[], yBucketSize: number, xBucketSize: number, logBase = 1) {\n  const heatmap = {};\n\n  for (const series of seriesList) {\n    const datapoints = series.datapoints;\n    const seriesName = series.label;\n\n    // Slice series into X axis buckets\n    // |    | ** |    |  * |  **|\n    // |  * |*  *|*   |** *| *  |\n    // |** *|    | ***|    |*   |\n    // |____|____|____|____|____|_\n    //\n    forEach(datapoints, (point) => {\n      const bucketBound = getBucketBound(point[TIME_INDEX], xBucketSize);\n      pushToXBuckets(heatmap, point, bucketBound, seriesName);\n    });\n  }\n\n  // Slice X axis buckets into Y (value) buckets\n  // |  **|     |2|,\n  // | *  | --\\ |1|,\n  // |*   | --/ |1|,\n  // |____|     |0|\n  //\n  forEach(heatmap, (xBucket: any) => {\n    if (logBase !== 1) {\n      xBucket.buckets = convertToLogScaleValueBuckets(xBucket, yBucketSize, logBase);\n    } else {\n      xBucket.buckets = convertToValueBuckets(xBucket, yBucketSize);\n    }\n  });\n\n  return heatmap;\n}\n\nfunction pushToXBuckets(buckets: any, point: any[], bucketNum: number, seriesName: string) {\n  const value = point[VALUE_INDEX];\n  if (value === null || value === undefined || isNaN(value)) {\n    return;\n  }\n\n  // Add series name to point for future identification\n  const pointExt = concat(point, seriesName);\n\n  if (buckets[bucketNum] && buckets[bucketNum].values) {\n    buckets[bucketNum].values.push(value);\n    buckets[bucketNum].points.push(pointExt);\n  } else {\n    buckets[bucketNum] = {\n      x: bucketNum,\n      values: [value],\n      points: [pointExt],\n    };\n  }\n}\n\nfunction pushToYBuckets(\n  buckets: Bucket,\n  bucketNum: number,\n  value: any,\n  point: string[],\n  bounds: { bottom: number; top: number }\n) {\n  let count = 1;\n  // Use the 3rd argument as scale/count\n  if (point.length > 3) {\n    count = parseInt(point[2], 10);\n  }\n  if (buckets[bucketNum]) {\n    buckets[bucketNum].values.push(value);\n    buckets[bucketNum].points?.push(point);\n    buckets[bucketNum].count += count;\n  } else {\n    buckets[bucketNum] = {\n      y: bucketNum,\n      bounds: bounds,\n      values: [value],\n      points: [point],\n      count: count,\n    };\n  }\n}\n\nfunction getValueBucketBound(value: any, yBucketSize: number, logBase: number) {\n  if (logBase === 1) {\n    return getBucketBound(value, yBucketSize);\n  } else {\n    return getLogScaleBucketBound(value, yBucketSize, logBase);\n  }\n}\n\n/**\n * Find bucket for given value (for linear scale)\n */\nfunction getBucketBounds(value: number, bucketSize: number) {\n  let bottom, top;\n  bottom = Math.floor(value / bucketSize) * bucketSize;\n  top = (Math.floor(value / bucketSize) + 1) * bucketSize;\n\n  return { bottom, top };\n}\n\nfunction getBucketBound(value: number, bucketSize: number) {\n  const bounds = getBucketBounds(value, bucketSize);\n  return bounds.bottom;\n}\n\nfunction convertToValueBuckets(xBucket: { values: any; points: any }, bucketSize: number) {\n  const values = xBucket.values;\n  const points = xBucket.points;\n  const buckets = {};\n\n  forEach(values, (val, index) => {\n    const bounds = getBucketBounds(val, bucketSize);\n    const bucketNum = bounds.bottom;\n    pushToYBuckets(buckets, bucketNum, val, points[index], bounds);\n  });\n\n  return buckets;\n}\n\n/**\n * Find bucket for given value (for log scales)\n */\nfunction getLogScaleBucketBounds(value: number, yBucketSplitFactor: number, logBase: number) {\n  let top, bottom;\n  if (value === 0) {\n    return { bottom: 0, top: 0 };\n  }\n\n  const valueLog = logp(value, logBase);\n  let pow, powTop;\n  if (yBucketSplitFactor === 1 || !yBucketSplitFactor) {\n    pow = Math.floor(valueLog);\n    powTop = pow + 1;\n  } else {\n    const additionalBucketSize = 1 / yBucketSplitFactor;\n    let additionalLog = valueLog - Math.floor(valueLog);\n    additionalLog = Math.floor(additionalLog / additionalBucketSize) * additionalBucketSize;\n    pow = Math.floor(valueLog) + additionalLog;\n    powTop = pow + additionalBucketSize;\n  }\n  bottom = Math.pow(logBase, pow);\n  top = Math.pow(logBase, powTop);\n\n  return { bottom, top };\n}\n\nfunction getLogScaleBucketBound(value: number, yBucketSplitFactor: number, logBase: number) {\n  const bounds = getLogScaleBucketBounds(value, yBucketSplitFactor, logBase);\n  return bounds.bottom;\n}\n\nfunction convertToLogScaleValueBuckets(\n  xBucket: { values: any; points: any },\n  yBucketSplitFactor: number,\n  logBase: number\n) {\n  const values = xBucket.values;\n  const points = xBucket.points;\n\n  const buckets = {};\n  forEach(values, (val, index) => {\n    const bounds = getLogScaleBucketBounds(val, yBucketSplitFactor, logBase);\n    const bucketNum = bounds.bottom;\n    pushToYBuckets(buckets, bucketNum, val, points[index], bounds);\n  });\n\n  return buckets;\n}\n\n/**\n * Logarithm for custom base\n * @param value\n * @param base logarithm base\n */\nfunction logp(value: number, base: number) {\n  return Math.log(value) / Math.log(base);\n}\n\n/**\n * Calculate size of Y bucket from given buckets bounds.\n * @param bounds Array of Y buckets bounds\n * @param logBase Logarithm base\n */\nfunction calculateBucketSize(bounds: number[], logBase = 1): number {\n  let bucketSize = Infinity;\n\n  if (bounds.length === 0) {\n    return 0;\n  } else if (bounds.length === 1) {\n    return bounds[0];\n  } else {\n    bounds = sortBy(bounds);\n    for (let i = 1; i < bounds.length; i++) {\n      const distance = getDistance(bounds[i], bounds[i - 1], logBase);\n      bucketSize = distance < bucketSize ? distance : bucketSize;\n    }\n  }\n\n  return bucketSize;\n}\n\n/**\n * Calculate distance between two numbers in given scale (linear or logarithmic).\n * @param a\n * @param b\n * @param logBase\n */\nfunction getDistance(a: number, b: number, logBase = 1): number {\n  if (logBase === 1) {\n    // Linear distance\n    return Math.abs(b - a);\n  } else {\n    // logarithmic distance\n    const ratio = Math.max(a, b) / Math.min(a, b);\n    return logp(ratio, logBase);\n  }\n}\n\n/**\n * Compare two heatmap data objects\n * @param objA\n * @param objB\n */\nfunction isHeatmapDataEqual(objA: any, objB: any): boolean {\n  let isEql = !emptyXOR(objA, objB);\n\n  forEach(objA, (xBucket: XBucket, x) => {\n    if (objB[x]) {\n      if (emptyXOR(xBucket.buckets, objB[x].buckets)) {\n        isEql = false;\n        return false;\n      }\n\n      forEach(xBucket.buckets, (yBucket: YBucket, y) => {\n        if (objB[x].buckets && objB[x].buckets[y]) {\n          if (objB[x].buckets[y].values) {\n            isEql = isEqual(sortBy(yBucket.values), sortBy(objB[x].buckets[y].values));\n            if (!isEql) {\n              return false;\n            } else {\n              return true;\n            }\n          } else {\n            isEql = false;\n            return false;\n          }\n        } else {\n          isEql = false;\n          return false;\n        }\n      });\n\n      if (!isEql) {\n        return false;\n      } else {\n        return true;\n      }\n    } else {\n      isEql = false;\n      return false;\n    }\n  });\n\n  return isEql;\n}\n\nfunction emptyXOR(foo: any, bar: any): boolean {\n  return (isEmpty(foo) || isEmpty(bar)) && !(isEmpty(foo) && isEmpty(bar));\n}\n\nexport {\n  convertToHeatMap,\n  histogramToHeatmap,\n  convertToCards,\n  mergeZeroBuckets,\n  getValueBucketBound,\n  isHeatmapDataEqual,\n  calculateBucketSize,\n  sortSeriesByLabel,\n};\n","import * as d3 from 'd3';\nimport $ from 'jquery';\nimport { filter, find, isNumber, map, reduce } from 'lodash';\n\nimport { getValueFormat, formattedValueToString } from '@grafana/data';\n\nimport { getValueBucketBound } from './heatmap_data_converter';\n\nconst TOOLTIP_PADDING_X = 30;\nconst TOOLTIP_PADDING_Y = 5;\nconst HISTOGRAM_WIDTH = 160;\nconst HISTOGRAM_HEIGHT = 40;\n\nexport class HeatmapTooltip {\n  tooltip: any;\n  scope: any;\n  dashboard: any;\n  panelCtrl: any;\n  panel: any;\n  heatmapPanel: any;\n  mouseOverBucket: boolean;\n  originalFillColor: any;\n\n  constructor(elem: JQuery, scope: any) {\n    this.scope = scope;\n    this.dashboard = scope.ctrl.dashboard;\n    this.panelCtrl = scope.ctrl;\n    this.panel = scope.ctrl.panel;\n    this.heatmapPanel = elem;\n    this.mouseOverBucket = false;\n    this.originalFillColor = null;\n\n    elem.on('mouseleave', this.onMouseLeave.bind(this));\n  }\n\n  onMouseLeave() {\n    this.destroy();\n  }\n\n  onMouseMove(e: any) {\n    if (!this.panel.tooltip.show) {\n      return;\n    }\n\n    this.move(e);\n  }\n\n  add() {\n    this.tooltip = d3.select('body').append('div').attr('class', 'heatmap-tooltip graph-tooltip grafana-tooltip');\n  }\n\n  destroy() {\n    if (this.tooltip) {\n      this.tooltip.remove();\n    }\n\n    this.tooltip = null;\n  }\n\n  show(pos: { panelRelY: any }, data: any) {\n    if (!this.panel.tooltip.show || !data) {\n      return;\n    }\n    // shared tooltip mode\n    if (pos.panelRelY) {\n      return;\n    }\n\n    const { xBucketIndex, yBucketIndex } = this.getBucketIndexes(pos, data);\n\n    if (!data.buckets[xBucketIndex]) {\n      this.destroy();\n      return;\n    }\n\n    if (!this.tooltip) {\n      this.add();\n    }\n\n    let boundBottom, boundTop, valuesNumber;\n    const xData = data.buckets[xBucketIndex];\n    // Search in special 'zero' bucket also\n    const yData: any = find(xData.buckets, (bucket, bucketIndex) => {\n      return bucket.bounds.bottom === yBucketIndex || bucketIndex === yBucketIndex.toString();\n    });\n\n    const tooltipTimeFormat = 'YYYY-MM-DD HH:mm:ss';\n    const time = this.dashboard.formatDate(xData.x, tooltipTimeFormat);\n\n    // Decimals override. Code from panel/graph/graph.ts\n    let countValueFormatter, bucketBoundFormatter;\n    if (isNumber(this.panel.tooltipDecimals)) {\n      countValueFormatter = this.countValueFormatter(this.panel.tooltipDecimals, null);\n      bucketBoundFormatter = this.panelCtrl.tickValueFormatter(this.panelCtrl.decimals, null);\n    } else {\n      // auto decimals\n      // legend and tooltip gets one more decimal precision\n      // than graph legend ticks\n      const decimals = (this.panelCtrl.decimals || -1) + 1;\n      countValueFormatter = this.countValueFormatter(decimals, this.panelCtrl.scaledDecimals + 2);\n      bucketBoundFormatter = this.panelCtrl.tickValueFormatter(decimals, this.panelCtrl.scaledDecimals + 2);\n    }\n\n    let tooltipHtml = `<div class=\"graph-tooltip-time\">${time}</div>\n      <div class=\"heatmap-histogram\"></div>`;\n\n    if (yData) {\n      if (yData.bounds) {\n        if (data.tsBuckets) {\n          // Use Y-axis labels\n          const tickFormatter = (valIndex: string | number) => {\n            return data.tsBucketsFormatted ? data.tsBucketsFormatted[valIndex] : data.tsBuckets[valIndex];\n          };\n\n          boundBottom = tickFormatter(yBucketIndex);\n          if (this.panel.yBucketBound !== 'middle') {\n            boundTop = yBucketIndex < data.tsBuckets.length - 1 ? tickFormatter(yBucketIndex + 1) : '';\n          }\n        } else {\n          // Display 0 if bucket is a special 'zero' bucket\n          const bottom = yData.y ? yData.bounds.bottom : 0;\n          boundBottom = bucketBoundFormatter(bottom);\n          boundTop = bucketBoundFormatter(yData.bounds.top);\n        }\n        valuesNumber = countValueFormatter(yData.count);\n        const boundStr = boundTop && boundBottom ? `${boundBottom} - ${boundTop}` : boundBottom || boundTop;\n        tooltipHtml += `<div>\n          bucket: <b>${boundStr}</b> <br>\n          count: <b>${valuesNumber}</b> <br>\n        </div>`;\n      } else {\n        // currently no bounds for pre bucketed data\n        tooltipHtml += `<div>count: <b>${yData.count}</b><br></div>`;\n      }\n    } else {\n      if (!this.panel.tooltip.showHistogram) {\n        this.destroy();\n        return;\n      }\n      boundBottom = yBucketIndex;\n      boundTop = '';\n      valuesNumber = 0;\n    }\n\n    this.tooltip.html(tooltipHtml);\n\n    if (this.panel.tooltip.showHistogram) {\n      this.addHistogram(xData);\n    }\n\n    this.move(pos);\n  }\n\n  getBucketIndexes(pos: { panelRelY?: any; x?: any; y?: any }, data: any) {\n    const xBucketIndex = this.getXBucketIndex(pos.x, data);\n    const yBucketIndex = this.getYBucketIndex(pos.y, data);\n    return { xBucketIndex, yBucketIndex };\n  }\n\n  getXBucketIndex(x: number, data: { buckets: any; xBucketSize: number }) {\n    // First try to find X bucket by checking x pos is in the\n    // [bucket.x, bucket.x + xBucketSize] interval\n    const xBucket: any = find(data.buckets, (bucket) => {\n      return x > bucket.x && x - bucket.x <= data.xBucketSize;\n    });\n    return xBucket ? xBucket.x : getValueBucketBound(x, data.xBucketSize, 1);\n  }\n\n  getYBucketIndex(y: number, data: { tsBuckets: any; yBucketSize: number }) {\n    if (data.tsBuckets) {\n      return Math.floor(y);\n    }\n    const yBucketIndex = getValueBucketBound(y, data.yBucketSize, this.panel.yAxis.logBase);\n    return yBucketIndex;\n  }\n\n  getSharedTooltipPos(pos: { pageX: any; x: any; pageY: any; panelRelY: number }) {\n    // get pageX from position on x axis and pageY from relative position in original panel\n    pos.pageX = this.heatmapPanel.offset().left + this.scope.xScale(pos.x);\n    pos.pageY = this.heatmapPanel.offset().top + this.scope.chartHeight * pos.panelRelY;\n    return pos;\n  }\n\n  addHistogram(data: { x: string | number }) {\n    const xBucket = this.scope.ctrl.data.buckets[data.x];\n    const yBucketSize = this.scope.ctrl.data.yBucketSize;\n    let min: number, max: number, ticks: number;\n    if (this.scope.ctrl.data.tsBuckets) {\n      min = 0;\n      max = this.scope.ctrl.data.tsBuckets.length - 1;\n      ticks = this.scope.ctrl.data.tsBuckets.length;\n    } else {\n      min = this.scope.ctrl.data.yAxis.min;\n      max = this.scope.ctrl.data.yAxis.max;\n      ticks = this.scope.ctrl.data.yAxis.ticks;\n    }\n    let histogramData = map(xBucket.buckets, (bucket) => {\n      const count = bucket.count !== undefined ? bucket.count : bucket.values.length;\n      return [bucket.bounds.bottom, count];\n    });\n    histogramData = filter(histogramData, (d) => {\n      return d[0] >= min && d[0] <= max;\n    });\n\n    const scale = this.scope.yScale.copy();\n    const histXScale = scale.domain([min, max]).range([0, HISTOGRAM_WIDTH]);\n\n    let barWidth: number;\n    if (this.panel.yAxis.logBase === 1) {\n      barWidth = Math.floor((HISTOGRAM_WIDTH / (max - min)) * yBucketSize * 0.9);\n    } else {\n      const barNumberFactor = yBucketSize ? yBucketSize : 1;\n      barWidth = Math.floor((HISTOGRAM_WIDTH / ticks / barNumberFactor) * 0.9);\n    }\n    barWidth = Math.max(barWidth, 1);\n\n    // Normalize histogram Y axis\n    const histogramDomain = reduce(\n      map(histogramData, (d) => d[1]),\n      (sum, val) => sum + val,\n      0\n    );\n    const histYScale = d3.scaleLinear().domain([0, histogramDomain]).range([0, HISTOGRAM_HEIGHT]);\n\n    const histogram = this.tooltip\n      .select('.heatmap-histogram')\n      .append('svg')\n      .attr('width', HISTOGRAM_WIDTH)\n      .attr('height', HISTOGRAM_HEIGHT);\n\n    histogram\n      .selectAll('.bar')\n      .data(histogramData)\n      .enter()\n      .append('rect')\n      .attr('x', (d: any[]) => {\n        return histXScale(d[0]);\n      })\n      .attr('width', barWidth)\n      .attr('y', (d: any[]) => {\n        return HISTOGRAM_HEIGHT - histYScale(d[1]);\n      })\n      .attr('height', (d: any[]) => {\n        return histYScale(d[1]);\n      });\n  }\n\n  move(pos: { panelRelY?: any; pageX?: any; pageY?: any }) {\n    if (!this.tooltip) {\n      return;\n    }\n\n    const elem = $(this.tooltip.node())[0];\n    const tooltipWidth = elem.clientWidth;\n    const tooltipHeight = elem.clientHeight;\n\n    let left = pos.pageX + TOOLTIP_PADDING_X;\n    let top = pos.pageY + TOOLTIP_PADDING_Y;\n\n    if (pos.pageX + tooltipWidth + 40 > window.innerWidth) {\n      left = pos.pageX - tooltipWidth - TOOLTIP_PADDING_X;\n    }\n\n    if (pos.pageY - window.pageYOffset + tooltipHeight + 20 > window.innerHeight) {\n      top = pos.pageY - tooltipHeight - TOOLTIP_PADDING_Y;\n    }\n\n    return this.tooltip.style('left', left + 'px').style('top', top + 'px');\n  }\n\n  countValueFormatter(decimals: number, scaledDecimals: any = null) {\n    const fmt = getValueFormat('short');\n    return (value: number) => {\n      return formattedValueToString(fmt(value, decimals, scaledDecimals));\n    };\n  }\n}\n","import * as d3 from 'd3';\nimport $ from 'jquery';\nimport { find, isEmpty, isNaN, isNil, isString, map, max, min, toNumber } from 'lodash';\n\nimport {\n  dateTimeFormat,\n  formattedValueToString,\n  getValueFormat,\n  LegacyGraphHoverClearEvent,\n  LegacyGraphHoverEvent,\n  PanelEvents,\n  toUtc,\n} from '@grafana/data';\nimport { graphTimeFormat } from '@grafana/ui';\nimport { config } from 'app/core/config';\nimport { contextSrv } from 'app/core/core';\nimport * as ticksUtils from 'app/core/utils/ticks';\n\nimport { getColorScale, getOpacityScale } from './color_scale';\nimport { mergeZeroBuckets } from './heatmap_data_converter';\nimport { HeatmapTooltip } from './heatmap_tooltip';\n\nconst MIN_CARD_SIZE = 1,\n  CARD_PADDING = 1,\n  CARD_ROUND = 0,\n  DATA_RANGE_WIDING_FACTOR = 1.2,\n  DEFAULT_X_TICK_SIZE_PX = 100,\n  DEFAULT_Y_TICK_SIZE_PX = 22.5,\n  X_AXIS_TICK_PADDING = 10,\n  Y_AXIS_TICK_PADDING = 5,\n  MIN_SELECTION_WIDTH = 2;\n\nexport default function rendering(scope: any, elem: any, attrs: any, ctrl: any) {\n  return new HeatmapRenderer(scope, elem, attrs, ctrl);\n}\nexport class HeatmapRenderer {\n  width = 200;\n  height = 200;\n  yScale: any;\n  xScale: any;\n  chartWidth = 0;\n  chartHeight = 0;\n  chartTop = 0;\n  chartBottom = 0;\n  yAxisWidth = 0;\n  xAxisHeight = 0;\n  cardPadding = 0;\n  cardRound = 0;\n  cardWidth = 0;\n  cardHeight = 0;\n  colorScale: any;\n  opacityScale: any;\n  mouseUpHandler: any;\n  data: any;\n  panel: any;\n  $heatmap: any;\n  tooltip: HeatmapTooltip;\n  heatmap: any;\n  timeRange: any;\n\n  selection: any;\n  padding: any;\n  margin: any;\n  dataRangeWidingFactor: number;\n\n  hoverEvent: LegacyGraphHoverEvent;\n\n  constructor(private scope: any, private elem: any, attrs: any, private ctrl: any) {\n    // $heatmap is JQuery object, but heatmap is D3\n    this.$heatmap = this.elem.find('.heatmap-panel');\n    this.tooltip = new HeatmapTooltip(this.$heatmap, this.scope);\n\n    this.selection = {\n      active: false,\n      x1: -1,\n      x2: -1,\n    };\n\n    this.padding = { left: 0, right: 0, top: 0, bottom: 0 };\n    this.margin = { left: 25, right: 15, top: 10, bottom: 20 };\n    this.dataRangeWidingFactor = DATA_RANGE_WIDING_FACTOR;\n    this.ctrl.events.on(PanelEvents.render, this.onRender.bind(this));\n    this.ctrl.tickValueFormatter = this.tickValueFormatter.bind(this);\n\n    /////////////////////////////\n    // Selection and crosshair //\n    /////////////////////////////\n\n    // Shared crosshair and tooltip\n    this.ctrl.dashboard.events.on(LegacyGraphHoverEvent.type, this.onGraphHover.bind(this), this.scope);\n    this.ctrl.dashboard.events.on(LegacyGraphHoverClearEvent.type, this.onGraphHoverClear.bind(this), this.scope);\n\n    // Register selection listeners\n    this.$heatmap.on('mousedown', this.onMouseDown.bind(this));\n    this.$heatmap.on('mousemove', this.onMouseMove.bind(this));\n    this.$heatmap.on('mouseleave', this.onMouseLeave.bind(this));\n\n    this.hoverEvent = new LegacyGraphHoverEvent({ pos: {}, point: {}, panel: this.panel });\n  }\n\n  onGraphHoverClear() {\n    this.clearCrosshair();\n  }\n\n  onGraphHover(event: { pos: any }) {\n    this.drawSharedCrosshair(event.pos);\n  }\n\n  onRender() {\n    this.render();\n    this.ctrl.renderingCompleted();\n  }\n\n  setElementHeight() {\n    try {\n      let height = this.ctrl.height || this.panel.height || this.ctrl.row.height;\n      if (isString(height)) {\n        height = parseInt(height.replace('px', ''), 10);\n      }\n\n      height -= this.panel.legend.show ? 28 : 11; // bottom padding and space for legend\n\n      this.$heatmap.css('height', height + 'px');\n\n      return true;\n    } catch (e) {\n      // IE throws errors sometimes\n      return false;\n    }\n  }\n\n  getYAxisWidth(elem: any) {\n    const panelYAxisWidth = this.getPanelYAxisWidth();\n    if (panelYAxisWidth !== null) {\n      return panelYAxisWidth + Y_AXIS_TICK_PADDING;\n    }\n\n    const axisText = elem.selectAll('.axis-y text').nodes();\n    const maxTextWidth = max(\n      map(axisText, (text) => {\n        // Use SVG getBBox method\n        return text.getBBox().width;\n      })\n    );\n\n    return maxTextWidth;\n  }\n\n  getXAxisHeight(elem: any) {\n    const axisLine = elem.select('.axis-x line');\n    if (!axisLine.empty()) {\n      const axisLinePosition = parseFloat(elem.select('.axis-x line').attr('y2'));\n      const canvasWidth = parseFloat(elem.attr('height'));\n      return canvasWidth - axisLinePosition;\n    } else {\n      // Default height\n      return 30;\n    }\n  }\n\n  addXAxis() {\n    this.scope.xScale = this.xScale = d3\n      .scaleTime()\n      .domain([this.timeRange.from, this.timeRange.to])\n      .range([0, this.chartWidth]);\n\n    const ticks = this.chartWidth / DEFAULT_X_TICK_SIZE_PX;\n    const format = graphTimeFormat(ticks, this.timeRange.from.valueOf(), this.timeRange.to.valueOf());\n    const timeZone = this.ctrl.dashboard.getTimezone();\n    const formatter = (date: d3.AxisDomain) =>\n      dateTimeFormat(date.valueOf(), {\n        format: format,\n        timeZone: timeZone,\n      });\n\n    const xAxis = d3\n      .axisBottom(this.xScale)\n      .ticks(ticks)\n      .tickFormat(formatter)\n      .tickPadding(X_AXIS_TICK_PADDING)\n      .tickSize(this.chartHeight);\n\n    const posY = this.margin.top;\n    const posX = this.yAxisWidth;\n    this.heatmap\n      .append('g')\n      .attr('class', 'axis axis-x')\n      .attr('transform', 'translate(' + posX + ',' + posY + ')')\n      .call(xAxis);\n\n    // Remove horizontal line in the top of axis labels (called domain in d3)\n    this.heatmap.select('.axis-x').select('.domain').remove();\n  }\n\n  addYAxis() {\n    let ticks = Math.ceil(this.chartHeight / DEFAULT_Y_TICK_SIZE_PX);\n    let tickInterval = ticksUtils.tickStep(this.data.heatmapStats.min, this.data.heatmapStats.max, ticks);\n    let { yMin, yMax } = this.wideYAxisRange(this.data.heatmapStats.min, this.data.heatmapStats.max, tickInterval);\n\n    // Rewrite min and max if it have been set explicitly\n    yMin = this.panel.yAxis.min !== null ? this.panel.yAxis.min : yMin;\n    yMax = this.panel.yAxis.max !== null ? this.panel.yAxis.max : yMax;\n\n    // Adjust ticks after Y range widening\n    tickInterval = ticksUtils.tickStep(yMin, yMax, ticks);\n    ticks = Math.ceil((yMax - yMin) / tickInterval);\n\n    const decimalsAuto = ticksUtils.getPrecision(tickInterval);\n    let decimals = this.panel.yAxis.decimals === null ? decimalsAuto : this.panel.yAxis.decimals;\n    // Calculate scaledDecimals for log scales using tick size (as in jquery.flot.js)\n    const flotTickSize = ticksUtils.getFlotTickSize(yMin, yMax, ticks, decimalsAuto);\n    const scaledDecimals = ticksUtils.getScaledDecimals(decimals, flotTickSize);\n    this.ctrl.decimals = decimals;\n    this.ctrl.scaledDecimals = scaledDecimals;\n\n    // Set default Y min and max if no data\n    if (isEmpty(this.data.buckets)) {\n      yMax = 1;\n      yMin = -1;\n      ticks = 3;\n      decimals = 1;\n    }\n\n    this.data.yAxis = {\n      min: yMin,\n      max: yMax,\n      ticks: ticks,\n    };\n\n    this.scope.yScale = this.yScale = d3.scaleLinear().domain([yMin, yMax]).range([this.chartHeight, 0]);\n\n    const yAxis = d3\n      .axisLeft(this.yScale)\n      .ticks(ticks)\n      .tickFormat(this.tickValueFormatter(decimals, scaledDecimals))\n      .tickSizeInner(0 - this.width)\n      .tickSizeOuter(0)\n      .tickPadding(Y_AXIS_TICK_PADDING);\n\n    this.heatmap.append('g').attr('class', 'axis axis-y').call(yAxis);\n\n    // Calculate Y axis width first, then move axis into visible area\n    const posY = this.margin.top;\n    const posX = this.getYAxisWidth(this.heatmap) + Y_AXIS_TICK_PADDING;\n    this.heatmap.select('.axis-y').attr('transform', 'translate(' + posX + ',' + posY + ')');\n\n    // Remove vertical line in the right of axis labels (called domain in d3)\n    this.heatmap.select('.axis-y').select('.domain').remove();\n  }\n\n  // Wide Y values range and anjust to bucket size\n  wideYAxisRange(min: number, max: number, tickInterval: number) {\n    const yWiding = (max * (this.dataRangeWidingFactor - 1) - min * (this.dataRangeWidingFactor - 1)) / 2;\n    let yMin, yMax;\n\n    if (tickInterval === 0) {\n      yMax = max * this.dataRangeWidingFactor;\n      yMin = min - min * (this.dataRangeWidingFactor - 1);\n    } else {\n      yMax = Math.ceil((max + yWiding) / tickInterval) * tickInterval;\n      yMin = Math.floor((min - yWiding) / tickInterval) * tickInterval;\n    }\n\n    // Don't wide axis below 0 if all values are positive\n    if (min >= 0 && yMin < 0) {\n      yMin = 0;\n    }\n\n    return { yMin, yMax };\n  }\n\n  addLogYAxis() {\n    const logBase = this.panel.yAxis.logBase;\n    let { yMin, yMax } = this.adjustLogRange(this.data.heatmapStats.minLog, this.data.heatmapStats.max, logBase);\n\n    yMin =\n      this.panel.yAxis.min && this.panel.yAxis.min !== '0' ? this.adjustLogMin(this.panel.yAxis.min, logBase) : yMin;\n    yMax = this.panel.yAxis.max !== null ? this.adjustLogMax(this.panel.yAxis.max, logBase) : yMax;\n\n    // Set default Y min and max if no data\n    if (isEmpty(this.data.buckets)) {\n      yMax = Math.pow(logBase, 2);\n      yMin = 1;\n    }\n\n    this.scope.yScale = this.yScale = d3\n      .scaleLog()\n      .base(this.panel.yAxis.logBase)\n      .domain([yMin, yMax])\n      .range([this.chartHeight, 0]);\n\n    const domain = this.yScale.domain();\n    const tickValues = this.logScaleTickValues(domain, logBase);\n\n    const decimalsAuto = ticksUtils.getPrecision(yMin);\n    const decimals = this.panel.yAxis.decimals || decimalsAuto;\n\n    // Calculate scaledDecimals for log scales using tick size (as in jquery.flot.js)\n    const flotTickSize = ticksUtils.getFlotTickSize(yMin, yMax, tickValues.length, decimalsAuto);\n    const scaledDecimals = ticksUtils.getScaledDecimals(decimals, flotTickSize);\n    this.ctrl.decimals = decimals;\n    this.ctrl.scaledDecimals = scaledDecimals;\n\n    this.data.yAxis = {\n      min: yMin,\n      max: yMax,\n      ticks: tickValues.length,\n    };\n\n    const yAxis = d3\n      .axisLeft(this.yScale)\n      .tickValues(tickValues)\n      .tickFormat(this.tickValueFormatter(decimals, scaledDecimals))\n      .tickSizeInner(0 - this.width)\n      .tickSizeOuter(0)\n      .tickPadding(Y_AXIS_TICK_PADDING);\n\n    this.heatmap.append('g').attr('class', 'axis axis-y').call(yAxis);\n\n    // Calculate Y axis width first, then move axis into visible area\n    const posY = this.margin.top;\n    const posX = this.getYAxisWidth(this.heatmap) + Y_AXIS_TICK_PADDING;\n    this.heatmap.select('.axis-y').attr('transform', 'translate(' + posX + ',' + posY + ')');\n\n    // Set first tick as pseudo 0\n    if (yMin < 1) {\n      this.heatmap.select('.axis-y').select('.tick text').text('0');\n    }\n\n    // Remove vertical line in the right of axis labels (called domain in d3)\n    this.heatmap.select('.axis-y').select('.domain').remove();\n  }\n\n  addYAxisFromBuckets() {\n    const tsBuckets = this.data.tsBuckets;\n    let ticks = Math.ceil(this.chartHeight / DEFAULT_Y_TICK_SIZE_PX);\n\n    this.scope.yScale = this.yScale = d3\n      .scaleLinear()\n      .domain([0, tsBuckets.length - 1])\n      .range([this.chartHeight, 0]);\n\n    const tickValues = map(tsBuckets, (b, i) => i);\n    const decimalsAuto = max(map(tsBuckets, ticksUtils.getStringPrecision));\n    const decimals = this.panel.yAxis.decimals === null ? decimalsAuto : this.panel.yAxis.decimals;\n    this.ctrl.decimals = decimals;\n\n    const tickValueFormatter = this.tickValueFormatter.bind(this);\n    function tickFormatter(yAxisWidth: number | null) {\n      return function (valIndex: d3.AxisDomain) {\n        let valueFormatted = tsBuckets[valIndex.valueOf()];\n        if (!isNaN(toNumber(valueFormatted)) && valueFormatted !== '') {\n          // Try to format numeric tick labels\n          valueFormatted = tickValueFormatter(decimals)(toNumber(valueFormatted));\n        } else if (valueFormatted && typeof valueFormatted === 'string' && valueFormatted !== '') {\n          if (yAxisWidth) {\n            const scale = 0.15; // how to have a better calculation for this\n            const trimmed = valueFormatted.substring(0, Math.floor(yAxisWidth * scale));\n            const postfix = trimmed.length < valueFormatted.length ? '...' : '';\n            valueFormatted = `${trimmed}${postfix}`;\n          }\n        }\n        return valueFormatted;\n      };\n    }\n    const tsBucketsFormatted = map(tsBuckets, (v, i) => tickFormatter(null)(i));\n    this.data.tsBucketsFormatted = tsBucketsFormatted;\n\n    const yAxis = d3\n      .axisLeft(this.yScale)\n      .tickFormat(tickFormatter(this.getPanelYAxisWidth()))\n      .tickSizeInner(0 - this.width)\n      .tickSizeOuter(0)\n      .tickPadding(Y_AXIS_TICK_PADDING);\n    if (tickValues && tickValues.length <= ticks) {\n      yAxis.tickValues(tickValues);\n    } else {\n      yAxis.ticks(ticks);\n    }\n\n    this.heatmap.append('g').attr('class', 'axis axis-y').call(yAxis);\n\n    // Calculate Y axis width first, then move axis into visible area\n    const posY = this.margin.top;\n    const posX = this.getYAxisWidth(this.heatmap) + Y_AXIS_TICK_PADDING;\n    this.heatmap.select('.axis-y').attr('transform', 'translate(' + posX + ',' + posY + ')');\n\n    if (this.panel.yBucketBound === 'middle' && tickValues && tickValues.length) {\n      // Shift Y axis labels to the middle of bucket\n      const tickShift = 0 - this.chartHeight / (tickValues.length - 1) / 2;\n      this.heatmap.selectAll('.axis-y text').attr('transform', 'translate(' + 0 + ',' + tickShift + ')');\n    }\n\n    // Remove vertical line in the right of axis labels (called domain in d3)\n    this.heatmap.select('.axis-y').select('.domain').remove();\n  }\n\n  // Adjust data range to log base\n  adjustLogRange(min: number, max: number, logBase: number) {\n    let yMin = this.data.heatmapStats.minLog;\n    if (this.data.heatmapStats.minLog > 1 || !this.data.heatmapStats.minLog) {\n      yMin = 1;\n    } else {\n      yMin = this.adjustLogMin(this.data.heatmapStats.minLog, logBase);\n    }\n\n    // Adjust max Y value to log base\n    const yMax = this.adjustLogMax(this.data.heatmapStats.max, logBase);\n\n    return { yMin, yMax };\n  }\n\n  adjustLogMax(max: number, base: number) {\n    return Math.pow(base, Math.ceil(ticksUtils.logp(max, base)));\n  }\n\n  adjustLogMin(min: number, base: number) {\n    return Math.pow(base, Math.floor(ticksUtils.logp(min, base)));\n  }\n\n  logScaleTickValues(domain: any[], base: number) {\n    const domainMin = domain[0];\n    const domainMax = domain[1];\n    const tickValues = [];\n\n    if (domainMin < 1) {\n      const underOneTicks = Math.floor(ticksUtils.logp(domainMin, base));\n      for (let i = underOneTicks; i < 0; i++) {\n        const tickValue = Math.pow(base, i);\n        tickValues.push(tickValue);\n      }\n    }\n\n    const ticks = Math.ceil(ticksUtils.logp(domainMax, base));\n    for (let i = 0; i <= ticks; i++) {\n      const tickValue = Math.pow(base, i);\n      tickValues.push(tickValue);\n    }\n\n    return tickValues;\n  }\n\n  tickValueFormatter(decimals: number, scaledDecimals: any = null) {\n    const format = this.panel.yAxis.format;\n    return (value: any) => {\n      try {\n        if (format !== 'none') {\n          const v = getValueFormat(format)(value, decimals, scaledDecimals);\n          return formattedValueToString(v);\n        }\n      } catch (err) {\n        console.error(err instanceof Error ? err.message : err);\n      }\n      return value;\n    };\n  }\n\n  fixYAxisTickSize() {\n    this.heatmap.select('.axis-y').selectAll('.tick line').attr('x2', this.chartWidth);\n  }\n\n  addAxes() {\n    this.chartHeight = this.height - this.margin.top - this.margin.bottom;\n    this.chartTop = this.margin.top;\n    this.chartBottom = this.chartTop + this.chartHeight;\n    if (this.panel.dataFormat === 'tsbuckets') {\n      this.addYAxisFromBuckets();\n    } else {\n      if (this.panel.yAxis.logBase === 1) {\n        this.addYAxis();\n      } else {\n        this.addLogYAxis();\n      }\n    }\n\n    this.yAxisWidth = this.getYAxisWidth(this.heatmap) + Y_AXIS_TICK_PADDING;\n    this.chartWidth = this.width - this.yAxisWidth - this.margin.right;\n    this.fixYAxisTickSize();\n\n    this.addXAxis();\n    this.xAxisHeight = this.getXAxisHeight(this.heatmap);\n\n    if (!this.panel.yAxis.show) {\n      this.heatmap.select('.axis-y').selectAll('line').style('opacity', 0);\n    }\n\n    if (!this.panel.xAxis.show) {\n      this.heatmap.select('.axis-x').selectAll('line').style('opacity', 0);\n    }\n  }\n\n  addHeatmapCanvas() {\n    const heatmapElem = this.$heatmap[0];\n\n    this.width = Math.floor(this.$heatmap.width()) - this.padding.right;\n    this.height = Math.floor(this.$heatmap.height()) - this.padding.bottom;\n\n    this.cardPadding = this.panel.cards.cardPadding !== null ? this.panel.cards.cardPadding : CARD_PADDING;\n    this.cardRound = this.panel.cards.cardRound !== null ? this.panel.cards.cardRound : CARD_ROUND;\n\n    if (this.heatmap) {\n      this.heatmap.remove();\n    }\n\n    this.heatmap = d3.select(heatmapElem).append('svg').attr('width', this.width).attr('height', this.height);\n  }\n\n  addHeatmap() {\n    this.addHeatmapCanvas();\n    this.addAxes();\n\n    if (this.panel.yAxis.logBase !== 1 && this.panel.dataFormat !== 'tsbuckets') {\n      const logBase = this.panel.yAxis.logBase;\n      const domain = this.yScale.domain();\n      const tickValues = this.logScaleTickValues(domain, logBase);\n      this.data.buckets = mergeZeroBuckets(this.data.buckets, min(tickValues)!);\n    }\n\n    const cardsData = this.data.cards;\n    const cardStats = this.data.cardStats;\n    const maxValueAuto = cardStats.max;\n    const minValueAuto = Math.max(cardStats.min, 0);\n    const maxValue = isNil(this.panel.color.max) ? maxValueAuto : this.panel.color.max;\n    const minValue = isNil(this.panel.color.min) ? minValueAuto : this.panel.color.min;\n    const colorScheme: any = find(this.ctrl.colorSchemes, {\n      value: this.panel.color.colorScheme,\n    });\n    this.colorScale = getColorScale(colorScheme, contextSrv.user.lightTheme, maxValue, minValue);\n    this.opacityScale = getOpacityScale(this.panel.color, maxValue, minValue);\n    this.setCardSize();\n\n    let cards = this.heatmap.selectAll('.heatmap-card').data(cardsData);\n    cards.append('title');\n    cards = cards\n      .enter()\n      .append('rect')\n      .attr('x', this.getCardX.bind(this))\n      .attr('width', this.getCardWidth.bind(this))\n      .attr('y', this.getCardY.bind(this))\n      .attr('height', this.getCardHeight.bind(this))\n      .attr('rx', this.cardRound)\n      .attr('ry', this.cardRound)\n      .attr('class', 'bordered heatmap-card')\n      .style('fill', this.getCardColor.bind(this))\n      .style('stroke', this.getCardColor.bind(this))\n      .style('stroke-width', 0)\n      .style('opacity', this.getCardOpacity.bind(this));\n\n    const $cards = this.$heatmap.find('.heatmap-card');\n    $cards\n      .on('mouseenter', (event: any) => {\n        this.tooltip.mouseOverBucket = true;\n        this.highlightCard(event);\n      })\n      .on('mouseleave', (event: any) => {\n        this.tooltip.mouseOverBucket = false;\n        this.resetCardHighLight(event);\n      });\n  }\n\n  highlightCard(event: any) {\n    const color = d3.select(event.target).style('fill');\n    const highlightColor = d3.color(color)!.darker(2);\n    const strokeColor = d3.color(color)!.brighter(4);\n    const currentCard = d3.select(event.target);\n    this.tooltip.originalFillColor = color;\n    currentCard\n      .style('fill', highlightColor.toString())\n      .style('stroke', strokeColor.toString())\n      .style('stroke-width', 1);\n  }\n\n  resetCardHighLight(event: any) {\n    d3.select(event.target)\n      .style('fill', this.tooltip.originalFillColor)\n      .style('stroke', this.tooltip.originalFillColor)\n      .style('stroke-width', 0);\n  }\n\n  setCardSize() {\n    const xGridSize = Math.floor(this.xScale(this.data.xBucketSize) - this.xScale(0));\n    let yGridSize = Math.floor(this.yScale(this.yScale.invert(0) - this.data.yBucketSize));\n\n    if (this.panel.yAxis.logBase !== 1) {\n      const base = this.panel.yAxis.logBase;\n      const splitFactor = this.data.yBucketSize || 1;\n      yGridSize = Math.floor((this.yScale(1) - this.yScale(base)) / splitFactor);\n    }\n\n    const cardWidth = xGridSize - this.cardPadding * 2;\n    this.cardWidth = Math.max(cardWidth, MIN_CARD_SIZE);\n    this.cardHeight = yGridSize ? yGridSize - this.cardPadding * 2 : 0;\n  }\n\n  getCardX(d: { x: any }) {\n    let x;\n    if (this.xScale(d.x) < 0) {\n      // Cut card left to prevent overlay\n      x = this.yAxisWidth + this.cardPadding;\n    } else {\n      x = this.xScale(d.x) + this.yAxisWidth + this.cardPadding;\n    }\n\n    return x;\n  }\n\n  getCardWidth(d: { x: any }) {\n    let w = this.cardWidth;\n    if (this.xScale(d.x) < 0) {\n      // Cut card left to prevent overlay\n      w = this.xScale(d.x) + this.cardWidth;\n    } else if (this.xScale(d.x) + this.cardWidth > this.chartWidth) {\n      // Cut card right to prevent overlay\n      w = this.chartWidth - this.xScale(d.x) - this.cardPadding;\n    }\n\n    // Card width should be MIN_CARD_SIZE at least, but cut cards shouldn't be displayed\n    w = w > 0 ? Math.max(w, MIN_CARD_SIZE) : 0;\n    return w;\n  }\n\n  getCardY(d: { y: number }) {\n    let y = this.yScale(d.y) + this.chartTop - this.cardHeight - this.cardPadding;\n    if (this.panel.yAxis.logBase !== 1 && d.y === 0) {\n      y = this.chartBottom - this.cardHeight - this.cardPadding;\n    } else {\n      if (y < this.chartTop) {\n        y = this.chartTop;\n      }\n    }\n\n    return y;\n  }\n\n  getCardHeight(d: { y: number }) {\n    const y = this.yScale(d.y) + this.chartTop - this.cardHeight - this.cardPadding;\n    let h = this.cardHeight;\n\n    if (this.panel.yAxis.logBase !== 1 && d.y === 0) {\n      return this.cardHeight;\n    }\n\n    // Cut card height to prevent overlay\n    if (y < this.chartTop) {\n      h = this.yScale(d.y) - this.cardPadding;\n    } else if (this.yScale(d.y) > this.chartBottom) {\n      h = this.chartBottom - y;\n    } else if (y + this.cardHeight > this.chartBottom) {\n      h = this.chartBottom - y;\n    }\n\n    // Height can't be more than chart height\n    h = Math.min(h, this.chartHeight);\n    // Card height should be MIN_CARD_SIZE at least\n    h = Math.max(h, MIN_CARD_SIZE);\n\n    return h;\n  }\n\n  getCardColor(d: { count: any }) {\n    if (this.panel.color.mode === 'opacity') {\n      return config.theme2.visualization.getColorByName(this.panel.color.cardColor);\n    } else {\n      return this.colorScale(d.count);\n    }\n  }\n\n  getCardOpacity(d: { count: any }) {\n    if (this.panel.color.mode === 'opacity') {\n      return this.opacityScale(d.count);\n    } else {\n      return 1;\n    }\n  }\n\n  getEventOffset(event: any) {\n    const elemOffset = this.$heatmap.offset();\n    const x = Math.floor(event.clientX - elemOffset.left);\n    const y = Math.floor(event.clientY - elemOffset.top);\n    return { x, y };\n  }\n\n  onMouseDown(event: any) {\n    const offset = this.getEventOffset(event);\n    this.selection.active = true;\n    this.selection.x1 = offset.x;\n\n    this.mouseUpHandler = () => {\n      this.onMouseUp();\n    };\n\n    $(document).one('mouseup', this.mouseUpHandler.bind(this));\n  }\n\n  onMouseUp() {\n    $(document).unbind('mouseup', this.mouseUpHandler.bind(this));\n    this.mouseUpHandler = null;\n    this.selection.active = false;\n\n    const selectionRange = Math.abs(this.selection.x2 - this.selection.x1);\n    if (this.selection.x2 >= 0 && selectionRange > MIN_SELECTION_WIDTH) {\n      const timeFrom = this.xScale.invert(Math.min(this.selection.x1, this.selection.x2) - this.yAxisWidth);\n      const timeTo = this.xScale.invert(Math.max(this.selection.x1, this.selection.x2) - this.yAxisWidth);\n\n      this.ctrl.timeSrv.setTime({\n        from: toUtc(timeFrom),\n        to: toUtc(timeTo),\n      });\n    }\n\n    this.clearSelection();\n  }\n\n  onMouseLeave() {\n    this.ctrl.dashboard.events.publish(new LegacyGraphHoverClearEvent());\n    this.clearCrosshair();\n  }\n\n  onMouseMove(event: any) {\n    if (!this.heatmap) {\n      return;\n    }\n\n    const offset = this.getEventOffset(event);\n    if (this.selection.active) {\n      // Clear crosshair and tooltip\n      this.clearCrosshair();\n      this.tooltip.destroy();\n\n      this.selection.x2 = this.limitSelection(offset.x);\n      this.drawSelection(this.selection.x1, this.selection.x2);\n    } else {\n      const pos = this.getEventPos(event, offset);\n      this.drawCrosshair(offset.x);\n      this.tooltip.show(pos, this.data);\n      this.emitGraphHoverEvent(pos);\n    }\n  }\n\n  getEventPos(event: { pageX: any; pageY: any }, offset: { x: any; y: any }) {\n    const x = this.xScale.invert(offset.x - this.yAxisWidth).valueOf();\n    const y = this.yScale.invert(offset.y - this.chartTop);\n    const pos: any = {\n      pageX: event.pageX,\n      pageY: event.pageY,\n      x: x,\n      x1: x,\n      y: y,\n      y1: y,\n      panelRelY: null,\n      offset,\n    };\n\n    return pos;\n  }\n\n  emitGraphHoverEvent(pos: { panelRelY: number; offset: { y: number } }) {\n    // Set minimum offset to prevent showing legend from another panel\n    pos.panelRelY = Math.max(pos.offset.y / this.height, 0.001);\n    // broadcast to other graph panels that we are hovering\n    this.hoverEvent.payload.pos = pos;\n    this.hoverEvent.payload.panel = this.panel;\n    this.hoverEvent.payload.point['time'] = (pos as any).x;\n    this.ctrl.dashboard.events.publish(this.hoverEvent);\n  }\n\n  limitSelection(x2: number) {\n    x2 = Math.max(x2, this.yAxisWidth);\n    x2 = Math.min(x2, this.chartWidth + this.yAxisWidth);\n    return x2;\n  }\n\n  drawSelection(posX1: number, posX2: number) {\n    if (this.heatmap) {\n      this.heatmap.selectAll('.heatmap-selection').remove();\n      const selectionX = Math.min(posX1, posX2);\n      const selectionWidth = Math.abs(posX1 - posX2);\n\n      if (selectionWidth > MIN_SELECTION_WIDTH) {\n        this.heatmap\n          .append('rect')\n          .attr('class', 'heatmap-selection')\n          .attr('x', selectionX)\n          .attr('width', selectionWidth)\n          .attr('y', this.chartTop)\n          .attr('height', this.chartHeight);\n      }\n    }\n  }\n\n  clearSelection() {\n    this.selection.x1 = -1;\n    this.selection.x2 = -1;\n\n    if (this.heatmap) {\n      this.heatmap.selectAll('.heatmap-selection').remove();\n    }\n  }\n\n  drawCrosshair(position: number) {\n    if (this.heatmap) {\n      this.heatmap.selectAll('.heatmap-crosshair').remove();\n\n      let posX = position;\n      posX = Math.max(posX, this.yAxisWidth);\n      posX = Math.min(posX, this.chartWidth + this.yAxisWidth);\n\n      this.heatmap\n        .append('g')\n        .attr('class', 'heatmap-crosshair')\n        .attr('transform', 'translate(' + posX + ',0)')\n        .append('line')\n        .attr('x1', 1)\n        .attr('y1', this.chartTop)\n        .attr('x2', 1)\n        .attr('y2', this.chartBottom)\n        .attr('stroke-width', 1);\n    }\n  }\n\n  drawSharedCrosshair(pos: { x: any }) {\n    if (this.heatmap && this.ctrl.dashboard.graphTooltip !== 0) {\n      const posX = this.xScale(pos.x) + this.yAxisWidth;\n      this.drawCrosshair(posX);\n    }\n  }\n\n  clearCrosshair() {\n    if (this.heatmap) {\n      this.heatmap.selectAll('.heatmap-crosshair').remove();\n    }\n  }\n\n  render() {\n    this.data = this.ctrl.data;\n    this.panel = this.ctrl.panel;\n    this.timeRange = this.ctrl.range;\n\n    if (!this.setElementHeight() || !this.data) {\n      return;\n    }\n\n    // Draw default axes and return if no data\n    if (isEmpty(this.data.buckets)) {\n      this.addHeatmapCanvas();\n      this.addAxes();\n      return;\n    }\n\n    this.addHeatmap();\n    this.scope.yAxisWidth = this.yAxisWidth;\n    this.scope.xAxisHeight = this.xAxisHeight;\n    this.scope.chartHeight = this.chartHeight;\n    this.scope.chartWidth = this.chartWidth;\n    this.scope.chartTop = this.chartTop;\n  }\n\n  private getPanelYAxisWidth(): number | null {\n    if (!this.panel.yAxis.width) {\n      return null;\n    }\n\n    return isNaN(this.panel.yAxis.width) ? null : parseInt(this.panel.yAxis.width, 10);\n  }\n}\n","import { auto } from 'angular';\nimport { defaultsDeep, includes, keys, map, reduce, min as _min, max as _max } from 'lodash';\n\nimport { LegacyResponseData, PanelEvents, DataFrame, rangeUtil } from '@grafana/data';\nimport appEvents from 'app/core/app_events';\nimport TimeSeries from 'app/core/time_series2';\nimport kbn from 'app/core/utils/kbn';\nimport { TimeSrv } from 'app/features/dashboard/services/TimeSrv';\nimport { getProcessedDataFrames } from 'app/features/query/state/runRequest';\nimport { TemplateSrv } from 'app/features/templating/template_srv';\nimport { MetricsPanelCtrl } from 'app/plugins/sdk';\nimport { ZoomOutEvent } from 'app/types/events';\n\nimport { DataProcessor } from '../graph/data_processor';\n\nimport { axesEditor } from './axes_editor';\nimport { heatmapDisplayEditor } from './display_editor';\nimport {\n  convertToHeatMap,\n  convertToCards,\n  histogramToHeatmap,\n  calculateBucketSize,\n  sortSeriesByLabel,\n} from './heatmap_data_converter';\nimport rendering from './rendering';\n\nconst X_BUCKET_NUMBER_DEFAULT = 30;\nconst Y_BUCKET_NUMBER_DEFAULT = 10;\n\nconst panelDefaults: any = {\n  heatmap: {},\n  cards: {\n    cardPadding: null,\n    cardRound: null,\n  },\n  color: {\n    mode: 'spectrum',\n    cardColor: '#b4ff00',\n    colorScale: 'sqrt',\n    exponent: 0.5,\n    colorScheme: 'interpolateOranges',\n  },\n  legend: {\n    show: false,\n  },\n  dataFormat: 'timeseries',\n  yBucketBound: 'auto',\n  reverseYBuckets: false,\n  xAxis: {\n    show: true,\n  },\n  yAxis: {\n    show: true,\n    format: 'short',\n    decimals: null,\n    logBase: 1,\n    splitFactor: null,\n    min: null,\n    max: null,\n  },\n  xBucketSize: null,\n  xBucketNumber: null,\n  yBucketSize: null,\n  yBucketNumber: null,\n  tooltip: {\n    show: true,\n    showHistogram: false,\n  },\n  highlightCards: true,\n  hideZeroBuckets: false,\n};\n\nconst colorModes = ['opacity', 'spectrum'];\nconst opacityScales = ['linear', 'sqrt'];\n\n// Schemes from d3-scale-chromatic\n// https://github.com/d3/d3-scale-chromatic\nconst colorSchemes = [\n  // Diverging\n  { name: 'Spectral', value: 'interpolateSpectral', invert: 'always' },\n  { name: 'RdYlGn', value: 'interpolateRdYlGn', invert: 'always' },\n\n  // Sequential (Single Hue)\n  { name: 'Blues', value: 'interpolateBlues', invert: 'dark' },\n  { name: 'Greens', value: 'interpolateGreens', invert: 'dark' },\n  { name: 'Greys', value: 'interpolateGreys', invert: 'dark' },\n  { name: 'Oranges', value: 'interpolateOranges', invert: 'dark' },\n  { name: 'Purples', value: 'interpolatePurples', invert: 'dark' },\n  { name: 'Reds', value: 'interpolateReds', invert: 'dark' },\n\n  // Sequential (Multi-Hue)\n  { name: 'Turbo', value: 'interpolateTurbo', invert: 'light' },\n  { name: 'Cividis', value: 'interpolateCividis', invert: 'light' },\n  { name: 'Viridis', value: 'interpolateViridis', invert: 'light' },\n  { name: 'Magma', value: 'interpolateMagma', invert: 'light' },\n  { name: 'Inferno', value: 'interpolateInferno', invert: 'light' },\n  { name: 'Plasma', value: 'interpolatePlasma', invert: 'light' },\n  { name: 'Warm', value: 'interpolateWarm', invert: 'light' },\n  { name: 'Cool', value: 'interpolateCool', invert: 'light' },\n  { name: 'Cubehelix', value: 'interpolateCubehelixDefault', invert: 'light' },\n  { name: 'BuGn', value: 'interpolateBuGn', invert: 'dark' },\n  { name: 'BuPu', value: 'interpolateBuPu', invert: 'dark' },\n  { name: 'GnBu', value: 'interpolateGnBu', invert: 'dark' },\n  { name: 'OrRd', value: 'interpolateOrRd', invert: 'dark' },\n  { name: 'PuBuGn', value: 'interpolatePuBuGn', invert: 'dark' },\n  { name: 'PuBu', value: 'interpolatePuBu', invert: 'dark' },\n  { name: 'PuRd', value: 'interpolatePuRd', invert: 'dark' },\n  { name: 'RdPu', value: 'interpolateRdPu', invert: 'dark' },\n  { name: 'YlGnBu', value: 'interpolateYlGnBu', invert: 'dark' },\n  { name: 'YlGn', value: 'interpolateYlGn', invert: 'dark' },\n  { name: 'YlOrBr', value: 'interpolateYlOrBr', invert: 'dark' },\n  { name: 'YlOrRd', value: 'interpolateYlOrRd', invert: 'dark' },\n];\n\nconst dsSupportHistogramSort = ['elasticsearch'];\n\nexport class HeatmapCtrl extends MetricsPanelCtrl {\n  static templateUrl = 'module.html';\n\n  opacityScales: any = [];\n  colorModes: any = [];\n  colorSchemes: any = [];\n  selectionActivated: boolean;\n  unitFormats: any;\n  data: any;\n  series: TimeSeries[] = [];\n  dataWarning: any;\n  decimals = 0;\n  scaledDecimals = 0;\n\n  processor: DataProcessor; // Shared with graph panel\n\n  /** @ngInject */\n  constructor($scope: any, $injector: auto.IInjectorService, templateSrv: TemplateSrv, timeSrv: TimeSrv) {\n    super($scope, $injector);\n\n    this.selectionActivated = false;\n\n    defaultsDeep(this.panel, panelDefaults);\n    this.opacityScales = opacityScales;\n    this.colorModes = colorModes;\n    this.colorSchemes = colorSchemes;\n\n    // Use DataFrames\n    this.useDataFrames = true;\n    this.processor = new DataProcessor({\n      xaxis: { mode: 'custom' }, // NOT: 'histogram' :)\n      aliasColors: {}, // avoids null reference\n    });\n\n    // Bind grafana panel events\n    this.events.on(PanelEvents.render, this.onRender.bind(this));\n    this.events.on(PanelEvents.dataFramesReceived, this.onDataFramesReceived.bind(this));\n    this.events.on(PanelEvents.dataSnapshotLoad, this.onSnapshotLoad.bind(this));\n    this.events.on(PanelEvents.editModeInitialized, this.onInitEditMode.bind(this));\n\n    this.onCardColorChange = this.onCardColorChange.bind(this);\n\n    // Make sure we do not save the version so migration to react version is kicked off\n    delete this.panel.pluginVersion;\n  }\n\n  onInitEditMode() {\n    this.addEditorTab('Axes', axesEditor, 2);\n    this.addEditorTab('Display', heatmapDisplayEditor, 3);\n    this.unitFormats = kbn.getUnitFormats();\n  }\n\n  zoomOut(evt: any) {\n    appEvents.publish(new ZoomOutEvent({ scale: 2 }));\n  }\n\n  onRender() {\n    if (this.panel.dataFormat === 'tsbuckets') {\n      this.convertHistogramToHeatmapData();\n    } else {\n      this.convertTimeSeriesToHeatmapData();\n    }\n  }\n\n  convertTimeSeriesToHeatmapData() {\n    if (!this.range || !this.series) {\n      return;\n    }\n\n    let xBucketSize, yBucketSize, bucketsData, heatmapStats;\n    const logBase = this.panel.yAxis.logBase;\n\n    const xBucketNumber = this.panel.xBucketNumber || X_BUCKET_NUMBER_DEFAULT;\n    const xBucketSizeByNumber = Math.floor((this.range.to.valueOf() - this.range.from.valueOf()) / xBucketNumber);\n\n    // Parse X bucket size (number or interval)\n    const isIntervalString = kbn.intervalRegex.test(this.panel.xBucketSize);\n    if (isIntervalString) {\n      xBucketSize = rangeUtil.intervalToMs(this.panel.xBucketSize);\n    } else if (\n      isNaN(Number(this.panel.xBucketSize)) ||\n      this.panel.xBucketSize === '' ||\n      this.panel.xBucketSize === null\n    ) {\n      xBucketSize = xBucketSizeByNumber;\n    } else {\n      xBucketSize = Number(this.panel.xBucketSize);\n    }\n\n    // Calculate Y bucket size\n    heatmapStats = this.parseSeries(this.series);\n    const yBucketNumber = this.panel.yBucketNumber || Y_BUCKET_NUMBER_DEFAULT;\n    if (logBase !== 1) {\n      yBucketSize = this.panel.yAxis.splitFactor;\n    } else {\n      if (heatmapStats.max === heatmapStats.min) {\n        if (heatmapStats.max) {\n          yBucketSize = heatmapStats.max / Y_BUCKET_NUMBER_DEFAULT;\n        } else {\n          yBucketSize = 1;\n        }\n      } else {\n        yBucketSize = (heatmapStats.max - heatmapStats.min) / yBucketNumber;\n      }\n      yBucketSize = this.panel.yBucketSize || yBucketSize;\n    }\n\n    bucketsData = convertToHeatMap(this.series, yBucketSize, xBucketSize, logBase);\n\n    // Set default Y range if no data\n    if (!heatmapStats.min && !heatmapStats.max) {\n      heatmapStats = { min: -1, max: 1, minLog: 1 };\n      yBucketSize = 1;\n    }\n\n    const { cards, cardStats } = convertToCards(bucketsData, this.panel.hideZeroBuckets);\n\n    this.data = {\n      buckets: bucketsData,\n      heatmapStats: heatmapStats,\n      xBucketSize: xBucketSize,\n      yBucketSize: yBucketSize,\n      cards: cards,\n      cardStats: cardStats,\n    };\n  }\n\n  convertHistogramToHeatmapData() {\n    if (!this.range || !this.series) {\n      return;\n    }\n\n    const panelDatasource = this.getPanelDataSourceType();\n    let xBucketSize, yBucketSize, bucketsData, tsBuckets;\n\n    // Try to sort series by bucket bound, if datasource doesn't do it.\n    if (!includes(dsSupportHistogramSort, panelDatasource)) {\n      this.series.sort(sortSeriesByLabel);\n    }\n\n    if (this.panel.reverseYBuckets) {\n      this.series.reverse();\n    }\n\n    // Convert histogram to heatmap. Each histogram bucket represented by the series which name is\n    // a top (or bottom, depends of datasource) bucket bound. Further, these values will be used as Y axis labels.\n    bucketsData = histogramToHeatmap(this.series);\n\n    tsBuckets = map(this.series, 'label');\n    const yBucketBound = this.panel.yBucketBound;\n    if (\n      (panelDatasource === 'prometheus' && yBucketBound !== 'lower' && yBucketBound !== 'middle') ||\n      yBucketBound === 'upper'\n    ) {\n      // Prometheus labels are upper inclusive bounds, so add empty bottom bucket label.\n      tsBuckets = [''].concat(tsBuckets);\n    } else {\n      // Elasticsearch uses labels as lower bucket bounds, so add empty top bucket label.\n      // Use this as a default mode as well.\n      tsBuckets.push('');\n    }\n\n    // Calculate bucket size based on heatmap data\n    const xBucketBoundSet = map(keys(bucketsData), (key) => Number(key));\n    xBucketSize = calculateBucketSize(xBucketBoundSet);\n    // Always let yBucketSize=1 in 'tsbuckets' mode\n    yBucketSize = 1;\n\n    const { cards, cardStats } = convertToCards(bucketsData, this.panel.hideZeroBuckets);\n\n    this.data = {\n      buckets: bucketsData,\n      xBucketSize: xBucketSize,\n      yBucketSize: yBucketSize,\n      tsBuckets: tsBuckets,\n      cards: cards,\n      cardStats: cardStats,\n    };\n  }\n\n  getPanelDataSourceType() {\n    if (this.datasource && this.datasource.meta && this.datasource.meta.id) {\n      return this.datasource.meta.id;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  // This should only be called from the snapshot callback\n  onSnapshotLoad(dataList: LegacyResponseData[]) {\n    this.onDataFramesReceived(getProcessedDataFrames(dataList));\n  }\n\n  // Directly support DataFrame\n  onDataFramesReceived(data: DataFrame[]) {\n    this.series = this.processor.getSeriesList({ dataList: data, range: this.range }).map((ts) => {\n      ts.color = undefined; // remove whatever the processor set\n      ts.flotpairs = ts.getFlotPairs(this.panel.nullPointMode);\n      return ts;\n    });\n\n    this.dataWarning = null;\n    const datapointsCount = reduce(\n      this.series,\n      (sum, series) => {\n        return sum + series.datapoints.length;\n      },\n      0\n    );\n\n    if (datapointsCount === 0) {\n      this.dataWarning = {\n        title: 'No data points',\n        tip: 'No datapoints returned from data query',\n      };\n    } else {\n      for (const series of this.series) {\n        if (series.isOutsideRange) {\n          this.dataWarning = {\n            title: 'Data points outside time range',\n            tip: 'Can be caused by timezone mismatch or missing time filter in query',\n          };\n          break;\n        }\n      }\n    }\n\n    this.render();\n  }\n\n  onDataError() {\n    this.series = [];\n    this.render();\n  }\n\n  onCardColorChange(newColor: any) {\n    this.panel.color.cardColor = newColor;\n    this.render();\n  }\n\n  parseSeries(series: TimeSeries[]) {\n    const min = _min(map(series, (s) => s.stats.min));\n    const minLog = _min(map(series, (s) => s.stats.logmin));\n    const max = _max(map(series, (s) => s.stats.max));\n\n    return {\n      max,\n      min,\n      minLog,\n    };\n  }\n\n  parseHistogramSeries(series: TimeSeries[]) {\n    const bounds = map(series, (s) => Number(s.alias));\n    const min = _min(bounds);\n    const minLog = _min(bounds);\n    const max = _max(bounds);\n\n    return {\n      max: max,\n      min: min,\n      minLog: minLog,\n    };\n  }\n\n  link(scope: any, elem: any, attrs: any, ctrl: any) {\n    rendering(scope, elem, attrs, ctrl);\n  }\n}\n","import { makeClassES5Compatible } from '@grafana/data';\nimport { loadPluginCss } from '@grafana/runtime';\nimport { MetricsPanelCtrl as MetricsPanelCtrlES6 } from 'app/angular/panel/metrics_panel_ctrl';\nimport { PanelCtrl as PanelCtrlES6 } from 'app/angular/panel/panel_ctrl';\nimport { QueryCtrl as QueryCtrlES6 } from 'app/angular/panel/query_ctrl';\n\nconst PanelCtrl = makeClassES5Compatible(PanelCtrlES6);\nconst MetricsPanelCtrl = makeClassES5Compatible(MetricsPanelCtrlES6);\nconst QueryCtrl = makeClassES5Compatible(QueryCtrlES6);\n\nexport { PanelCtrl, MetricsPanelCtrl, QueryCtrl, loadPluginCss };\n"],"names":["DEFAULT_PORTS","http","https","ftp","AngularLocationWrapper","constructor","this","absUrl","wrapInDeprecationWarning","hash","host","path","port","protocol","replace","search","state","url","fn","replacement","self","deprecationWarning","name","apply","arguments","window","location","origin","newHash","navigationLogger","Error","locationService","slice","URL","href","hostname","pathname","parsedPath","String","startsWith","length","parseInt","paramValue","newQuery","locationSearchToObject","key","Object","keys","undefined","updatedUrl","urlUtil","newUrl","trim","MetricsPanelCtrl","PanelCtrl","$scope","$injector","super","next","data","panelData","LoadingState","loading","processDataError","error","angularDirtyCheck","request","timeInfo","timeRange","range","useDataFrames","handleDataFrames","series","legacy","map","v","toLegacyResponseData","handleQueryResult","contextSrv","get","datasourceSrv","timeSrv","templateSrv","panel","datasource","events","on","PanelEvents","onMetricsPanelRefresh","bind","onPanelTearDown","onMetricsPanelMounted","queryRunner","getQueryRunner","querySubscription","getData","withTransforms","withFieldConfig","subscribe","panelDataObserver","unsubscribe","otherPanelInFullscreenMode","snapshotData","updateTimeRange","isArray","$timeout","emit","scopedVars","then","issueQueries","catch","err","cancelled","console","log","message","$root","$$phase","$digest","newTimeData","applyPanelTimeOverrides","run","queries","targets","panelId","id","dashboardId","dashboard","timezone","getTimezone","maxDataPoints","width","minInterval","interval","publicDashboardAccessToken","meta","cacheTimeout","transformations","snapshot","frame","toDataFrameDTO","result","plugin","$parent","editorTabs","$location","EventBusSrv","timing","config","type","pluginId","pluginName","$on","panelDidMount","panelInitialized","renderingCompleted","profiler","refresh","publishAppEvent","event","payload","appEvent","initEditMode","editModeInitiated","addEditorTab","title","directiveFn","index","icon","editorTab","isString","templateUrl","splice","push","getExtendedMenu","menu","async","otherPanelInFullscreen","render","QueryCtrl","panelCtrl","ctrl","target","isLastQuery","indexOf","DataProcessor","getSeriesList","options","list","dataList","i","timeField","getTimeField","applyNullInsertThreshold","refFieldName","j","fields","field","FieldType","getFieldDisplayName","datapoints","r","values","dateTime","valueOf","toTimeSeries","xaxis","mode","stack","first","alias","aliasEscaped","concat","dataFrameIndex","fieldIndex","colorIndex","colors","color","aliasColors","TimeSeries","unit","last","from","isOutsideRange","setPanelDefaultsForNewXAxisMode","bars","lines","points","legend","show","tooltip","shared","validateXAxisSeriesValue","validOptions","getXAxisValueOptions","find","value","text","pluckDeep","obj","property","propertyParts","split","getColorScale","colorScheme","lightTheme","maxValue","minValue","colorInterpolator","d3ScaleChromatic","colorScaleInverted","invert","start","end","d3","scaleSequential","domain","getOpacityScale","legendOpacityScale","colorScale","scaleLinear","scalePow","exponent","drawLegendValues","elem","rangeFrom","rangeTo","legendWidth","valuesRange","legendElem","$","legendDomElement","select","childNodes","legendValueScale","ticks","tickStepSize","tickStep","ticksNum","Math","ceil","firstTick","step","floor","getFirstCloseTick","current","isValueCloseTo","sortBy","uniq","buildLegendTicks","xAxis","axisBottom","tickValues","tickSize","colorRect","posY","svgElem","height","baseVal","getSvgElemHeight","posX","x","getSvgElemX","append","attr","call","remove","clearLegend","empty","val","valueTo","abs","coreModule","restrict","template","link","scope","attrs","outerWidth","colorSchemes","legendHeight","valuesNumber","rangeStep","selectAll","enter","d","drawSimpleColorLegend","colorOptions","cardColor","style","drawSimpleOpacityLegend","isEmpty","cards","cardStats","isNil","min","max","widthFactor","round","drawColorLegend","opacityScale","drawOpacityLegend","AxesEditorCtrl","uiSegmentSrv","yAxis","format","editor","logScales","linear","dataFormats","yBucketBoundModes","Auto","Upper","Lower","Middle","axesEditor","controller","HeatmapDisplayEditorCtrl","heatmapDisplayEditor","sortSeriesByLabel","s1","s2","label1","label2","parseHistogramLabel","label","Infinity","Number","isNaN","convertToCards","buckets","hideZero","forEach","xBucket","yBucket","card","y","yBounds","bounds","count","pushToXBuckets","point","bucketNum","seriesName","pointExt","pushToYBuckets","getValueBucketBound","yBucketSize","logBase","getBucketBound","yBucketSplitFactor","getLogScaleBucketBounds","bottom","getLogScaleBucketBound","getBucketBounds","bucketSize","top","convertToValueBuckets","valueLog","logp","pow","powTop","additionalBucketSize","additionalLog","convertToLogScaleValueBuckets","base","getDistance","a","b","HISTOGRAM_WIDTH","HeatmapTooltip","heatmapPanel","mouseOverBucket","originalFillColor","onMouseLeave","destroy","onMouseMove","e","move","add","pos","panelRelY","xBucketIndex","yBucketIndex","getBucketIndexes","boundBottom","boundTop","xData","yData","bucket","bucketIndex","toString","time","formatDate","countValueFormatter","bucketBoundFormatter","isNumber","tooltipDecimals","tickValueFormatter","decimals","scaledDecimals","tooltipHtml","tsBuckets","tickFormatter","valIndex","tsBucketsFormatted","yBucketBound","showHistogram","html","addHistogram","getXBucketIndex","getYBucketIndex","xBucketSize","getSharedTooltipPos","pageX","offset","left","xScale","pageY","chartHeight","histogramData","filter","histXScale","yScale","copy","barWidth","barNumberFactor","histogramDomain","reduce","sum","histYScale","node","tooltipWidth","clientWidth","tooltipHeight","clientHeight","innerWidth","pageYOffset","innerHeight","fmt","getValueFormat","formattedValueToString","HeatmapRenderer","$heatmap","selection","active","x1","x2","padding","right","margin","dataRangeWidingFactor","onRender","LegacyGraphHoverEvent","onGraphHover","LegacyGraphHoverClearEvent","onGraphHoverClear","onMouseDown","hoverEvent","clearCrosshair","drawSharedCrosshair","setElementHeight","row","css","getYAxisWidth","panelYAxisWidth","getPanelYAxisWidth","axisText","nodes","getBBox","getXAxisHeight","axisLinePosition","parseFloat","addXAxis","to","chartWidth","graphTimeFormat","timeZone","tickFormat","date","dateTimeFormat","tickPadding","yAxisWidth","heatmap","addYAxis","tickInterval","ticksUtils","heatmapStats","yMin","yMax","wideYAxisRange","decimalsAuto","flotTickSize","tickSizeInner","tickSizeOuter","yWiding","addLogYAxis","adjustLogRange","minLog","adjustLogMin","adjustLogMax","logScaleTickValues","addYAxisFromBuckets","valueFormatted","toNumber","scale","trimmed","substring","tickShift","domainMin","domainMax","tickValue","fixYAxisTickSize","addAxes","chartTop","chartBottom","dataFormat","xAxisHeight","addHeatmapCanvas","heatmapElem","cardPadding","cardRound","addHeatmap","yBuckets","emptyBucket","nullBucket","minBucket","newBucket","mergeZeroBuckets","cardsData","maxValueAuto","minValueAuto","setCardSize","getCardX","getCardWidth","getCardY","getCardHeight","getCardColor","getCardOpacity","highlightCard","resetCardHighLight","highlightColor","darker","strokeColor","brighter","currentCard","xGridSize","yGridSize","splitFactor","cardWidth","cardHeight","w","h","getEventOffset","elemOffset","clientX","clientY","mouseUpHandler","onMouseUp","document","one","unbind","selectionRange","timeFrom","timeTo","setTime","toUtc","clearSelection","publish","limitSelection","drawSelection","getEventPos","drawCrosshair","emitGraphHoverEvent","y1","posX1","posX2","selectionX","selectionWidth","position","graphTooltip","panelDefaults","reverseYBuckets","xBucketNumber","yBucketNumber","highlightCards","hideZeroBuckets","colorModes","opacityScales","dsSupportHistogramSort","HeatmapCtrl","selectionActivated","defaultsDeep","processor","onDataFramesReceived","onSnapshotLoad","onInitEditMode","onCardColorChange","pluginVersion","unitFormats","kbn","zoomOut","evt","appEvents","ZoomOutEvent","convertHistogramToHeatmapData","convertTimeSeriesToHeatmapData","bucketsData","xBucketSizeByNumber","rangeUtil","parseSeries","seriesList","bucketBound","convertToHeatMap","panelDatasource","getPanelDataSourceType","includes","sort","reverse","bound","histogramToHeatmap","distance","calculateBucketSize","getProcessedDataFrames","ts","flotpairs","getFlotPairs","nullPointMode","dataWarning","tip","onDataError","newColor","_min","s","stats","logmin","_max","parseHistogramSeries","rendering","makeClassES5Compatible","PanelCtrlES6","MetricsPanelCtrlES6","QueryCtrlES6"],"sourceRoot":""}