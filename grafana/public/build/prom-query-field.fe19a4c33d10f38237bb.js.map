{"version":3,"file":"prom-query-field.fe19a4c33d10f38237bb.js","mappings":"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","sources":["webpack://grafana/../../opt/drone/yarncache/monaco-promql-npm-1.7.4-1b0c13a666-9fe2708be5.zip/node_modules/monaco-promql/promql/promql.contribution.js","webpack://grafana/./public/app/plugins/datasource/prometheus/components/monaco-query-field/getOverrideServices.ts","webpack://grafana/./public/app/plugins/datasource/prometheus/components/monaco-query-field/monaco-completion-provider/util.ts","webpack://grafana/./public/app/plugins/datasource/prometheus/components/monaco-query-field/monaco-completion-provider/completions.ts","webpack://grafana/./public/app/plugins/datasource/prometheus/components/monaco-query-field/monaco-completion-provider/situation.ts","webpack://grafana/./public/app/plugins/datasource/prometheus/components/monaco-query-field/monaco-completion-provider/index.ts","webpack://grafana/./public/app/plugins/datasource/prometheus/components/monaco-query-field/MonacoQueryField.tsx","webpack://grafana/./.yarn/__virtual__/react-use-virtual-0c21d950b6/3/opt/drone/yarncache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/useLatest.js"],"sourcesContent":["// The MIT License (MIT)\n//\n// Copyright (c) Celian Garcia and Augustin Husson @ Amadeus IT Group\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n'use strict';\n// noinspection JSUnusedGlobalSymbols\nexport var promLanguageDefinition = {\n    id: 'promql',\n    extensions: ['.promql'],\n    aliases: ['Prometheus', 'prometheus', 'prom', 'Prom', 'promql', 'Promql', 'promQL', 'PromQL'],\n    mimetypes: [],\n    loader: function () { return import('./promql'); } // eslint-disable-line @typescript-eslint/explicit-function-return-type\n};\n","import { monacoTypes } from '@grafana/ui';\n\n// this thing here is a workaround in a way.\n// what we want to achieve, is that when the autocomplete-window\n// opens, the \"second, extra popup\" with the extra help,\n// also opens automatically.\n// but there is no API to achieve it.\n// the way to do it is to implement the `storageService`\n// interface, and provide our custom implementation,\n// which will default to `true` for the correct string-key.\n// unfortunately, while the typescript-interface exists,\n// it is not exported from monaco-editor,\n// so we cannot rely on typescript to make sure\n// we do it right. all we can do is to manually\n// lookup the interface, and make sure we code our code right.\n// our code is a \"best effort\" approach,\n// i am not 100% how the `scope` and `target` things work,\n// but so far it seems to work ok.\n// i would use an another approach, if there was one available.\n\nfunction makeStorageService() {\n  // we need to return an object that fulfills this interface:\n  // https://github.com/microsoft/vscode/blob/ff1e16eebb93af79fd6d7af1356c4003a120c563/src/vs/platform/storage/common/storage.ts#L37\n  // unfortunately it is not export from monaco-editor\n\n  const strings = new Map<string, string>();\n\n  // we want this to be true by default\n  strings.set('expandSuggestionDocs', true.toString());\n\n  return {\n    // we do not implement the on* handlers\n    onDidChangeValue: (data: unknown): void => undefined,\n    onDidChangeTarget: (data: unknown): void => undefined,\n    onWillSaveState: (data: unknown): void => undefined,\n\n    get: (key: string, scope: unknown, fallbackValue?: string): string | undefined => {\n      return strings.get(key) ?? fallbackValue;\n    },\n\n    getBoolean: (key: string, scope: unknown, fallbackValue?: boolean): boolean | undefined => {\n      const val = strings.get(key);\n      if (val !== undefined) {\n        // the interface-docs say the value will be converted\n        // to a boolean but do not specify how, so we improvise\n        return val === 'true';\n      } else {\n        return fallbackValue;\n      }\n    },\n\n    getNumber: (key: string, scope: unknown, fallbackValue?: number): number | undefined => {\n      const val = strings.get(key);\n      if (val !== undefined) {\n        return parseInt(val, 10);\n      } else {\n        return fallbackValue;\n      }\n    },\n\n    store: (\n      key: string,\n      value: string | boolean | number | undefined | null,\n      scope: unknown,\n      target: unknown\n    ): void => {\n      // the interface-docs say if the value is nullish, it should act as delete\n      if (value === null || value === undefined) {\n        strings.delete(key);\n      } else {\n        strings.set(key, value.toString());\n      }\n    },\n\n    remove: (key: string, scope: unknown): void => {\n      strings.delete(key);\n    },\n\n    keys: (scope: unknown, target: unknown): string[] => {\n      return Array.from(strings.keys());\n    },\n\n    logStorage: (): void => {\n      console.log('logStorage: not implemented');\n    },\n\n    migrate: (): Promise<void> => {\n      // we do not implement this\n      return Promise.resolve(undefined);\n    },\n\n    isNew: (scope: unknown): boolean => {\n      // we create a new storage for every session, we do not persist it,\n      // so we return `true`.\n      return true;\n    },\n\n    flush: (reason?: unknown): Promise<void> => {\n      // we do not implement this\n      return Promise.resolve(undefined);\n    },\n  };\n}\n\nlet overrideServices: monacoTypes.editor.IEditorOverrideServices | null = null;\n\nexport function getOverrideServices(): monacoTypes.editor.IEditorOverrideServices {\n  // only have one instance of this for every query editor\n  if (overrideServices === null) {\n    overrideServices = {\n      storageService: makeStorageService(),\n    };\n  }\n\n  return overrideServices;\n}\n","// this helper class is used to make typescript warn you when you forget\n// a case-block in a switch statement.\n// example code that triggers the typescript-error:\n//\n// const x:'A'|'B'|'C' = 'A';\n//\n// switch(x) {\n//   case 'A':\n//     // something\n//   case 'B':\n//     // something\n//   default:\n//     throw new NeverCaseError(x);\n// }\n//\n//\n// typescript will show an error in this case,\n// when you add the missing `case 'C'` code,\n// the problem will be fixed.\n\nexport class NeverCaseError extends Error {\n  constructor(value: never) {\n    super('should never happen');\n  }\n}\n","import { escapeLabelValueInExactSelector } from '../../../language_utils';\nimport { FUNCTIONS } from '../../../promql';\n\nimport type { Situation, Label } from './situation';\nimport { NeverCaseError } from './util';\n// FIXME: we should not load this from the \"outside\", but we cannot do that while we have the \"old\" query-field too\n\nexport type CompletionType = 'HISTORY' | 'FUNCTION' | 'METRIC_NAME' | 'DURATION' | 'LABEL_NAME' | 'LABEL_VALUE';\n\ntype Completion = {\n  type: CompletionType;\n  label: string;\n  insertText: string;\n  detail?: string;\n  documentation?: string;\n  triggerOnInsert?: boolean;\n};\n\ntype Metric = {\n  name: string;\n  help: string;\n  type: string;\n};\n\nexport type DataProvider = {\n  getHistory: () => Promise<string[]>;\n  getAllMetricNames: () => Promise<Metric[]>;\n  getAllLabelNames: () => Promise<string[]>;\n  getLabelValues: (labelName: string) => Promise<string[]>;\n  getSeriesValues: (name: string, match: string) => Promise<string[]>;\n  getSeriesLabels: (selector: string, otherLabels: Label[]) => Promise<string[]>;\n};\n\n// we order items like: history, functions, metrics\n\nasync function getAllMetricNamesCompletions(dataProvider: DataProvider): Promise<Completion[]> {\n  const metrics = await dataProvider.getAllMetricNames();\n  return metrics.map((metric) => ({\n    type: 'METRIC_NAME',\n    label: metric.name,\n    insertText: metric.name,\n    detail: `${metric.name} : ${metric.type}`,\n    documentation: metric.help,\n  }));\n}\n\nconst FUNCTION_COMPLETIONS: Completion[] = FUNCTIONS.map((f) => ({\n  type: 'FUNCTION',\n  label: f.label,\n  insertText: f.insertText ?? '', // i don't know what to do when this is nullish. it should not be.\n  detail: f.detail,\n  documentation: f.documentation,\n}));\n\nasync function getAllFunctionsAndMetricNamesCompletions(dataProvider: DataProvider): Promise<Completion[]> {\n  const metricNames = await getAllMetricNamesCompletions(dataProvider);\n  return [...FUNCTION_COMPLETIONS, ...metricNames];\n}\n\nconst DURATION_COMPLETIONS: Completion[] = [\n  '$__interval',\n  '$__range',\n  '$__rate_interval',\n  '1m',\n  '5m',\n  '10m',\n  '30m',\n  '1h',\n  '1d',\n].map((text) => ({\n  type: 'DURATION',\n  label: text,\n  insertText: text,\n}));\n\nasync function getAllHistoryCompletions(dataProvider: DataProvider): Promise<Completion[]> {\n  // function getAllHistoryCompletions(queryHistory: PromHistoryItem[]): Completion[] {\n  // NOTE: the typescript types are wrong. historyItem.query.expr can be undefined\n  const allHistory = await dataProvider.getHistory();\n  // FIXME: find a better history-limit\n  return allHistory.slice(0, 10).map((expr) => ({\n    type: 'HISTORY',\n    label: expr,\n    insertText: expr,\n  }));\n}\n\nfunction makeSelector(metricName: string | undefined, labels: Label[]): string {\n  const allLabels = [...labels];\n\n  // we transform the metricName to a label, if it exists\n  if (metricName !== undefined) {\n    allLabels.push({ name: '__name__', value: metricName, op: '=' });\n  }\n\n  const allLabelTexts = allLabels.map(\n    (label) => `${label.name}${label.op}\"${escapeLabelValueInExactSelector(label.value)}\"`\n  );\n\n  return `{${allLabelTexts.join(',')}}`;\n}\n\nasync function getLabelNames(\n  metric: string | undefined,\n  otherLabels: Label[],\n  dataProvider: DataProvider\n): Promise<string[]> {\n  if (metric === undefined && otherLabels.length === 0) {\n    // if there is no filtering, we have to use a special endpoint\n    return dataProvider.getAllLabelNames();\n  } else {\n    const selector = makeSelector(metric, otherLabels);\n    return await dataProvider.getSeriesLabels(selector, otherLabels);\n  }\n}\n\nasync function getLabelNamesForCompletions(\n  metric: string | undefined,\n  suffix: string,\n  triggerOnInsert: boolean,\n  otherLabels: Label[],\n  dataProvider: DataProvider\n): Promise<Completion[]> {\n  const labelNames = await getLabelNames(metric, otherLabels, dataProvider);\n  return labelNames.map((text) => ({\n    type: 'LABEL_NAME',\n    label: text,\n    insertText: `${text}${suffix}`,\n    triggerOnInsert,\n  }));\n}\n\nasync function getLabelNamesForSelectorCompletions(\n  metric: string | undefined,\n  otherLabels: Label[],\n  dataProvider: DataProvider\n): Promise<Completion[]> {\n  return getLabelNamesForCompletions(metric, '=', true, otherLabels, dataProvider);\n}\nasync function getLabelNamesForByCompletions(\n  metric: string | undefined,\n  otherLabels: Label[],\n  dataProvider: DataProvider\n): Promise<Completion[]> {\n  return getLabelNamesForCompletions(metric, '', false, otherLabels, dataProvider);\n}\n\nasync function getLabelValues(\n  metric: string | undefined,\n  labelName: string,\n  otherLabels: Label[],\n  dataProvider: DataProvider\n): Promise<string[]> {\n  if (metric === undefined && otherLabels.length === 0) {\n    // if there is no filtering, we have to use a special endpoint\n    return dataProvider.getLabelValues(labelName);\n  } else {\n    const selector = makeSelector(metric, otherLabels);\n    return await dataProvider.getSeriesValues(labelName, selector);\n  }\n}\n\nasync function getLabelValuesForMetricCompletions(\n  metric: string | undefined,\n  labelName: string,\n  betweenQuotes: boolean,\n  otherLabels: Label[],\n  dataProvider: DataProvider\n): Promise<Completion[]> {\n  const values = await getLabelValues(metric, labelName, otherLabels, dataProvider);\n  return values.map((text) => ({\n    type: 'LABEL_VALUE',\n    label: text,\n    insertText: betweenQuotes ? text : `\"${text}\"`, // FIXME: escaping strange characters?\n  }));\n}\n\nexport async function getCompletions(situation: Situation, dataProvider: DataProvider): Promise<Completion[]> {\n  switch (situation.type) {\n    case 'IN_DURATION':\n      return DURATION_COMPLETIONS;\n    case 'IN_FUNCTION':\n      return getAllFunctionsAndMetricNamesCompletions(dataProvider);\n    case 'AT_ROOT': {\n      return getAllFunctionsAndMetricNamesCompletions(dataProvider);\n    }\n    case 'EMPTY': {\n      const metricNames = await getAllMetricNamesCompletions(dataProvider);\n      const historyCompletions = await getAllHistoryCompletions(dataProvider);\n      return [...historyCompletions, ...FUNCTION_COMPLETIONS, ...metricNames];\n    }\n    case 'IN_LABEL_SELECTOR_NO_LABEL_NAME':\n      return getLabelNamesForSelectorCompletions(situation.metricName, situation.otherLabels, dataProvider);\n    case 'IN_GROUPING':\n      return getLabelNamesForByCompletions(situation.metricName, situation.otherLabels, dataProvider);\n    case 'IN_LABEL_SELECTOR_WITH_LABEL_NAME':\n      return getLabelValuesForMetricCompletions(\n        situation.metricName,\n        situation.labelName,\n        situation.betweenQuotes,\n        situation.otherLabels,\n        dataProvider\n      );\n    default:\n      throw new NeverCaseError(situation);\n  }\n}\n","import type { SyntaxNode, Tree } from '@lezer/common';\nimport {\n  AggregateExpr,\n  AggregateModifier,\n  EqlRegex,\n  EqlSingle,\n  FunctionCallBody,\n  GroupingLabels,\n  Identifier,\n  LabelMatcher,\n  LabelMatchers,\n  LabelMatchList,\n  LabelName,\n  MatchOp,\n  MatrixSelector,\n  MetricIdentifier,\n  Neq,\n  NeqRegex,\n  parser,\n  PromQL,\n  StringLiteral,\n  VectorSelector,\n} from '@prometheus-io/lezer-promql';\n\nimport { NeverCaseError } from './util';\n\ntype Direction = 'parent' | 'firstChild' | 'lastChild' | 'nextSibling';\n\ntype NodeTypeId =\n  | 0 // this is used as error-id\n  | typeof AggregateExpr\n  | typeof AggregateModifier\n  | typeof FunctionCallBody\n  | typeof GroupingLabels\n  | typeof Identifier\n  | typeof LabelMatcher\n  | typeof LabelMatchers\n  | typeof LabelMatchList\n  | typeof LabelName\n  | typeof MetricIdentifier\n  | typeof PromQL\n  | typeof StringLiteral\n  | typeof VectorSelector\n  | typeof MatrixSelector\n  | typeof MatchOp\n  | typeof EqlSingle\n  | typeof Neq\n  | typeof EqlRegex\n  | typeof NeqRegex;\n\ntype Path = Array<[Direction, NodeTypeId]>;\n\nfunction move(node: SyntaxNode, direction: Direction): SyntaxNode | null {\n  switch (direction) {\n    case 'parent':\n      return node.parent;\n    case 'firstChild':\n      return node.firstChild;\n    case 'lastChild':\n      return node.lastChild;\n    case 'nextSibling':\n      return node.nextSibling;\n    default:\n      throw new NeverCaseError(direction);\n  }\n}\n\nfunction walk(node: SyntaxNode, path: Path): SyntaxNode | null {\n  let current: SyntaxNode | null = node;\n  for (const [direction, expectedType] of path) {\n    current = move(current, direction);\n    if (current === null) {\n      // we could not move in the direction, we stop\n      return null;\n    }\n    if (current.type.id !== expectedType) {\n      // the reached node has wrong type, we stop\n      return null;\n    }\n  }\n  return current;\n}\n\nfunction getNodeText(node: SyntaxNode, text: string): string {\n  return text.slice(node.from, node.to);\n}\n\nfunction parsePromQLStringLiteral(text: string): string {\n  // if it is a string-literal, it is inside quotes of some kind\n  const inside = text.slice(1, text.length - 1);\n\n  // FIXME: support https://prometheus.io/docs/prometheus/latest/querying/basics/#string-literals\n  // FIXME: maybe check other promql code, if all is supported or not\n\n  // for now we do only some very simple un-escaping\n\n  // we start with double-quotes\n  if (text.startsWith('\"') && text.endsWith('\"')) {\n    // NOTE: this is not 100% perfect, we only unescape the double-quote,\n    // there might be other characters too\n    return inside.replace(/\\\\\"/, '\"');\n  }\n\n  // then single-quote\n  if (text.startsWith(\"'\") && text.endsWith(\"'\")) {\n    // NOTE: this is not 100% perfect, we only unescape the single-quote,\n    // there might be other characters too\n    return inside.replace(/\\\\'/, \"'\");\n  }\n\n  // then backticks\n  if (text.startsWith('`') && text.endsWith('`')) {\n    return inside;\n  }\n\n  throw new Error('FIXME: invalid string literal');\n}\n\ntype LabelOperator = '=' | '!=' | '=~' | '!~';\n\nexport type Label = {\n  name: string;\n  value: string;\n  op: LabelOperator;\n};\n\nexport type Situation =\n  | {\n      type: 'IN_FUNCTION';\n    }\n  | {\n      type: 'AT_ROOT';\n    }\n  | {\n      type: 'EMPTY';\n    }\n  | {\n      type: 'IN_DURATION';\n    }\n  | {\n      type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME';\n      metricName?: string;\n      otherLabels: Label[];\n    }\n  | {\n      type: 'IN_GROUPING';\n      metricName: string;\n      otherLabels: Label[];\n    }\n  | {\n      type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME';\n      metricName?: string;\n      labelName: string;\n      betweenQuotes: boolean;\n      otherLabels: Label[];\n    };\n\ntype Resolver = {\n  path: NodeTypeId[];\n  fun: (node: SyntaxNode, text: string, pos: number) => Situation | null;\n};\n\nfunction isPathMatch(resolverPath: NodeTypeId[], cursorPath: number[]): boolean {\n  return resolverPath.every((item, index) => item === cursorPath[index]);\n}\n\nconst ERROR_NODE_NAME: NodeTypeId = 0; // this is used as error-id\n\nconst RESOLVERS: Resolver[] = [\n  {\n    path: [LabelMatchers, VectorSelector],\n    fun: resolveLabelKeysWithEquals,\n  },\n  {\n    path: [PromQL],\n    fun: resolveTopLevel,\n  },\n  {\n    path: [FunctionCallBody],\n    fun: resolveInFunction,\n  },\n  {\n    path: [StringLiteral, LabelMatcher],\n    fun: resolveLabelMatcher,\n  },\n  {\n    path: [ERROR_NODE_NAME, LabelMatcher],\n    fun: resolveLabelMatcher,\n  },\n  {\n    path: [ERROR_NODE_NAME, MatrixSelector],\n    fun: resolveDurations,\n  },\n  {\n    path: [GroupingLabels],\n    fun: resolveLabelsForGrouping,\n  },\n];\n\nconst LABEL_OP_MAP = new Map<number, LabelOperator>([\n  [EqlSingle, '='],\n  [EqlRegex, '=~'],\n  [Neq, '!='],\n  [NeqRegex, '!~'],\n]);\n\nfunction getLabelOp(opNode: SyntaxNode): LabelOperator | null {\n  const opChild = opNode.firstChild;\n  if (opChild === null) {\n    return null;\n  }\n\n  return LABEL_OP_MAP.get(opChild.type.id) ?? null;\n}\n\nfunction getLabel(labelMatcherNode: SyntaxNode, text: string): Label | null {\n  if (labelMatcherNode.type.id !== LabelMatcher) {\n    return null;\n  }\n\n  const nameNode = walk(labelMatcherNode, [['firstChild', LabelName]]);\n\n  if (nameNode === null) {\n    return null;\n  }\n\n  const opNode = walk(nameNode, [['nextSibling', MatchOp]]);\n  if (opNode === null) {\n    return null;\n  }\n\n  const op = getLabelOp(opNode);\n  if (op === null) {\n    return null;\n  }\n\n  const valueNode = walk(labelMatcherNode, [['lastChild', StringLiteral]]);\n\n  if (valueNode === null) {\n    return null;\n  }\n\n  const name = getNodeText(nameNode, text);\n  const value = parsePromQLStringLiteral(getNodeText(valueNode, text));\n\n  return { name, value, op };\n}\n\nfunction getLabels(labelMatchersNode: SyntaxNode, text: string): Label[] {\n  if (labelMatchersNode.type.id !== LabelMatchers) {\n    return [];\n  }\n\n  let listNode: SyntaxNode | null = walk(labelMatchersNode, [['firstChild', LabelMatchList]]);\n\n  const labels: Label[] = [];\n\n  while (listNode !== null) {\n    const matcherNode = walk(listNode, [['lastChild', LabelMatcher]]);\n    if (matcherNode === null) {\n      // unexpected, we stop\n      return [];\n    }\n\n    const label = getLabel(matcherNode, text);\n    if (label !== null) {\n      labels.push(label);\n    }\n\n    // there might be more labels\n    listNode = walk(listNode, [['firstChild', LabelMatchList]]);\n  }\n\n  // our labels-list is last-first, so we reverse it\n  labels.reverse();\n\n  return labels;\n}\n\nfunction getNodeChildren(node: SyntaxNode): SyntaxNode[] {\n  let child: SyntaxNode | null = node.firstChild;\n  const children: SyntaxNode[] = [];\n  while (child !== null) {\n    children.push(child);\n    child = child.nextSibling;\n  }\n  return children;\n}\n\nfunction getNodeInSubtree(node: SyntaxNode, typeId: NodeTypeId): SyntaxNode | null {\n  // first we try the current node\n  if (node.type.id === typeId) {\n    return node;\n  }\n\n  // then we try the children\n  const children = getNodeChildren(node);\n  for (const child of children) {\n    const n = getNodeInSubtree(child, typeId);\n    if (n !== null) {\n      return n;\n    }\n  }\n\n  return null;\n}\n\nfunction resolveLabelsForGrouping(node: SyntaxNode, text: string, pos: number): Situation | null {\n  const aggrExpNode = walk(node, [\n    ['parent', AggregateModifier],\n    ['parent', AggregateExpr],\n  ]);\n  if (aggrExpNode === null) {\n    return null;\n  }\n  const bodyNode = aggrExpNode.getChild(FunctionCallBody);\n  if (bodyNode === null) {\n    return null;\n  }\n\n  const metricIdNode = getNodeInSubtree(bodyNode, MetricIdentifier);\n  if (metricIdNode === null) {\n    return null;\n  }\n\n  const idNode = walk(metricIdNode, [['firstChild', Identifier]]);\n  if (idNode === null) {\n    return null;\n  }\n\n  const metricName = getNodeText(idNode, text);\n  return {\n    type: 'IN_GROUPING',\n    metricName,\n    otherLabels: [],\n  };\n}\n\nfunction resolveLabelMatcher(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // we can arrive here in two situation. `node` is either:\n  // - a StringNode (like in `{job=\"^\"}`)\n  // - or an error node (like in `{job=^}`)\n  const inStringNode = !node.type.isError;\n\n  const parent = walk(node, [['parent', LabelMatcher]]);\n  if (parent === null) {\n    return null;\n  }\n\n  const labelNameNode = walk(parent, [['firstChild', LabelName]]);\n  if (labelNameNode === null) {\n    return null;\n  }\n\n  const labelName = getNodeText(labelNameNode, text);\n\n  // now we need to go up, to the parent of LabelMatcher,\n  // there can be one or many `LabelMatchList` parents, we have\n  // to go through all of them\n\n  const firstListNode = walk(parent, [['parent', LabelMatchList]]);\n  if (firstListNode === null) {\n    return null;\n  }\n\n  let listNode = firstListNode;\n\n  // we keep going through the parent-nodes\n  // as long as they are LabelMatchList.\n  // as soon as we reawch LabelMatchers, we stop\n  let labelMatchersNode: SyntaxNode | null = null;\n  while (labelMatchersNode === null) {\n    const p = listNode.parent;\n    if (p === null) {\n      return null;\n    }\n\n    const { id } = p.type;\n\n    switch (id) {\n      case LabelMatchList:\n        //we keep looping\n        listNode = p;\n        continue;\n      case LabelMatchers:\n        // we reached the end, we can stop the loop\n        labelMatchersNode = p;\n        continue;\n      default:\n        // we reached some other node, we stop\n        return null;\n    }\n  }\n\n  // now we need to find the other names\n  const allLabels = getLabels(labelMatchersNode, text);\n\n  // we need to remove \"our\" label from all-labels, if it is in there\n  const otherLabels = allLabels.filter((label) => label.name !== labelName);\n\n  const metricNameNode = walk(labelMatchersNode, [\n    ['parent', VectorSelector],\n    ['firstChild', MetricIdentifier],\n    ['firstChild', Identifier],\n  ]);\n\n  if (metricNameNode === null) {\n    // we are probably in a situation without a metric name\n    return {\n      type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME',\n      labelName,\n      betweenQuotes: inStringNode,\n      otherLabels,\n    };\n  }\n\n  const metricName = getNodeText(metricNameNode, text);\n\n  return {\n    type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME',\n    metricName,\n    labelName,\n    betweenQuotes: inStringNode,\n    otherLabels,\n  };\n}\n\nfunction resolveTopLevel(node: SyntaxNode, text: string, pos: number): Situation {\n  return {\n    type: 'AT_ROOT',\n  };\n}\n\nfunction resolveInFunction(node: SyntaxNode, text: string, pos: number): Situation {\n  return {\n    type: 'IN_FUNCTION',\n  };\n}\n\nfunction resolveDurations(node: SyntaxNode, text: string, pos: number): Situation {\n  return {\n    type: 'IN_DURATION',\n  };\n}\n\nfunction subTreeHasError(node: SyntaxNode): boolean {\n  return getNodeInSubtree(node, ERROR_NODE_NAME) !== null;\n}\n\nfunction resolveLabelKeysWithEquals(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // for example `something{^}`\n\n  // there are some false positives that can end up in this situation, that we want\n  // to eliminate:\n  // `something{a~^}` (if this subtree contains any error-node, we stop)\n  if (subTreeHasError(node)) {\n    return null;\n  }\n\n  // next false positive:\n  // `something{a=\"1\"^}`\n  const child = walk(node, [['firstChild', LabelMatchList]]);\n  if (child !== null) {\n    // means the label-matching part contains at least one label already.\n    //\n    // in this case, we will need to have a `,` character at the end,\n    // to be able to suggest adding the next label.\n    // the area between the end-of-the-child-node and the cursor-pos\n    // must contain a `,` in this case.\n    const textToCheck = text.slice(child.to, pos);\n\n    if (!textToCheck.includes(',')) {\n      return null;\n    }\n  }\n\n  const metricNameNode = walk(node, [\n    ['parent', VectorSelector],\n    ['firstChild', MetricIdentifier],\n    ['firstChild', Identifier],\n  ]);\n\n  const otherLabels = getLabels(node, text);\n\n  if (metricNameNode === null) {\n    // we are probably in a situation without a metric name.\n    return {\n      type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME',\n      otherLabels,\n    };\n  }\n\n  const metricName = getNodeText(metricNameNode, text);\n\n  return {\n    type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME',\n    metricName,\n    otherLabels,\n  };\n}\n\n// we find the first error-node in the tree that is at the cursor-position.\n// NOTE: this might be too slow, might need to optimize it\n// (ideas: we do not need to go into every subtree, based on from/to)\n// also, only go to places that are in the sub-tree of the node found\n// by default by lezer. problem is, `next()` will go upward too,\n// and we do not want to go higher than our node\nfunction getErrorNode(tree: Tree, pos: number): SyntaxNode | null {\n  const cur = tree.cursorAt(pos);\n  while (true) {\n    if (cur.from === pos && cur.to === pos) {\n      const { node } = cur;\n      if (node.type.isError) {\n        return node;\n      }\n    }\n\n    if (!cur.next()) {\n      break;\n    }\n  }\n  return null;\n}\n\nexport function getSituation(text: string, pos: number): Situation | null {\n  // there is a special-case when we are at the start of writing text,\n  // so we handle that case first\n\n  if (text === '') {\n    return {\n      type: 'EMPTY',\n    };\n  }\n\n  /*\n\tPromQL\n  Expr\n  VectorSelector\n  LabelMatchers\n  */\n  const tree = parser.parse(text);\n\n  // if the tree contains error, it is very probable that\n  // our node is one of those error-nodes.\n  // also, if there are errors, the node lezer finds us,\n  // might not be the best node.\n  // so first we check if there is an error-node at the cursor-position\n  const maybeErrorNode = getErrorNode(tree, pos);\n\n  const cur = maybeErrorNode != null ? maybeErrorNode.cursor() : tree.cursorAt(pos);\n  const currentNode = cur.node;\n\n  const ids = [cur.type.id];\n  while (cur.parent()) {\n    ids.push(cur.type.id);\n  }\n\n  for (let resolver of RESOLVERS) {\n    // i do not use a foreach because i want to stop as soon\n    // as i find something\n    if (isPathMatch(resolver.path, ids)) {\n      return resolver.fun(currentNode, text, pos);\n    }\n  }\n\n  return null;\n}\n","import type { Monaco, monacoTypes } from '@grafana/ui';\n\nimport { getCompletions, DataProvider, CompletionType } from './completions';\nimport { getSituation } from './situation';\nimport { NeverCaseError } from './util';\n\nexport function getSuggestOptions(): monacoTypes.editor.ISuggestOptions {\n  return {\n    // monaco-editor sometimes provides suggestions automatically, i am not\n    // sure based on what, seems to be by analyzing the words already\n    // written.\n    // to try it out:\n    // - enter `go_goroutines{job~`\n    // - have the cursor at the end of the string\n    // - press ctrl-enter\n    // - you will get two suggestions\n    // those were not provided by grafana, they are offered automatically.\n    // i want to remove those. the only way i found is:\n    // - every suggestion-item has a `kind` attribute,\n    //   that controls the icon to the left of the suggestion.\n    // - items auto-generated by monaco have `kind` set to `text`.\n    // - we make sure grafana-provided suggestions do not have `kind` set to `text`.\n    // - and then we tell monaco not to show suggestions of kind `text`\n    showWords: false,\n  };\n}\n\nfunction getMonacoCompletionItemKind(type: CompletionType, monaco: Monaco): monacoTypes.languages.CompletionItemKind {\n  switch (type) {\n    case 'DURATION':\n      return monaco.languages.CompletionItemKind.Unit;\n    case 'FUNCTION':\n      return monaco.languages.CompletionItemKind.Variable;\n    case 'HISTORY':\n      return monaco.languages.CompletionItemKind.Snippet;\n    case 'LABEL_NAME':\n      return monaco.languages.CompletionItemKind.Enum;\n    case 'LABEL_VALUE':\n      return monaco.languages.CompletionItemKind.EnumMember;\n    case 'METRIC_NAME':\n      return monaco.languages.CompletionItemKind.Constructor;\n    default:\n      throw new NeverCaseError(type);\n  }\n}\nexport function getCompletionProvider(\n  monaco: Monaco,\n  dataProvider: DataProvider\n): monacoTypes.languages.CompletionItemProvider {\n  const provideCompletionItems = (\n    model: monacoTypes.editor.ITextModel,\n    position: monacoTypes.Position\n  ): monacoTypes.languages.ProviderResult<monacoTypes.languages.CompletionList> => {\n    const word = model.getWordAtPosition(position);\n    const range =\n      word != null\n        ? monaco.Range.lift({\n            startLineNumber: position.lineNumber,\n            endLineNumber: position.lineNumber,\n            startColumn: word.startColumn,\n            endColumn: word.endColumn,\n          })\n        : monaco.Range.fromPositions(position);\n    // documentation says `position` will be \"adjusted\" in `getOffsetAt`\n    // i don't know what that means, to be sure i clone it\n    const positionClone = {\n      column: position.column,\n      lineNumber: position.lineNumber,\n    };\n    const offset = model.getOffsetAt(positionClone);\n    const situation = getSituation(model.getValue(), offset);\n    const completionsPromise = situation != null ? getCompletions(situation, dataProvider) : Promise.resolve([]);\n    return completionsPromise.then((items) => {\n      // monaco by-default alphabetically orders the items.\n      // to stop it, we use a number-as-string sortkey,\n      // so that monaco keeps the order we use\n      const maxIndexDigits = items.length.toString().length;\n      const suggestions: monacoTypes.languages.CompletionItem[] = items.map((item, index) => ({\n        kind: getMonacoCompletionItemKind(item.type, monaco),\n        label: item.label,\n        insertText: item.insertText,\n        detail: item.detail,\n        documentation: item.documentation,\n        sortText: index.toString().padStart(maxIndexDigits, '0'), // to force the order we have\n        range,\n        command: item.triggerOnInsert\n          ? {\n              id: 'editor.action.triggerSuggest',\n              title: '',\n            }\n          : undefined,\n      }));\n      return { suggestions };\n    });\n  };\n\n  return {\n    triggerCharacters: ['{', ',', '[', '(', '=', '~', ' ', '\"'],\n    provideCompletionItems,\n  };\n}\n","import { css } from '@emotion/css';\nimport { debounce } from 'lodash';\nimport { promLanguageDefinition } from 'monaco-promql';\nimport React, { useRef, useEffect } from 'react';\nimport { useLatest } from 'react-use';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { useTheme2, ReactMonacoEditor, Monaco, monacoTypes } from '@grafana/ui';\n\nimport { Props } from './MonacoQueryFieldProps';\nimport { getOverrideServices } from './getOverrideServices';\nimport { getCompletionProvider, getSuggestOptions } from './monaco-completion-provider';\n\nconst options: monacoTypes.editor.IStandaloneEditorConstructionOptions = {\n  codeLens: false,\n  contextmenu: false,\n  // we need `fixedOverflowWidgets` because otherwise in grafana-dashboards\n  // the popup is clipped by the panel-visualizations.\n  fixedOverflowWidgets: true,\n  folding: false,\n  fontSize: 14,\n  lineDecorationsWidth: 8, // used as \"padding-left\"\n  lineNumbers: 'off',\n  minimap: { enabled: false },\n  overviewRulerBorder: false,\n  overviewRulerLanes: 0,\n  padding: {\n    // these numbers were picked so that visually this matches the previous version\n    // of the query-editor the best\n    top: 4,\n    bottom: 5,\n  },\n  renderLineHighlight: 'none',\n  scrollbar: {\n    vertical: 'hidden',\n    verticalScrollbarSize: 8, // used as \"padding-right\"\n    horizontal: 'hidden',\n    horizontalScrollbarSize: 0,\n  },\n  scrollBeyondLastLine: false,\n  suggest: getSuggestOptions(),\n  suggestFontSize: 12,\n  wordWrap: 'on',\n};\n\n// this number was chosen by testing various values. it might be necessary\n// because of the width of the border, not sure.\n//it needs to do 2 things:\n// 1. when the editor is single-line, it should make the editor height be visually correct\n// 2. when the editor is multi-line, the editor should not be \"scrollable\" (meaning,\n//    you do a scroll-movement in the editor, and it will scroll the content by a couple pixels\n//    up & down. this we want to avoid)\nconst EDITOR_HEIGHT_OFFSET = 2;\n\nconst PROMQL_LANG_ID = promLanguageDefinition.id;\n\n// we must only run the promql-setup code once\nlet PROMQL_SETUP_STARTED = false;\n\nfunction ensurePromQL(monaco: Monaco) {\n  if (PROMQL_SETUP_STARTED === false) {\n    PROMQL_SETUP_STARTED = true;\n    const { aliases, extensions, mimetypes, loader } = promLanguageDefinition;\n    monaco.languages.register({ id: PROMQL_LANG_ID, aliases, extensions, mimetypes });\n\n    loader().then((mod) => {\n      monaco.languages.setMonarchTokensProvider(PROMQL_LANG_ID, mod.language);\n      monaco.languages.setLanguageConfiguration(PROMQL_LANG_ID, mod.languageConfiguration);\n    });\n  }\n}\n\nconst getStyles = (theme: GrafanaTheme2, placeholder: string) => {\n  return {\n    container: css`\n      border-radius: ${theme.shape.borderRadius()};\n      border: 1px solid ${theme.components.input.borderColor};\n    `,\n    placeholder: css`\n      ::after {\n        content: '${placeholder}';\n        font-family: ${theme.typography.fontFamilyMonospace};\n        opacity: 0.3;\n      }\n    `,\n  };\n};\n\nconst MonacoQueryField = (props: Props) => {\n  const id = uuidv4();\n\n  // we need only one instance of `overrideServices` during the lifetime of the react component\n  const overrideServicesRef = useRef(getOverrideServices());\n  const containerRef = useRef<HTMLDivElement>(null);\n  const { languageProvider, history, onBlur, onRunQuery, initialValue, placeholder, onChange } = props;\n\n  const lpRef = useLatest(languageProvider);\n  const historyRef = useLatest(history);\n  const onRunQueryRef = useLatest(onRunQuery);\n  const onBlurRef = useLatest(onBlur);\n  const onChangeRef = useLatest(onChange);\n\n  const autocompleteDisposeFun = useRef<(() => void) | null>(null);\n\n  const theme = useTheme2();\n  const styles = getStyles(theme, placeholder);\n\n  useEffect(() => {\n    // when we unmount, we unregister the autocomplete-function, if it was registered\n    return () => {\n      autocompleteDisposeFun.current?.();\n    };\n  }, []);\n\n  return (\n    <div\n      aria-label={selectors.components.QueryField.container}\n      className={styles.container}\n      // NOTE: we will be setting inline-style-width/height on this element\n      ref={containerRef}\n    >\n      <ReactMonacoEditor\n        overrideServices={overrideServicesRef.current}\n        options={options}\n        language=\"promql\"\n        value={initialValue}\n        beforeMount={(monaco) => {\n          ensurePromQL(monaco);\n        }}\n        onMount={(editor, monaco) => {\n          const isEditorFocused = editor.createContextKey<boolean>('isEditorFocused' + id, false);\n          // we setup on-blur\n          editor.onDidBlurEditorWidget(() => {\n            isEditorFocused.set(false);\n            onBlurRef.current(editor.getValue());\n          });\n          editor.onDidFocusEditorText(() => {\n            isEditorFocused.set(true);\n          });\n\n          // we construct a DataProvider object\n          const getHistory = () =>\n            Promise.resolve(historyRef.current.map((h) => h.query.expr).filter((expr) => expr !== undefined));\n\n          const getAllMetricNames = () => {\n            const { metrics, metricsMetadata } = lpRef.current;\n            const result = metrics.map((m) => {\n              const metaItem = metricsMetadata?.[m];\n              return {\n                name: m,\n                help: metaItem?.help ?? '',\n                type: metaItem?.type ?? '',\n              };\n            });\n\n            return Promise.resolve(result);\n          };\n\n          const getAllLabelNames = () => Promise.resolve(lpRef.current.getLabelKeys());\n\n          const getLabelValues = (labelName: string) => lpRef.current.getLabelValues(labelName);\n\n          const getSeriesValues = lpRef.current.getSeriesValues;\n\n          const getSeriesLabels = lpRef.current.getSeriesLabels;\n          const dataProvider = {\n            getHistory,\n            getAllMetricNames,\n            getAllLabelNames,\n            getLabelValues,\n            getSeriesValues,\n            getSeriesLabels,\n          };\n          const completionProvider = getCompletionProvider(monaco, dataProvider);\n\n          // completion-providers in monaco are not registered directly to editor-instances,\n          // they are registered to languages. this makes it hard for us to have\n          // separate completion-providers for every query-field-instance\n          // (but we need that, because they might connect to different datasources).\n          // the trick we do is, we wrap the callback in a \"proxy\",\n          // and in the proxy, the first thing is, we check if we are called from\n          // \"our editor instance\", and if not, we just return nothing. if yes,\n          // we call the completion-provider.\n          const filteringCompletionProvider: monacoTypes.languages.CompletionItemProvider = {\n            ...completionProvider,\n            provideCompletionItems: (model, position, context, token) => {\n              // if the model-id does not match, then this call is from a different editor-instance,\n              // not \"our instance\", so return nothing\n              if (editor.getModel()?.id !== model.id) {\n                return { suggestions: [] };\n              }\n              return completionProvider.provideCompletionItems(model, position, context, token);\n            },\n          };\n\n          const { dispose } = monaco.languages.registerCompletionItemProvider(\n            PROMQL_LANG_ID,\n            filteringCompletionProvider\n          );\n\n          autocompleteDisposeFun.current = dispose;\n          // this code makes the editor resize itself so that the content fits\n          // (it will grow taller when necessary)\n          // FIXME: maybe move this functionality into CodeEditor, like:\n          // <CodeEditor resizingMode=\"single-line\"/>\n          const updateElementHeight = () => {\n            const containerDiv = containerRef.current;\n            if (containerDiv !== null) {\n              const pixelHeight = editor.getContentHeight();\n              containerDiv.style.height = `${pixelHeight + EDITOR_HEIGHT_OFFSET}px`;\n              containerDiv.style.width = '100%';\n              const pixelWidth = containerDiv.clientWidth;\n              editor.layout({ width: pixelWidth, height: pixelHeight });\n            }\n          };\n\n          editor.onDidContentSizeChange(updateElementHeight);\n          updateElementHeight();\n\n          // Whenever the editor changes, lets save the last value so the next query for this editor will be up-to-date.\n          // This change is being introduced to fix a bug where you can submit a query via shift+enter:\n          // If you clicked into another field and haven't un-blurred the active field,\n          // then the query that is run will be stale, as the reference is only updated\n          // with the value of the last blurred input.\n          // This can run quite slowly, so we're debouncing this which should accomplish two things\n          // 1. Should prevent this function from blocking the current call stack by pushing into the web API callback queue\n          // 2. Should prevent a bunch of duplicates of this function being called as the user is typing\n          const updateCurrentEditorValue = debounce(() => {\n            const editorValue = editor.getValue();\n            onChangeRef.current(editorValue);\n          }, 300);\n\n          editor.getModel()?.onDidChangeContent(() => {\n            updateCurrentEditorValue();\n          });\n\n          // handle: shift + enter\n          // FIXME: maybe move this functionality into CodeEditor?\n          editor.addCommand(\n            monaco.KeyMod.Shift | monaco.KeyCode.Enter,\n            () => {\n              onRunQueryRef.current(editor.getValue());\n            },\n            'isEditorFocused' + id\n          );\n\n          /* Something in this configuration of monaco doesn't bubble up [mod]+K, which the\n          command palette uses. Pass the event out of monaco manually\n          */\n          editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyK, function () {\n            global.dispatchEvent(new KeyboardEvent('keydown', { key: 'k', metaKey: true }));\n          });\n\n          if (placeholder) {\n            const placeholderDecorators = [\n              {\n                range: new monaco.Range(1, 1, 1, 1),\n                options: {\n                  className: styles.placeholder,\n                  isWholeLine: true,\n                },\n              },\n            ];\n\n            let decorators: string[] = [];\n\n            const checkDecorators: () => void = () => {\n              const model = editor.getModel();\n\n              if (!model) {\n                return;\n              }\n\n              const newDecorators = model.getValueLength() === 0 ? placeholderDecorators : [];\n              decorators = model.deltaDecorations(decorators, newDecorators);\n            };\n\n            checkDecorators();\n            editor.onDidChangeModelContent(checkDecorators);\n          }\n        }}\n      />\n    </div>\n  );\n};\n\n// we will lazy-load this module using React.lazy,\n// and that only supports default-exports,\n// so we have to default-export this, even if\n// it is against the style-guidelines.\n\nexport default MonacoQueryField;\n","import { useRef } from 'react';\nvar useLatest = function (value) {\n    var ref = useRef(value);\n    ref.current = value;\n    return ref;\n};\nexport default useLatest;\n"],"names":["promLanguageDefinition","id","extensions","aliases","mimetypes","loader","makeStorageService","strings","Map","set","toString","onDidChangeValue","data","onDidChangeTarget","onWillSaveState","get","key","scope","fallbackValue","getBoolean","val","undefined","getNumber","parseInt","store","value","target","delete","remove","keys","Array","from","logStorage","console","log","migrate","Promise","resolve","isNew","flush","reason","overrideServices","NeverCaseError","Error","constructor","super","async","getAllMetricNamesCompletions","dataProvider","getAllMetricNames","map","metric","type","label","name","insertText","detail","documentation","help","FUNCTION_COMPLETIONS","FUNCTIONS","f","getAllFunctionsAndMetricNamesCompletions","metricNames","DURATION_COMPLETIONS","text","makeSelector","metricName","labels","allLabels","push","op","escapeLabelValueInExactSelector","join","getLabelNamesForCompletions","suffix","triggerOnInsert","otherLabels","labelNames","length","getAllLabelNames","selector","getSeriesLabels","getLabelNames","getLabelValuesForMetricCompletions","labelName","betweenQuotes","values","getLabelValues","getSeriesValues","getCompletions","situation","historyCompletions","getHistory","slice","expr","getAllHistoryCompletions","getLabelNamesForSelectorCompletions","getLabelNamesForByCompletions","move","node","direction","parent","firstChild","lastChild","nextSibling","walk","path","current","expectedType","getNodeText","to","isPathMatch","resolverPath","cursorPath","every","item","index","RESOLVERS","LabelMatchers","VectorSelector","fun","pos","getNodeInSubtree","subTreeHasError","child","LabelMatchList","includes","metricNameNode","MetricIdentifier","Identifier","getLabels","PromQL","FunctionCallBody","StringLiteral","LabelMatcher","resolveLabelMatcher","MatrixSelector","GroupingLabels","aggrExpNode","AggregateModifier","AggregateExpr","bodyNode","getChild","metricIdNode","idNode","LABEL_OP_MAP","EqlSingle","EqlRegex","Neq","NeqRegex","getLabel","labelMatcherNode","nameNode","LabelName","opNode","MatchOp","opChild","getLabelOp","valueNode","inside","startsWith","endsWith","replace","parsePromQLStringLiteral","labelMatchersNode","listNode","matcherNode","reverse","typeId","children","getNodeChildren","n","inStringNode","isError","labelNameNode","firstListNode","p","filter","getMonacoCompletionItemKind","monaco","languages","CompletionItemKind","Unit","Variable","Snippet","Enum","EnumMember","Constructor","getCompletionProvider","triggerCharacters","provideCompletionItems","model","position","word","getWordAtPosition","range","Range","lift","startLineNumber","lineNumber","endLineNumber","startColumn","endColumn","fromPositions","positionClone","column","offset","getOffsetAt","tree","parser","maybeErrorNode","cur","cursorAt","next","getErrorNode","cursor","currentNode","ids","resolver","getSituation","getValue","then","items","maxIndexDigits","suggestions","kind","sortText","padStart","command","title","options","codeLens","contextmenu","fixedOverflowWidgets","folding","fontSize","lineDecorationsWidth","lineNumbers","minimap","enabled","overviewRulerBorder","overviewRulerLanes","padding","top","bottom","renderLineHighlight","scrollbar","vertical","verticalScrollbarSize","horizontal","horizontalScrollbarSize","scrollBeyondLastLine","suggest","showWords","suggestFontSize","wordWrap","PROMQL_LANG_ID","PROMQL_SETUP_STARTED","props","uuidv4","overrideServicesRef","useRef","storageService","containerRef","languageProvider","history","onBlur","onRunQuery","initialValue","placeholder","onChange","lpRef","useLatest","historyRef","onRunQueryRef","onBlurRef","onChangeRef","autocompleteDisposeFun","styles","theme","container","css","shape","borderRadius","components","input","borderColor","typography","fontFamilyMonospace","getStyles","useTheme2","useEffect","selectors","className","ref","language","beforeMount","register","mod","setMonarchTokensProvider","setLanguageConfiguration","languageConfiguration","ensurePromQL","onMount","editor","isEditorFocused","createContextKey","onDidBlurEditorWidget","onDidFocusEditorText","completionProvider","h","query","metrics","metricsMetadata","result","m","metaItem","getLabelKeys","filteringCompletionProvider","context","token","getModel","dispose","registerCompletionItemProvider","updateElementHeight","containerDiv","pixelHeight","getContentHeight","style","height","width","pixelWidth","clientWidth","layout","onDidContentSizeChange","updateCurrentEditorValue","debounce","editorValue","onDidChangeContent","addCommand","KeyMod","Shift","KeyCode","Enter","CtrlCmd","KeyK","global","dispatchEvent","KeyboardEvent","metaKey","placeholderDecorators","isWholeLine","decorators","checkDecorators","newDecorators","getValueLength","deltaDecorations","onDidChangeModelContent"],"sourceRoot":""}