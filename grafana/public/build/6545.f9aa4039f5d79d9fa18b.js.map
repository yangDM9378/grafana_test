{"version":3,"file":"6545.f9aa4039f5d79d9fa18b.js","mappings":"0JASO,MAAMA,EAAqB,SAACC,GAAiD,IAAnCC,EAAU,UAAH,8CACtD,MAAMC,EAASF,EAAME,OAErB,OAAQF,EAAMG,MACZ,KAAKC,EAAAA,GAAAA,OACH,OAAOC,EAAqBH,EAAQD,GACtC,KAAKG,EAAAA,GAAAA,OACH,OAAOE,EAAoBJ,EAAQD,GACrC,KAAKG,EAAAA,GAAAA,QACH,OAAOG,EAAqBL,EAAQD,GACtC,KAAKG,EAAAA,GAAAA,KACH,OAAOI,EAAkBN,EAAQD,GACnC,QACE,OAAOQ,EAAqBR,GAElC,EAGaS,EAAe,CAACC,EAAQC,IAC9BD,GAAMC,GAIPC,EAAAA,EAAAA,UAASF,KAAME,EAAAA,EAAAA,UAASD,GACnBE,EAAgBH,EAAGC,IAGxBG,EAAAA,EAAAA,IAASJ,GAAGK,SAASJ,IACf,GAGNG,EAAAA,EAAAA,IAASH,GAAGI,SAASL,GAChB,EAGF,EAfEM,EAAcN,EAAGC,GAmBfE,EAAkB,CAACH,EAAWC,IAClCD,EAAIC,EAIAM,EAAiB,CAACP,EAAWC,IACnCD,GAAMC,EAGJD,EAAEQ,cAAcP,GAFdK,EAAcN,EAAGC,GAKfQ,EAAkB,CAACT,EAAYC,IACnCK,EAAcN,EAAGC,GAGpBK,EAAgB,CAACN,EAAQC,KACxBD,GAAKC,EACD,EAGLD,IAAMC,GACA,EAGH,EAGHJ,EAAoB,CAACN,EAAqBD,IACvC,CAACU,EAAWC,KACjB,MAAMS,EAAKnB,EAAOoB,IAAIX,GAChBY,EAAKrB,EAAOoB,IAAIV,GACtB,OAAOX,EAAUS,EAAaa,EAAIF,GAAMX,EAAaW,EAAIE,EAAG,EAI1DhB,EAAuB,CAACL,EAAqBD,IAC1C,CAACU,EAAWC,KACjB,MAAMS,EAAcnB,EAAOoB,IAAIX,GACzBY,EAAcrB,EAAOoB,IAAIV,GAC/B,OAAOX,EAAUmB,EAAgBG,EAAIF,GAAMD,EAAgBC,EAAIE,EAAG,EAIhElB,EAAuB,CAACH,EAAqBD,IAC1C,CAACU,EAAWC,KACjB,MAAMS,EAAanB,EAAOoB,IAAIX,GACxBY,EAAarB,EAAOoB,IAAIV,GAC9B,OAAOX,EAAUa,EAAgBS,EAAIF,GAAMP,EAAgBO,EAAIE,EAAG,EAIhEjB,EAAsB,CAACJ,EAAqBD,IACzC,CAACU,EAAWC,KACjB,MAAMS,EAAanB,EAAOoB,IAAIX,GACxBY,EAAarB,EAAOoB,IAAIV,GAC9B,OAAOX,EAAUiB,EAAeK,EAAIF,GAAMH,EAAeG,EAAIE,EAAG,EAI9Dd,EAAwBR,GACrB,CAACU,EAAWC,IACVX,EAAUa,EAAgBF,EAAGD,GAAKG,EAAgBH,EAAGC,E,6DCxGhE,MAAMY,EAAgD,CACpDC,GAAIC,EAAAA,GAAAA,OACJC,KAAM,aACNC,YAAa,gCACbC,eAAgBzB,EAAAA,GAAAA,OAEhBkB,IAAMnB,GACG,CAACH,EAAc8B,EAAkBC,IAC/B5B,IAASH,EAAMG,KAI1B6B,sBAAwB7B,GACd,eAAcA,KAMpB8B,EAAmC,CACvCR,GAAIC,EAAAA,GAAAA,QACJC,KAAM,iBACNC,YAAa,0BAEbN,IAAK,IACIE,EAAiBF,IAAIlB,EAAAA,GAAAA,QAG9B4B,sBAAuB,IACd,kBAKLE,EAAgC,CACpCT,GAAIC,EAAAA,GAAAA,KACJC,KAAM,cACNC,YAAa,wBAEbN,IAAK,IACIE,EAAiBF,IAAIlB,EAAAA,GAAAA,MAG9B4B,sBAAuB,IACd,eAOJ,SAASG,IACd,MAAO,CAACX,EAAkBS,EAAgBC,EAC5C,C,kBCvDO,IAAKE,EAQAV,EAqBAW,EAUAC,E,6CAjCX,SANWF,GAAAA,EAAS,oBAATA,EAAS,oBAATA,EAAS,0BAATA,EAAS,0BAATA,EAAS,wBAMpB,CANWA,IAAAA,EAAS,KA0BrB,SAlBYV,GAAAA,EAAc,kBAAdA,EAAc,YAAdA,EAAc,cAAdA,EAAc,gCAAdA,EAAc,gBAAdA,EAAc,gBAAdA,EAAc,kBAAdA,EAAc,oBAAdA,EAAc,kCAAdA,EAAc,4BAkB1B,CAlBYA,IAAAA,EAAc,KA4B1B,SAPYW,GAAAA,EAAc,gBAAdA,EAAc,kBAAdA,EAAc,kBAAdA,EAAc,kBAO1B,CAPYA,IAAAA,EAAc,KAqBzB,SAXWC,GAAAA,EAAc,cAAdA,EAAc,gBAAdA,EAAc,sBAAdA,EAAc,kBAAdA,EAAc,gCAAdA,EAAc,cAAdA,EAAc,4BAAdA,EAAc,cAAdA,EAAc,oBAAdA,EAAc,kBAWzB,CAXWA,IAAAA,EAAc,I,kDCpC1B,MAAMC,EAAwC,CAC5Cd,G,SAAIY,GAAAA,QACJV,KAAM,cACNC,YAAa,kBACbC,eAAgB,IAEhBP,IAAMkB,IACJ,MAAMC,GAAQC,EAAAA,EAAAA,IAAgBF,GAC9B,OAAQV,GACCW,EAAME,KAAKb,EAAMc,OAAS,GAClC,EAGHZ,sBAAwBQ,GACd,UAASA,KAId,SAASK,IACd,MAAO,CAACN,EACV,C,6DCtBA,MAAMO,EAAsC,CAC1CrB,GAAIC,EAAAA,GAAAA,MACJC,KAAM,cACNC,YAAa,+BAEbN,IAAMnB,GACG,CAACH,EAAc8B,EAAkBC,IAC/B/B,IAAU8B,EAAMiB,OAAO,GAIlCf,sBAAuB,IACb,eAINgB,EAA0C,CAC9CvB,GAAIC,EAAAA,GAAAA,eACJC,KAAM,mBACNC,YAAa,0CAEbN,IAAMnB,GACG,CAACH,EAAc8B,EAAkBC,IAC/B/B,EAAMG,OAASC,EAAAA,GAAAA,MAAkBJ,IAAU8B,EAAMiB,OAAOE,MAAMC,GAAMA,EAAE/C,OAASC,EAAAA,GAAAA,OAI1F4B,sBAAuB,IACb,oBAOL,SAASmB,IACd,MAAO,CAACL,EAAmBE,EAC7B,C,kDCpCA,MAAMI,EAAkE,CACtE3B,GAAIa,EAAAA,GAAAA,MACJX,KAAM,WACNC,YAAa,+DACbN,IAAM+B,GACG,CAACC,EAAoBtD,IACZA,EAAME,OAAOoB,IAAIgC,IAEfD,EAAQE,MAG5BvB,sBAAuB,IACb,wCAEVwB,aAAc,KAAM,EACpBC,kBAAmB,KAAM,CAAGF,MAAO,MAG/BG,EAAqE,CACzEjC,GAAIa,EAAAA,GAAAA,SACJX,KAAM,eACNC,YAAa,mEACbN,IAAM+B,GACG,CAACC,EAAoBtD,IACZA,EAAME,OAAOoB,IAAIgC,IAEfD,EAAQE,MAG5BvB,sBAAuB,IACb,4CAEVwB,aAAc,KAAM,EACpBC,kBAAmB,KAAM,CAAGF,MAAO,MAGxBI,EAAwB,IAA0B,CAACP,EAAqBM,E,kDCpCrF,MAAME,EAA4D,CAChEnC,GAAIa,EAAAA,GAAAA,OACJX,KAAM,UACNC,YAAa,6CACbN,IAAK,IACI,CAACgC,EAAoBtD,IAEV,MADFA,EAAME,OAAOoB,IAAIgC,GAInCtB,sBAAuB,IACb,wCAEVwB,aAAc,KAAM,EACpBC,kBAAmB,KAAM,CAAG,IAGxBI,EAA+D,CACnEpC,GAAIa,EAAAA,GAAAA,UACJX,KAAM,cACNC,YAAa,iDACbN,IAAK,IACI,CAACgC,EAAoBtD,IAEV,MADFA,EAAME,OAAOoB,IAAIgC,GAInCtB,sBAAuB,IACb,4CAEVwB,aAAc,KAAM,EACpBC,kBAAmB,KAAM,CAAG,IAGjBK,EAAuB,IAA0B,CAACF,EAAoBC,E,6DClCnF,MAAME,EAA4E,CAChFtC,GAAIa,EAAAA,GAAAA,QACJX,KAAM,aACNC,YAAa,iDACbN,IAAM+B,GACG,CAACC,EAAoBtD,KAC1B,MAAMuD,EAAQvD,EAAME,OAAOoB,IAAIgC,GAC/B,OAAIU,MAAMT,IAGHA,EAAQF,EAAQE,KAAK,EAGhCvB,sBAAwBqB,GACd,uDAAsDA,EAAQE,SAExEC,aAAexD,GAAUA,EAAMG,OAASC,EAAAA,GAAAA,OACxCqD,kBAAmB,KAAM,CAAGF,MAAO,KAG/BU,EAAmF,CACvFxC,GAAIa,EAAAA,GAAAA,eACJX,KAAM,sBACNC,YAAa,6DACbN,IAAM+B,GACG,CAACC,EAAoBtD,KAC1B,MAAMuD,EAAQvD,EAAME,OAAOoB,IAAIgC,GAC/B,OAAIU,MAAMT,IAGHA,GAASF,EAAQE,KAAK,EAGjCvB,sBAAwBqB,GACd,mEAAkEA,EAAQE,SAEpFC,aAAexD,GAAUA,EAAMG,OAASC,EAAAA,GAAAA,OACxCqD,kBAAmB,KAAM,CAAGF,MAAO,KAG/BW,EAA0E,CAC9EzC,GAAIa,EAAAA,GAAAA,MACJX,KAAM,WACNC,YAAa,+CACbN,IAAM+B,GACG,CAACC,EAAoBtD,KAC1B,MAAMuD,EAAQvD,EAAME,OAAOoB,IAAIgC,GAC/B,OAAIU,MAAMT,IAGHA,EAAQF,EAAQE,KAAK,EAGhCvB,sBAAwBqB,GACd,qDAAoDA,EAAQE,SAEtEC,aAAexD,GAAUA,EAAMG,OAASC,EAAAA,GAAAA,OACxCqD,kBAAmB,KAAM,CAAGF,MAAO,KAG/BY,EAAiF,CACrF1C,GAAIa,EAAAA,GAAAA,aACJX,KAAM,oBACNC,YAAa,wDACbN,IAAM+B,GACG,CAACC,EAAoBtD,KAC1B,MAAMuD,EAAQvD,EAAME,OAAOoB,IAAIgC,GAC/B,OAAIU,MAAMT,IAGHA,GAASF,EAAQE,KAAK,EAGjCvB,sBAAwBqB,GACd,8DAA6DA,EAAQE,SAE/EC,aAAexD,GAAUA,EAAMG,OAASC,EAAAA,GAAAA,OACxCqD,kBAAmB,KAAM,CAAGF,MAAO,KAGxBa,EAA0B,IAA0B,CAC/DL,EACAE,EACAC,EACAC,E,iDCpFF,MAAME,EAA4E,CAChF5C,G,SAAIa,GAAAA,QACJX,KAAM,aACNC,YAAa,yDACbN,IAAM+B,GACG,CAACC,EAAoBtD,KAC1B,MAAMuD,EAAQvD,EAAME,OAAOoB,IAAIgC,GAC/B,OAAIU,MAAMT,KAGHA,EAAQF,EAAQiB,MAAQf,EAAQF,EAAQkB,GAAE,EAGrDvC,sBAAwBqB,GACd,iDAAgDA,EAAQiB,YAAYjB,EAAQkB,MAEtFf,aAAexD,GAAUA,EAAMG,OAASC,EAAAA,GAAAA,OACxCqD,kBAAmB,KAAM,CAAGa,KAAM,EAAGC,GAAI,OAG9BC,EAAwB,IAA0B,CAACH,E,mCCpBhE,MAAMI,EAAwE,CAC5EhD,G,SAAIa,GAAAA,MACJX,KAAM,QACNC,YAAa,4CACbN,IAAM+B,IACJ,MAAMZ,EAAQ,IAAIiC,OAAOrB,EAAQE,OAEjC,MAAO,CAACD,EAAoBtD,KAC1B,MAAMuD,EAAQvD,EAAME,OAAOoB,IAAIgC,GAC/B,OAAOb,EAAME,KAAKY,EAAM,CACzB,EAEHvB,sBAAwBqB,GACd,yDAAwDA,EAAQE,QAE1EC,aAAc,KAAM,EACpBC,kBAAmB,KAAM,CAAGF,MAAO,QAGxBoB,EAAuB,IAA0B,CAACF,E,kBCzBxD,IAAKG,E,iBAsCX,SAtCWA,GAAAA,EAAiB,gBAAjBA,EAAiB,gBAAjBA,EAAiB,cAAjBA,EAAiB,oBAAjBA,EAAiB,gBAAjBA,EAAiB,gCAAjBA,EAAiB,kCAAjBA,EAAiB,4BAAjBA,EAAiB,cAAjBA,EAAiB,0BAAjBA,EAAiB,gCAAjBA,EAAiB,4BAAjBA,EAAiB,wCAAjBA,EAAiB,4BAAjBA,EAAiB,8BAAjBA,EAAiB,8BAAjBA,EAAiB,8BAAjBA,EAAiB,YAAjBA,EAAiB,8BAAjBA,EAAiB,kBAAjBA,EAAiB,gBAAjBA,EAAiB,sBAAjBA,EAAiB,gCAAjBA,EAAiB,4BAAjBA,EAAiB,sCAAjBA,EAAiB,oCAAjBA,EAAiB,0BAAjBA,EAAiB,kBAAjBA,EAAiB,kBAAjBA,EAAiB,0BAAjBA,EAAiB,4BAAjBA,EAAiB,8BAAjBA,EAAiB,oCAAjBA,EAAiB,cAAjBA,EAAiB,sCAsC5B,CAtCWA,IAAAA,EAAiB,I,yKCsCtB,MAAMC,EAKXC,YAAoBC,GAAkB,iBAJf,IAAE,cACV,IAAIC,KAAgB,sBACb,GAAK,kBAMhBD,IACT,GAAIE,KAAKC,YACP,MAAM,IAAIC,MAAM,gCAElBF,KAAKF,KAAOA,CAAI,IACjB,KATmBA,KAAAA,EAClBE,KAAKF,KAAOA,CACd,CASAK,YAAY3D,GAKV,GAJKwD,KAAKC,aACRD,KAAKI,aAGH5D,EACF,OAAOwD,KAAKK,KAAKhE,IAAIG,EAIzB,CAEQ4D,aACN,GAAIJ,KAAKF,KACP,IAAK,MAAMQ,KAAON,KAAKF,OACrBE,KAAKO,SAASD,GAGlBN,KAAKQ,OACLR,KAAKC,aAAc,CACrB,CAEA5D,IAAIG,GACF,MAAMiE,EAAIT,KAAKG,YAAY3D,GAC3B,IAAKiE,EACH,MAAM,IAAIP,MAAO,IAAG1D,oBAAqBwD,KAAKU,OAAOC,KAAKF,GAAMA,EAAEjE,QAEpE,OAAOiE,CACT,CAEAG,cAAcC,EAAoBC,GAC3Bd,KAAKC,aACRD,KAAKI,aAGP,MAAMW,EAAS,CACb3C,QAAS,GACTyC,QAAS,IAGLG,EAA0D,CAAC,EACjE,GAAIH,EACF,IAAK,MAAMrE,KAAMqE,EACfG,EAAexE,GAAM,CAAC,EAI1B,IAAK,MAAM8D,KAAON,KAAKiB,QAAS,CAC9B,GAAIX,EAAIY,kBACN,SAEF,GAAIJ,IAAWA,EAAOR,GACpB,SAGF,MAAMa,EAAS,CACb7C,MAAOgC,EAAI9D,GACX4E,MAAOd,EAAI5D,KACXC,YAAa2D,EAAI3D,aAGf2D,EAAIe,QAAUC,EAAAA,GAAAA,QAChBH,EAAOC,OAAS,YAGlBL,EAAO3C,QAAQmD,KAAKJ,GAChBH,EAAeV,EAAI9D,MACrBwE,EAAeV,EAAI9D,IAAM2E,EAE7B,CAOA,OALIN,IAEFE,EAAOF,QAAUW,OAAOvG,OAAO+F,IAG1BD,CACT,CAKAL,KAAKe,GAKH,GAJKzB,KAAKC,aACRD,KAAKI,aAGHqB,EAAK,CACP,MAAMC,EAAa,GACnB,IAAK,MAAMlF,KAAMiF,EAAK,CACpB,MAAMhB,EAAIT,KAAKG,YAAY3D,GACvBiE,GACFiB,EAAMH,KAAKd,EAEf,CACA,OAAOiB,CACT,CAEA,OAAO1B,KAAKiB,OACd,CAEAU,UAKE,OAJK3B,KAAKC,aACRD,KAAKI,aAGwB,IAAxBJ,KAAKiB,QAAQW,MACtB,CAEArB,SAASD,GACP,GAAIN,KAAKK,KAAKwB,IAAIvB,EAAI9D,IACpB,MAAM,IAAI0D,MAAM,iBAAmBI,EAAI9D,IAMzC,GAHAwD,KAAKK,KAAKyB,IAAIxB,EAAI9D,GAAI8D,GACtBN,KAAKiB,QAAQM,KAAKjB,GAEdA,EAAIyB,SACN,IAAK,MAAMC,KAAS1B,EAAIyB,SACjB/B,KAAKK,KAAKwB,IAAIG,IACjBhC,KAAKK,KAAKyB,IAAIE,EAAO1B,GAKvBN,KAAKC,aACPD,KAAKQ,MAET,CAEQA,OAER,E,iDCnLK,MAAMyB,UAA6BC,EAAAA,EAGxCrC,YAAYsC,G,UACVC,Q,OAAQ,G,EAAA,Y,EAAA,M,sFACRpC,KAAKmC,OAASA,GAAkB,EAClC,CAEIP,aACF,OAAO5B,KAAKmC,OAAOP,MACrB,CAEAS,IAAI/D,GACF0B,KAAKmC,OAAOZ,KAAKjD,EACnB,CAEAjC,IAAIiG,GACF,OAAOtC,KAAKmC,OAAOG,EACrB,CAEAR,IAAIQ,EAAehE,GACjB0B,KAAKmC,OAAOG,GAAShE,CACvB,CAEAtD,UACEgF,KAAKmC,OAAOnH,SACd,CAEAuH,UACE,OAAOvC,KAAKmC,MACd,CAEAK,SACE,OAAOxC,KAAKmC,MACd,E,kDClCK,MAAMM,EACX5C,YAAoB6C,EAA2BC,GAAiB,KAA5CD,OAAAA,EAAiB,KAAUC,MAAAA,CAAkB,CAE7Df,aACF,OAAO5B,KAAK0C,OAAOd,MACrB,CAEAvF,IAAIiG,GACF,OAAOtC,KAAK0C,OAAOrG,IAAI2D,KAAK2C,MAAML,GACpC,CAEAC,UACE,OAAOK,EAAAA,EAAAA,GAAc5C,KACvB,CAEAwC,SACE,OAAOI,EAAAA,EAAAA,GAAc5C,KACvB,CAEA6C,gBACE,OAAO7C,KAAK2C,KACd,E,kBC1BK,SAASC,EAAiBnC,GAC/B,MAAMqC,EAAWC,MAAMtC,EAAEmB,QACzB,IAAK,IAAIoB,EAAI,EAAGA,EAAIvC,EAAEmB,OAAQoB,IAC5BF,EAAIE,GAAKvC,EAAEpE,IAAI2G,GAEjB,OAAOF,CACT,C,kCCAO,SAASG,EAAiBC,GAC/B,MAAMC,EAASD,GAAO,CAAC,EAEvB,IAAKC,EAAMC,QAAS,WAClB,GAAmB,iBAARF,GAAoBA,aAAeG,OAC5C,MAAO,CAAED,QAASF,GAGpB,IAAIE,EAAU,cACVD,EAAMC,QACRA,EAAUD,EAAMC,QACPD,EAAMG,MAAQH,EAAMG,KAAKF,SAAmC,sBAAd,QAAV,EAAAD,EAAMG,YAAI,aAAV,EAAYF,SACzDA,EAAUD,EAAMG,KAAKF,QACa,sBAAzBD,SAAW,QAAN,EAALA,EAAOG,YAAI,WAAN,EAAL,EAAaF,UAAb,MAA+CD,GAAW,QAAN,EAALA,EAAOG,YAAI,OAAX,EAAaH,OAE5DA,EAAMG,MAAQH,EAAMG,KAAKH,MADlCC,EAAUD,EAAMG,KAAKH,MAGZA,EAAMI,SACfH,EAAW,gBAAeD,EAAMI,UAAUJ,EAAMK,cAElDL,EAAMC,QAAUA,CAClB,CAEA,OAAOD,CACT,C,4TCoCI,IAWCM,GAAyB,SAAzBA,GAAAA,EAAAA,EAAyB,iBAAzBA,EAAAA,EAAyB,6CAAzBA,EAAAA,EAAyB,kCAAzBA,IAAAA,EAAyB,KAsB9B,MAiBMC,EAAiB,CACrBC,EACAzI,IACoCyI,EAAQ7C,QAAQ8C,GAAMA,EAAE1I,OAASA,IAEhE,MAAM2I,EAMXhE,YAAoBiE,GAAgC,qFAHH,IAAIC,EAAAA,EAAc,IAAE,sDAYlD,KACjB/D,KAAKgE,OAAOC,WACZjE,KAAKkE,uBAAuBC,cAC5BnE,KAAK8D,KAAKM,YAAY,IACvB,kCAEiC,KAC3BpE,KAAKgE,OAAOK,UACfrE,KAAKsE,UACP,IACD,kBAEkBpB,IACjBqB,QAAQC,IAAI,oBAAqB,CAAEtB,OAAOlD,KAAK8D,KAAKW,WACpDzE,KAAKgE,OAAOU,KAAK,CACfxJ,KAAMuI,EAA0BvD,MAChCiD,OAAOF,EAAAA,EAAAA,GAAiBC,KAE1BlD,KAAKsE,UAAU,IAChB,qBAEoB,KACnBC,QAAQC,IAAI,uBAAwBxE,KAAK8D,KAAKW,WAC9CzE,KAAKsE,UAAU,IAChB,iBAEiBK,IAChB,IAAIC,EAAAA,EAAAA,IAA0BD,GAE5B,YADA3E,KAAK6E,QAAQF,EAAIvB,SAInB,MAAM0B,GAAyBC,EAAAA,EAAAA,IAAyBJ,GACpDG,GAA0BH,EAAIxB,MAChCnD,KAAKgE,OAAOU,KAAK,CACfxJ,KAAMuI,EAA0BvD,MAChCiD,MAAO,OAAF,WACAF,EAAAA,EAAAA,GAAiB0B,EAAIxB,OAAM,CAC9BC,QAAU,4BAA2BuB,EAAIxB,MAAMC,cAOnD0B,IACCH,EAAItD,QAAU2D,EAAAA,GAAAA,WAAwCL,EAAItD,QAAU2D,EAAAA,GAAAA,UACrEL,EAAIvB,SAEJpD,KAAK6E,QAAQF,EAAIvB,QACnB,IACD,kBAEkB6B,IACEjF,KAAKkF,YAAY3D,KAAK0D,GAE1BE,cACbnF,KAAKgE,OAAOU,KAAK,CACfxJ,KAAMuI,EAA0B2B,gBAGlCpF,KAAKgE,OAAOU,KAAK,CACfxJ,KAAMuI,EAA0B4B,oBAChCpK,OAAQ+E,KAAKkF,YAAYI,2BAE7B,IACD,uBAEuBC,IAClBA,GAAiBvF,KAAKkF,YAAYM,cAAcD,IAClDvF,KAAKkF,YAAYO,OAAOF,EAC1B,IACD,kDAEkDnH,KAC5C4B,KAAKkF,YAAYQ,uBAAyBtH,EAAQvB,OAErDmD,KAAK6E,QAAQzG,EAAQvB,MACvB,IACD,+BAE8B,KACzBmD,KAAK2F,oBACPC,aAAa5F,KAAK2F,mBAClB3F,KAAK2F,uBAAoBE,EAC3B,IACD,cAEK,CAACzH,EAAgC0H,KAA8E,QACnH9F,KAAK+F,uBACL,MAAM5D,GAAS6D,EAAAA,EAAAA,IAAyB5H,EAAQ+D,QAEhDnC,KAAKiG,aAAa9D,GAClBnC,KAAKkG,wCAAwC9H,GAE7C,MAAM+H,GAA2B/H,SAAe,QAAR,EAAPA,EAAS+D,cAAM,WAAR,EAAP,EAAiBiE,UAAWC,EAAAA,GAAAA,QACvDC,EAAkC,QAAjB,EAAGlI,EAAQ0C,cAAM,aAAd,EAAgBhD,OAEpCyI,GADqBD,aAAiB,EAAjBA,EAAmB1E,QACI,QAAC,KAAElF,GAAa,SAAK4J,EAAkBE,SAAS9J,EAAK,OAAGmJ,EAC1G,IAAIY,EAEJ,MAAMC,EAA2B,CAC/BC,EACAxD,KAEAsD,EAAuBF,EACnBvG,KAAKkF,YAAY0B,wBAAwBL,QACzCV,EAECM,EAcDhD,EAEK,CACL0D,IAAKf,EACLzE,MAAOyF,EAAAA,GAAAA,MACPxD,KAAM,CACJ,CACEpI,KAAM6L,EAAAA,GAAAA,UACNlK,MAAOmD,KAAKkF,YAAY8B,UAAUT,EAAsBpE,EAAQ,CAAE8E,UAAW,MAGjF9D,SAICwD,EAAS/E,OAgBP,CACLiF,IAAKf,EACLzE,MAAOyF,EAAAA,GAAAA,UACPxD,KAAM,CACJ,CACEpI,KAAM6L,EAAAA,GAAAA,UACNlK,MAAOmD,KAAKkF,YAAY8B,UAAUT,EAAsBpE,EAAQ,CAC9D8E,UAAWjH,KAAKkF,YAAYgC,WAAWtF,WAI7CuB,UA1BAoB,QAAQ4C,KAAM,mDAAkDR,EAAShG,KAAI,QAAC,KAAEzF,GAAM,SAAKA,CAAI,OAExF,CACL2L,IAAKf,EACLzE,MAAOyF,EAAAA,GAAAA,UACPxD,KAAM,CACJ,CACEpI,KAAM6L,EAAAA,GAAAA,UACNlK,MAAOmD,KAAKkF,YAAY8B,UAAUT,EAAsBpE,EAAQ,CAAE8E,UAAW,MAGjF9D,UAxCK,CACL0D,IAAKf,EACLzE,MAAO8B,EAAQ2D,EAAAA,GAAAA,MAAqBA,EAAAA,GAAAA,UACpCxD,KAAM,CACJ,CACEpI,KAAM6L,EAAAA,GAAAA,UACNlK,MAAOmD,KAAKkF,YAAY8B,UAAUT,EAAsBpE,KAG5DgB,UAkDAiE,EACJT,IAEA,MAAMU,EAAcV,EAAS/E,OAAS+E,EAASA,EAAS/E,OAAS,QAAKiE,EAChE5K,EACJkL,GAA4BkB,EACxBA,EAAYpM,QAnNtB0I,EAoN4CgD,EApNwC,CAEpF1L,OAAQ0I,EAAQ2D,QAAO,CAACC,EAAK,KAAe,IAAf,OAAEtM,GAAQ,EACrC,IAAK,IAAI+H,EAAI,EAAGA,EAAI/H,EAAO2G,OAAQoB,IAAK,CACjCuE,EAAIvE,KACPuE,EAAIvE,GAAK,IAEX,IAAK,IAAIwE,EAAI,EAAGA,EAAIvM,EAAO+H,GAAGpB,OAAQ4F,IACpCD,EAAIvE,GAAGzB,KAAKtG,EAAO+H,GAAGwE,GAE1B,CACA,OAAOD,CAAG,GACT,IACHrM,KAAMuI,EAA0B4B,sBAuMsBpK,OApNtD0I,MAsNI,MAAM8D,EAAiBhB,EACnBxL,EAAO6F,QAAO,CAACL,EAAGuC,IAAOyD,EAAkCD,SAASxD,KACpE/H,EAEJ,MAAO,CACL4L,IAAKf,EACLzE,MAAOyF,EAAAA,GAAAA,UACPxD,KAAM,CACJ,CACEpI,KAAM6L,EAAAA,GAAAA,oBACN9L,OAAQwM,IAGb,EAGH,IAAIC,GAAsB,EAC1B,MAAMC,EAA4B3H,KAAKgE,OAAO4D,MAvT/CC,EAwTe7H,KAAK8D,KAAKgE,oBAvTtBpF,GACK,IAAIqF,EAAAA,GAAYC,IACrB,IAAI7F,EAAc,GACd8F,GAAU,EAEd,MAAMC,EAAa,KACjBF,EAAWtD,KAAKvC,GAChBA,EAAS,EAAE,EAGPgG,EAAaN,EAAkBO,UAAU,CAC7C1D,KAAO2D,IACLJ,EAAUI,EAENJ,GAAW9F,EAAOP,QACpBsG,GACF,IAIEI,EAAY5F,EAAO0F,UAAU,CACjC1D,KAAKpG,GACC2J,EACG9F,EAAOP,OAGVsG,IAFAF,EAAWtD,KAAK,CAACpG,IAKnB6D,EAAOZ,KAAKjD,EAEhB,EACA6E,MAAMA,GACJ6E,EAAW7E,MAAMA,EACnB,EACAc,WACE+D,EAAW/D,UACb,IAGF,MAAO,KACLqE,EAAUnE,cACVgE,EAAWhE,aAAa,CACzB,MA6QDxD,EAAAA,EAAAA,IAAI,CAACgG,EAAU3D,KACb,MAAMuF,EAAS7E,EAAeiD,EAAUlD,EAA0BvD,OAC5DsI,EAAYD,EAAO3G,OAAS2G,EAAOA,EAAO3G,OAAS,GAAGuB,WAAQ0C,EAEpE,GAAI6B,EAEF,OADAA,GAAsB,EACfhB,EAAyBC,EAAU6B,GAG5C,GAAID,EAAO3G,OAET,OAAO8E,EAAyBC,EAAU6B,GAI5C,GADsB7B,EAAS8B,MAAMC,GAAMA,EAAExN,OAASuI,EAA0B2B,gBAG9E,OAAOsB,EAAyBC,OAAUd,GAG5C,MAAM8C,EAA6BjF,EAAeiD,EAAUlD,EAA0B4B,qBAKtF,OAJIsD,EAA2B/G,SAAW+E,EAAS/E,QACjD2C,QAAQ4C,KAAM,4BAA2BR,EAAShG,KAAI,QAAC,KAAEzF,GAAM,SAAKA,CAAI,OAGnEkM,EAAmCuB,EAA2B,KAlV1Ed,MAsVC,OAAO,IAAIE,EAAAA,GAAwCC,IACjD,MAAMY,EAAMjB,EAA0BS,UAAU,CAC9C1D,KAAOgE,IACLV,EAAWtD,KAAKgE,EAAE,EAEpBvF,MAAQD,IACN8E,EAAW7E,MAAMD,EAAI,EAEvBe,SAAU,KACR+D,EAAW/D,UAAU,IAIzB,MAAO,KAEL2E,EAAIzE,cACCnE,KAAKgE,OAAOK,WACfrE,KAAK+F,uBACL/F,KAAK2F,kBAAoBkD,WAAW7I,KAAK8I,wBAAyB9I,KAAK8D,KAAKiF,mBAC9E,CACD,GACD,IACH,KAjQmBjF,KAAAA,EAClB9D,KAAKkF,YAAc8D,EAAAA,GAAAA,MAAyBlF,EAAKmF,8BACjDjJ,KAAKkE,uBAAyBJ,EAAKoF,qBAAqBd,UAAU,CAChEjF,MAAOnD,KAAKmJ,QACZlF,SAAUjE,KAAKoJ,WACf1E,KAAM1E,KAAKqJ,QAEf,E,uIChHK,MAAMC,EAgBXzJ,YAAYrD,EAAY+M,GAA0B,+CAbhCC,KAAKC,OAAK,0DAIV,IAAIC,EAAAA,GAA8B,qKAkG1B,KAEV,IADA1J,KAAKgE,OAAO2F,UAAU/H,QAElC5B,KAAK4J,YACP,IA5FA5J,KAAKxD,GAAKA,EACVwD,KAAKuJ,KAAOA,EACZvJ,KAAK6J,cAAgB,CACnB3O,KAAM4O,EAAAA,GAAAA,OACNtN,KACAuN,UAAW/J,KAAKgK,OAChB3I,MAAO2D,EAAAA,GAAAA,UAEJiF,EAAAA,EAAAA,IAA0BV,KAC7BvJ,KAAK6J,cAAcxI,MAAQ2D,EAAAA,GAAAA,QAC3BhF,KAAK6J,cAAc1G,MAAQ,0BAE/B,CAGA+G,YACE,GAAIlK,KAAKmK,WACP,MAAM,IAAIjK,MAAM,+BAAiCF,KAAKxD,IAExDwD,KAAKmK,YAAa,EAElBnK,KAAKoK,aAAcC,GAAG,eAAgBC,IACpC,IACMA,EAAIhH,OACFgH,EAAIhH,KAAKiH,SACXvK,KAAKwK,sBAAwBF,EAAIhH,MAGnCtD,KAAKgE,OAAOU,KAAK,CACfxJ,KAAM4O,EAAAA,GAAAA,QACN1G,QAASkH,EAAIhH,QAKbtD,KAAK6J,cAAc1G,QACrBnD,KAAK6J,cAAcE,UAAYP,KAAKC,aAC7BzJ,KAAK6J,cAAc1G,MAC1BnD,KAAKyK,aAOT,CALE,MAAOvH,GACPqB,QAAQC,IAAI,gBAAiBxE,KAAKuJ,KAAMrG,GACxClD,KAAK6J,cAAc1G,MAAQD,EAC3BlD,KAAK6J,cAAcE,UAAYP,KAAKC,MACpCzJ,KAAKyK,YACP,KAECJ,GAAG,SAAUC,IACZtK,KAAK6J,cAAcE,UAAYP,KAAKC,MACpCzJ,KAAK6J,cAAc1G,MAAQmH,EAAInH,MAAMC,QACrCpD,KAAKyK,YAAY,IAElBJ,GAAG,cAAeC,IAA2B,MAC5CtK,KAAK6J,cAAcE,UAAYP,KAAKC,MACpCzJ,KAAK6J,cAAcxI,MAAQ2D,EAAAA,GAAAA,iBACpBhF,KAAK6J,cAAc1G,MAEd,QAAZ,EAAImH,EAAIhH,YAAI,OAAR,EAAUiH,SACZvK,KAAKwK,sBAAwBF,EAAIhH,MAEnCtD,KAAKyK,WAAWH,EAAIhH,KAAK,IAE1B+G,GAAG,gBAAgB,KAClBrK,KAAK6J,cAAcE,UAAYP,KAAKC,MACpCzJ,KAAK6J,cAAcxI,MAAQ2D,EAAAA,GAAAA,aAC3BhF,KAAKyK,YAAY,IAElBJ,GAAG,eAAe,KACjBrK,KAAK6J,cAAcE,UAAYP,KAAKC,MACpCzJ,KAAK6J,cAAcxI,MAAQ2D,EAAAA,GAAAA,WAC3BhF,KAAKyK,YAAY,IAElBJ,GAAG,QAASC,IACXtK,KAAKgE,OAAOU,KAAK,CAAExJ,KAAM4O,EAAAA,GAAAA,KAA2BY,KAAMJ,EAAIK,KAAKD,MAAO,IAE3EL,GAAG,SAAUC,IACZtK,KAAKgE,OAAOU,KAAK,CAAExJ,KAAM4O,EAAAA,GAAAA,MAA4BY,KAAMJ,EAAIK,KAAKD,MAAO,GAEjF,CAEQD,WAAWrH,GACjB,MAAMwH,EAAO,OAAH,UAAQ5K,KAAK6J,eACnBzG,IACFwH,EAAKxH,QAAUA,GAEjBpD,KAAKgE,OAAOU,KAAKkG,EACnB,CAYAC,YACE,OAAO,IAAI9C,EAAAA,GAAYC,IAAe,MACpC,MAAM8C,EAAiB,OAAH,UAAQ9K,KAAK6J,eACO,MAAV,QAA9B,EAAI7J,KAAKwK,6BAAqB,OAA1B,EAA4BD,SAE9BO,EAAe1H,QAAU,CAAEmH,OAAkC,QAA5B,EAAEvK,KAAKwK,6BAAqB,aAA1B,EAA4BD,SAGjEvC,EAAWtD,KAAK,OAAD,UAAM1E,KAAK6J,cAAe,CAAAzG,QAASpD,KAAKwK,yBAEvD,MAAM5B,EAAM5I,KAAKgE,OAAOoE,UAAUJ,GAClC,MAAO,KACLY,EAAIzE,cAIU,IAHAnE,KAAKgE,OAAO2F,UAAU/H,QAIlCiH,WAAW7I,KAAK+K,wBAAyB,IAC3C,CACD,GAEL,CAKAC,oBACE,OAAKhL,KAAKoK,aAIHpK,KAAKoK,aAAca,WAAWC,MAAMzK,IAClC,CACL0K,MAAO3J,OAAO4J,KAAK3K,EAAE4K,aALhBC,QAAQC,OAAO,iBAQ1B,CAKA3B,aACE5J,KAAK6J,cAAcxI,MAAQ2D,EAAAA,GAAAA,SAC3BhF,KAAK6J,cAAcE,UAAYP,KAAKC,MAEhCzJ,KAAKoK,eACPpK,KAAKoK,aAAajG,cAClBnE,KAAKoK,aAAaoB,qBAClBxL,KAAKoK,kBAAevE,GAGtB7F,KAAKgE,OAAOC,WAEZjE,KAAKgE,OAAOU,KAAK,OAAD,UAAM1E,KAAK6J,gBAC3B7J,KAAKgE,OAAOC,WAERjE,KAAKyL,kBACPzL,KAAKyL,kBAET,CAEAC,kBAAkBxI,GAChBlD,KAAK6J,cAAc1G,MAAQD,EAC3BlD,KAAKyK,aACLzK,KAAK4J,YACP,E,wHCzJF,MAAMX,EAAgE,CACpEhC,UAAW,IACX0E,SAAUC,IACVxF,OAAQC,EAAAA,GAAAA,QAKH,MAAMwF,EAQXhM,YAAoBiE,GAAyB,cAP7B,IAAI/D,KAAoC,mCAC4B,CAAC,GAAC,mKA8CjE+L,IACnB9L,KAAK+L,gBAAgBrH,MAAK,EAAK,IAChC,uBAEuBoH,IACtB9L,KAAK+L,gBAAgBrH,MAAK,EAAM,IACjC,8BAE8BoH,IAC7BvH,QAAQC,IAAI,uCAAwCsH,EAAQ,IAC7D,6BA0DoB,IACZ9L,KAAK+L,gBAAgBC,iBAC7B,oBAK2CC,GACnCjM,KAAKkM,WAAcD,GAASpB,cACpC,gCAEgCzM,IAA8B,aAClD,QADkD,EAC7DA,EAAQyI,WAAG,QAAK,QAAOsF,GAAiB,gCAEb/N,IAC3B,MAAMqG,GAAY2H,EAAAA,EAAAA,IAAgBhO,EAAQmL,MACpC8C,EAAiBrM,KAAKsM,0BAA0B7H,GAEtD,GAAI4H,EACF,OAAOA,EAGT,MAAME,EAAUvM,KAAKkM,WAAW9N,EAAQmL,MAWxC,OAVAvJ,KAAKsM,0BAA0B7H,GAAa,IAAIZ,EAAe,CAC7DY,YACAL,WAAY,YACHpE,KAAKsM,0BAA0B7H,EAAU,EAElDyE,qBAAsBqD,EAAQ1B,YAC9B/C,oBAAqB9H,KAAKwM,8BAC1BvD,+BACAF,kBArJ8B,MAuJzB/I,KAAKsM,0BAA0B7H,EAAU,IACjD,wBAIgDrG,IAC/C,MAAMqO,EAAkBzM,KAAK0M,sBAAsBtO,GAGnD,OADe4B,KAAK2M,kBAAkBvO,GACxB/B,IAAI+B,EAASqO,EAAgB,IAC5C,uBAO6CzB,UACxChL,KAAK4M,WAAWvL,QAAUwL,EAAAA,MAAAA,iBACtB7M,KAAK8M,kBAEN9M,KAAK4M,WAAWG,IAAI,gBAAiB3O,EAAQ4O,SACrD,sBAO4Cf,GACpCjM,KAAKkM,WAAWD,GAASgB,gBACjC,KA5KmBnJ,KAAAA,EAClB9D,KAAKwM,8BAAgC1I,EAAK0I,8BAA8B5E,MAAKsF,EAAAA,EAAAA,MAASC,EAAAA,EAAAA,IAAU,IAEhG,IAAIC,EAAW,GAAEtJ,EAAKuJ,OAAOC,QAAQ,QAAS,oBAE9C,MAAMC,EAAQzJ,EAAK0J,iBACL,OAAVD,GAA4B,KAAVA,IACpBH,GAAW,eAAiBG,GAG9BvN,KAAK4M,WAAa,IAAIa,EAAAA,WAAWL,EAAS,CACxCM,QAAS,MAGP5J,EAAK6J,aAAgC,KAAjB7J,EAAK8J,SAC3B5N,KAAK4M,WAAWiB,UAElB7N,KAAK+L,gBAAkB,IAAI+B,EAAAA,EAAyB9N,KAAK4M,WAAWvL,QAAUwL,EAAAA,MAAAA,WAC9E7M,KAAK8M,kBAAoB,IAAIxB,SAAeyC,IAC1C,GAAI/N,KAAK4M,WAAWvL,QAAUwL,EAAAA,MAAAA,UAC5B,OAAOkB,IAET,MAAMC,EAAkB,KACtBD,IACA/N,KAAK4M,WAAWqB,eAAe,YAAaD,EAAgB,EAE9DhO,KAAK4M,WAAWsB,YAAY,YAAaF,EAAgB,IAI3DhO,KAAK4M,WAAWvC,GAAG,YAAarK,KAAKmO,WACrCnO,KAAK4M,WAAWvC,GAAG,aAAcrK,KAAKoO,cACtCpO,KAAK4M,WAAWvC,GAAG,eAAgBrK,KAAKoO,cACxCpO,KAAK4M,WAAWvC,GAAG,cAAerK,KAAKqO,oBACzC,CAsBQnC,WAAqB3C,GAC3B,MAAM/M,EAAM,GAAEwD,KAAK8D,KAAKwK,SAAS/E,EAAKgF,SAAShF,EAAKiF,aAAajF,EAAKkF,OACtE,IAAIlC,EAAUvM,KAAK0O,KAAKrS,IAAIG,GAC5B,OAAe,MAAX+P,EACKA,GAGTA,EAAU,IAAIjD,EAAsB9M,EAAI+M,GACpCgD,EAAQ1C,cAAcxI,QAAU2D,EAAAA,GAAAA,UAGpCuH,EAAQd,iBAAmB,KACzBzL,KAAK0O,KAAKC,OAAOnS,GAGjBwD,KAAK4M,WAAWgC,mBAAmB5O,KAAK4M,WAAWiC,gBAAgBrS,GAAI,EAEzEwD,KAAK0O,KAAK5M,IAAItF,EAAI+P,GAGlBvM,KAAK8O,YAAYvC,GAASwC,OAAO7L,IAC3BqJ,IACFA,EAAQ1C,cAAcxI,MAAQ2D,EAAAA,GAAAA,QAC9BuH,EAAQb,kBAAkBxI,IAE5BlD,KAAK0O,KAAKC,OAAOnS,EAAG,KAhBb+P,EAqBX,CAEA,kBAA0BA,GACpBvM,KAAK4M,WAAWvL,QAAUwL,EAAAA,MAAAA,iBACtB7M,KAAK8M,kBAEb,MAAM1C,EAAepK,KAAK4M,WAAWoC,gBAAgBzC,EAAQ/P,GAAI,CAC/D8G,KAAMiJ,EAAQhD,KAAKjG,OAErBiJ,EAAQnC,aAAeA,EACvBmC,EAAQrC,YACRE,EAAahC,WAEf,EA6EF,IAAI+D,EAAgB,C,4CC9OpB,MAAM8C,EAAiC,CACrCC,UAAU5Q,GACDA,GAASA,aAAiB6Q,EAAAA,GAGnCnI,UAAU1I,GACR,MAAM8Q,EAAMC,EAAAA,GAAc/Q,IAEpB,MAAEgR,EAAK,MAAEC,GAAU,IAAIC,eAI7B,OAFAH,EAAAA,GAAeD,EAAKE,GAEb,CAACC,EAAO,CAACA,GAClB,EAEAE,YAAYnR,IACVA,EAAMoR,QAECL,EAAAA,GAA0B/Q,KAGrC+Q,EAAAA,GAAAA,IAA6B,oBAAqBJ,E,kBCvB3C,SAASU,EAAmBC,EAAsBC,GAEvD,OAAOD,EAAatC,QADD,wBACqB,CAACwC,EAAGC,IAAQF,EAAUE,GAAMF,EAAUE,GAAMA,GACtF,C","sources":["webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/field/fieldComparers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/fieldTypeMatcher.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/ids.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/refIdMatcher.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/simpleFieldMatcher.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/equalMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/nullMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/numericMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/rangeMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/regexMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/transformers/ids.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/utils/Registry.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/vector/ArrayVector.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/vector/SortedVector.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/vector/vectorToArray.ts","webpack://grafana/./.yarn/__virtual__/@grafana-runtime-virtual-f9d61a496b/1/packages/grafana-runtime/src/utils/toDataQueryError.ts","webpack://grafana/./public/app/features/live/centrifuge/LiveDataStream.ts","webpack://grafana/./public/app/features/live/centrifuge/channel.ts","webpack://grafana/./public/app/features/live/centrifuge/service.ts","webpack://grafana/./public/app/features/live/centrifuge/transferHandlers.ts","webpack://grafana/./public/app/plugins/datasource/prometheus/legend.ts"],"sourcesContent":["import { isNumber } from 'lodash';\n\nimport { dateTime } from '../datetime';\nimport { Field, FieldType } from '../types/dataFrame';\nimport { Vector } from '../types/vector';\n\ntype IndexComparer = (a: number, b: number) => number;\n\n/** @public */\nexport const fieldIndexComparer = (field: Field, reverse = false): IndexComparer => {\n  const values = field.values;\n\n  switch (field.type) {\n    case FieldType.number:\n      return numericIndexComparer(values, reverse);\n    case FieldType.string:\n      return stringIndexComparer(values, reverse);\n    case FieldType.boolean:\n      return booleanIndexComparer(values, reverse);\n    case FieldType.time:\n      return timeIndexComparer(values, reverse);\n    default:\n      return naturalIndexComparer(reverse);\n  }\n};\n\n/** @public */\nexport const timeComparer = (a: any, b: any): number => {\n  if (!a || !b) {\n    return falsyComparer(a, b);\n  }\n\n  if (isNumber(a) && isNumber(b)) {\n    return numericComparer(a, b);\n  }\n\n  if (dateTime(a).isBefore(b)) {\n    return -1;\n  }\n\n  if (dateTime(b).isBefore(a)) {\n    return 1;\n  }\n\n  return 0;\n};\n\n/** @public */\nexport const numericComparer = (a: number, b: number): number => {\n  return a - b;\n};\n\n/** @public */\nexport const stringComparer = (a: string, b: string): number => {\n  if (!a || !b) {\n    return falsyComparer(a, b);\n  }\n  return a.localeCompare(b);\n};\n\nexport const booleanComparer = (a: boolean, b: boolean): number => {\n  return falsyComparer(a, b);\n};\n\nconst falsyComparer = (a: any, b: any): number => {\n  if (!a && b) {\n    return 1;\n  }\n\n  if (a && !b) {\n    return -1;\n  }\n\n  return 0;\n};\n\nconst timeIndexComparer = (values: Vector<any>, reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA = values.get(a);\n    const vB = values.get(b);\n    return reverse ? timeComparer(vB, vA) : timeComparer(vA, vB);\n  };\n};\n\nconst booleanIndexComparer = (values: Vector<any>, reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA: boolean = values.get(a);\n    const vB: boolean = values.get(b);\n    return reverse ? booleanComparer(vB, vA) : booleanComparer(vA, vB);\n  };\n};\n\nconst numericIndexComparer = (values: Vector<any>, reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA: number = values.get(a);\n    const vB: number = values.get(b);\n    return reverse ? numericComparer(vB, vA) : numericComparer(vA, vB);\n  };\n};\n\nconst stringIndexComparer = (values: Vector<any>, reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA: string = values.get(a);\n    const vB: string = values.get(b);\n    return reverse ? stringComparer(vB, vA) : stringComparer(vA, vB);\n  };\n};\n\nconst naturalIndexComparer = (reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    return reverse ? numericComparer(b, a) : numericComparer(a, b);\n  };\n};\n","import { Field, FieldType, DataFrame } from '../../types/dataFrame';\nimport { FieldMatcherInfo } from '../../types/transformations';\n\nimport { FieldMatcherID } from './ids';\n\n// General Field matcher\nconst fieldTypeMatcher: FieldMatcherInfo<FieldType> = {\n  id: FieldMatcherID.byType,\n  name: 'Field Type',\n  description: 'match based on the field type',\n  defaultOptions: FieldType.number,\n\n  get: (type: FieldType) => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return type === field.type;\n    };\n  },\n\n  getOptionsDisplayText: (type: FieldType) => {\n    return `Field type: ${type}`;\n  },\n};\n\n// Numeric Field matcher\n// This gets its own entry so it shows up in the dropdown\nconst numericMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.numeric,\n  name: 'Numeric Fields',\n  description: 'Fields with type number',\n\n  get: () => {\n    return fieldTypeMatcher.get(FieldType.number);\n  },\n\n  getOptionsDisplayText: () => {\n    return 'Numeric Fields';\n  },\n};\n\n// Time Field matcher\nconst timeMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.time,\n  name: 'Time Fields',\n  description: 'Fields with type time',\n\n  get: () => {\n    return fieldTypeMatcher.get(FieldType.time);\n  },\n\n  getOptionsDisplayText: () => {\n    return 'Time Fields';\n  },\n};\n\n/**\n * Registry Initialization\n */\nexport function getFieldTypeMatchers(): FieldMatcherInfo[] {\n  return [fieldTypeMatcher, numericMatcher, timeMatcher];\n}\n","// This needs to be in its own file to avoid circular references\n\n// Builtin Predicates\n// not using 'any' and 'never' since they are reserved keywords\nexport enum MatcherID {\n  anyMatch = 'anyMatch', // checks children\n  allMatch = 'allMatch', // checks children\n  invertMatch = 'invertMatch', // checks child\n  alwaysMatch = 'alwaysMatch',\n  neverMatch = 'neverMatch',\n}\n\nexport enum FieldMatcherID {\n  // Specific Types\n  numeric = 'numeric',\n  time = 'time', // Can be multiple times\n  first = 'first',\n  firstTimeField = 'firstTimeField', // Only the first fime field\n\n  // With arguments\n  byType = 'byType',\n  byName = 'byName',\n  byNames = 'byNames',\n  byRegexp = 'byRegexp',\n  byRegexpOrNames = 'byRegexpOrNames',\n  byFrameRefID = 'byFrameRefID',\n  // byIndex = 'byIndex',\n  // byLabel = 'byLabel',\n}\n\n/**\n * Field name matchers\n */\nexport enum FrameMatcherID {\n  byName = 'byName',\n  byRefId = 'byRefId',\n  byIndex = 'byIndex',\n  byLabel = 'byLabel',\n}\n\n/**\n * @public\n */\nexport enum ValueMatcherID {\n  regex = 'regex',\n  isNull = 'isNull',\n  isNotNull = 'isNotNull',\n  greater = 'greater',\n  greaterOrEqual = 'greaterOrEqual',\n  lower = 'lower',\n  lowerOrEqual = 'lowerOrEqual',\n  equal = 'equal',\n  notEqual = 'notEqual',\n  between = 'between',\n}\n","import { stringToJsRegex } from '../../text';\nimport { DataFrame } from '../../types/dataFrame';\nimport { FrameMatcherInfo } from '../../types/transformations';\n\nimport { FrameMatcherID } from './ids';\n\n// General Field matcher\nconst refIdMacher: FrameMatcherInfo<string> = {\n  id: FrameMatcherID.byRefId,\n  name: 'Query refId',\n  description: 'match the refId',\n  defaultOptions: 'A',\n\n  get: (pattern: string) => {\n    const regex = stringToJsRegex(pattern);\n    return (frame: DataFrame) => {\n      return regex.test(frame.refId || '');\n    };\n  },\n\n  getOptionsDisplayText: (pattern: string) => {\n    return `RefID: ${pattern}`;\n  },\n};\n\nexport function getRefIdMatchers(): FrameMatcherInfo[] {\n  return [refIdMacher];\n}\n","import { Field, FieldType, DataFrame } from '../../types/dataFrame';\nimport { FieldMatcherInfo } from '../../types/transformations';\n\nimport { FieldMatcherID } from './ids';\n\nconst firstFieldMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.first,\n  name: 'First Field',\n  description: 'The first field in the frame',\n\n  get: (type: FieldType) => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return field === frame.fields[0];\n    };\n  },\n\n  getOptionsDisplayText: () => {\n    return `First field`;\n  },\n};\n\nconst firstTimeFieldMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.firstTimeField,\n  name: 'First time field',\n  description: 'The first field of type time in a frame',\n\n  get: (type: FieldType) => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return field.type === FieldType.time && field === frame.fields.find((f) => f.type === FieldType.time);\n    };\n  },\n\n  getOptionsDisplayText: () => {\n    return `First time field`;\n  },\n};\n\n/**\n * Registry Initialization\n */\nexport function getSimpleFieldMatchers(): FieldMatcherInfo[] {\n  return [firstFieldMatcher, firstTimeFieldMatcher];\n}\n","import { Field } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { BasicValueMatcherOptions } from './types';\n\nconst isEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions> = {\n  id: ValueMatcherID.equal,\n  name: 'Is equal',\n  description: 'Match where value for given field is equal to options value.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      // eslint-disable-next-line eqeqeq\n      return value == options.value;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({ value: '' }),\n};\n\nconst isNotEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions> = {\n  id: ValueMatcherID.notEqual,\n  name: 'Is not equal',\n  description: 'Match where value for given field is not equal to options value.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      // eslint-disable-next-line eqeqeq\n      return value != options.value;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is not null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({ value: '' }),\n};\n\nexport const getEqualValueMatchers = (): ValueMatcherInfo[] => [isEqualValueMatcher, isNotEqualValueMatcher];\n","import { Field } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { ValueMatcherOptions } from './types';\n\nconst isNullValueMatcher: ValueMatcherInfo<ValueMatcherOptions> = {\n  id: ValueMatcherID.isNull,\n  name: 'Is null',\n  description: 'Match where value for given field is null.',\n  get: () => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      return value == null;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({}),\n};\n\nconst isNotNullValueMatcher: ValueMatcherInfo<ValueMatcherOptions> = {\n  id: ValueMatcherID.isNotNull,\n  name: 'Is not null',\n  description: 'Match where value for given field is not null.',\n  get: () => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      return value != null;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is not null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({}),\n};\n\nexport const getNullValueMatchers = (): ValueMatcherInfo[] => [isNullValueMatcher, isNotNullValueMatcher];\n","import { Field, FieldType } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { BasicValueMatcherOptions } from './types';\n\nconst isGreaterValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<number>> = {\n  id: ValueMatcherID.greater,\n  name: 'Is greater',\n  description: 'Match when field value is greater than option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value > options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is greater than: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nconst isGreaterOrEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<number>> = {\n  id: ValueMatcherID.greaterOrEqual,\n  name: 'Is greater or equal',\n  description: 'Match when field value is greater than or equal to option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value >= options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is greater than or equal to: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nconst isLowerValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<number>> = {\n  id: ValueMatcherID.lower,\n  name: 'Is lower',\n  description: 'Match when field value is lower than option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value < options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is lower than: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nconst isLowerOrEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<number>> = {\n  id: ValueMatcherID.lowerOrEqual,\n  name: 'Is lower or equal',\n  description: 'Match when field value is lower or equal than option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value <= options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is lower or equal than: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nexport const getNumericValueMatchers = (): ValueMatcherInfo[] => [\n  isGreaterValueMatcher,\n  isGreaterOrEqualValueMatcher,\n  isLowerValueMatcher,\n  isLowerOrEqualValueMatcher,\n];\n","import { Field, FieldType } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { RangeValueMatcherOptions } from './types';\n\nconst isBetweenValueMatcher: ValueMatcherInfo<RangeValueMatcherOptions<number>> = {\n  id: ValueMatcherID.between,\n  name: 'Is between',\n  description: 'Match when field value is between given option values.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value > options.from && value < options.to;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is between ${options.from} and ${options.to}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ from: 0, to: 100 }),\n};\n\nexport const getRangeValueMatchers = (): ValueMatcherInfo[] => [isBetweenValueMatcher];\n","import { Field } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { BasicValueMatcherOptions } from './types';\n\nconst regexValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<string>> = {\n  id: ValueMatcherID.regex,\n  name: 'Regex',\n  description: 'Match when field value is matching regex.',\n  get: (options) => {\n    const regex = new RegExp(options.value);\n\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      return regex.test(value);\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is matching regex: ${options.value}`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({ value: '.*' }),\n};\n\nexport const getRegexValueMatcher = (): ValueMatcherInfo[] => [regexValueMatcher];\n","export enum DataTransformerID {\n  append = 'append',\n  //  rotate = 'rotate', // Columns to rows\n  reduce = 'reduce',\n  order = 'order',\n  organize = 'organize',\n  rename = 'rename',\n  calculateField = 'calculateField',\n  /** @deprecated use joinByField */\n  seriesToColumns = 'seriesToColumns',\n  seriesToRows = 'seriesToRows',\n  merge = 'merge',\n  concatenate = 'concatenate',\n  labelsToFields = 'labelsToFields',\n  filterFields = 'filterFields',\n  filterFieldsByName = 'filterFieldsByName',\n  filterFrames = 'filterFrames',\n  filterByRefId = 'filterByRefId',\n  renameByRegex = 'renameByRegex',\n  filterByValue = 'filterByValue',\n  noop = 'noop',\n  ensureColumns = 'ensureColumns',\n  groupBy = 'groupBy',\n  sortBy = 'sortBy',\n  histogram = 'histogram',\n  configFromData = 'configFromData',\n  rowsToFields = 'rowsToFields',\n  prepareTimeSeries = 'prepareTimeSeries',\n  convertFieldType = 'convertFieldType',\n  fieldLookup = 'fieldLookup',\n  heatmap = 'heatmap',\n  spatial = 'spatial',\n  joinByField = 'joinByField',\n  joinByLabels = 'joinByLabels',\n  extractFields = 'extractFields',\n  groupingToMatrix = 'groupingToMatrix',\n  limit = 'limit',\n  partitionByValues = 'partitionByValues',\n}\n","import { PluginState } from '../types';\nimport { SelectableValue } from '../types/select';\n\nexport interface RegistryItem {\n  id: string; // Unique Key -- saved in configs\n  name: string; // Display Name, can change without breaking configs\n  description?: string;\n  aliasIds?: string[]; // when the ID changes, we may want backwards compatibility ('current' => 'last')\n\n  /**\n   * Some extensions should not be user selectable\n   *  like: 'all' and 'any' matchers;\n   */\n  excludeFromPicker?: boolean;\n\n  /**\n   * Optional feature state\n   */\n  state?: PluginState;\n}\n\nexport interface RegistryItemWithOptions<TOptions = any> extends RegistryItem {\n  /**\n   * Convert the options to a string\n   */\n  getOptionsDisplayText?: (options: TOptions) => string;\n\n  /**\n   * Default options used if nothing else is specified\n   */\n  defaultOptions?: TOptions;\n}\n\ninterface RegistrySelectInfo {\n  options: Array<SelectableValue<string>>;\n  current: Array<SelectableValue<string>>;\n}\n\nexport class Registry<T extends RegistryItem> {\n  private ordered: T[] = [];\n  private byId = new Map<string, T>();\n  private initialized = false;\n\n  constructor(private init?: () => T[]) {\n    this.init = init;\n  }\n\n  setInit = (init: () => T[]) => {\n    if (this.initialized) {\n      throw new Error('Registry already initialized');\n    }\n    this.init = init;\n  };\n\n  getIfExists(id: string | undefined): T | undefined {\n    if (!this.initialized) {\n      this.initialize();\n    }\n\n    if (id) {\n      return this.byId.get(id);\n    }\n\n    return undefined;\n  }\n\n  private initialize() {\n    if (this.init) {\n      for (const ext of this.init()) {\n        this.register(ext);\n      }\n    }\n    this.sort();\n    this.initialized = true;\n  }\n\n  get(id: string): T {\n    const v = this.getIfExists(id);\n    if (!v) {\n      throw new Error(`\"${id}\" not found in: ${this.list().map((v) => v.id)}`);\n    }\n    return v;\n  }\n\n  selectOptions(current?: string[], filter?: (ext: T) => boolean): RegistrySelectInfo {\n    if (!this.initialized) {\n      this.initialize();\n    }\n\n    const select = {\n      options: [],\n      current: [],\n    } as RegistrySelectInfo;\n\n    const currentOptions: Record<string, SelectableValue<string>> = {};\n    if (current) {\n      for (const id of current) {\n        currentOptions[id] = {};\n      }\n    }\n\n    for (const ext of this.ordered) {\n      if (ext.excludeFromPicker) {\n        continue;\n      }\n      if (filter && !filter(ext)) {\n        continue;\n      }\n\n      const option = {\n        value: ext.id,\n        label: ext.name,\n        description: ext.description,\n      };\n\n      if (ext.state === PluginState.alpha) {\n        option.label += ' (alpha)';\n      }\n\n      select.options.push(option);\n      if (currentOptions[ext.id]) {\n        currentOptions[ext.id] = option;\n      }\n    }\n\n    if (current) {\n      // this makes sure we preserve the order of ids\n      select.current = Object.values(currentOptions);\n    }\n\n    return select;\n  }\n\n  /**\n   * Return a list of values by ID, or all values if not specified\n   */\n  list(ids?: string[]): T[] {\n    if (!this.initialized) {\n      this.initialize();\n    }\n\n    if (ids) {\n      const found: T[] = [];\n      for (const id of ids) {\n        const v = this.getIfExists(id);\n        if (v) {\n          found.push(v);\n        }\n      }\n      return found;\n    }\n\n    return this.ordered;\n  }\n\n  isEmpty(): boolean {\n    if (!this.initialized) {\n      this.initialize();\n    }\n\n    return this.ordered.length === 0;\n  }\n\n  register(ext: T) {\n    if (this.byId.has(ext.id)) {\n      throw new Error('Duplicate Key:' + ext.id);\n    }\n\n    this.byId.set(ext.id, ext);\n    this.ordered.push(ext);\n\n    if (ext.aliasIds) {\n      for (const alias of ext.aliasIds) {\n        if (!this.byId.has(alias)) {\n          this.byId.set(alias, ext);\n        }\n      }\n    }\n\n    if (this.initialized) {\n      this.sort();\n    }\n  }\n\n  private sort() {\n    // TODO sort the list\n  }\n}\n","import { MutableVector } from '../types/vector';\n\nimport { FunctionalVector } from './FunctionalVector';\n\n/**\n * @public\n */\nexport class ArrayVector<T = any> extends FunctionalVector<T> implements MutableVector<T> {\n  buffer: T[];\n\n  constructor(buffer?: T[]) {\n    super();\n    this.buffer = buffer ? buffer : [];\n  }\n\n  get length() {\n    return this.buffer.length;\n  }\n\n  add(value: T) {\n    this.buffer.push(value);\n  }\n\n  get(index: number): T {\n    return this.buffer[index];\n  }\n\n  set(index: number, value: T) {\n    this.buffer[index] = value;\n  }\n\n  reverse() {\n    this.buffer.reverse();\n  }\n\n  toArray(): T[] {\n    return this.buffer;\n  }\n\n  toJSON(): T[] {\n    return this.buffer;\n  }\n}\n","import { Vector } from '../types/vector';\n\nimport { vectorToArray } from './vectorToArray';\n\n/**\n * Values are returned in the order defined by the input parameter\n */\nexport class SortedVector<T = any> implements Vector<T> {\n  constructor(private source: Vector<T>, private order: number[]) {}\n\n  get length(): number {\n    return this.source.length;\n  }\n\n  get(index: number): T {\n    return this.source.get(this.order[index]);\n  }\n\n  toArray(): T[] {\n    return vectorToArray(this);\n  }\n\n  toJSON(): T[] {\n    return vectorToArray(this);\n  }\n\n  getOrderArray(): number[] {\n    return this.order;\n  }\n}\n","import { Vector } from '../types/vector';\n\nexport function vectorToArray<T>(v: Vector<T>): T[] {\n  const arr: T[] = Array(v.length);\n  for (let i = 0; i < v.length; i++) {\n    arr[i] = v.get(i);\n  }\n  return arr;\n}\n","import { DataQueryError } from '@grafana/data';\n\n/**\n * Convert an object into a DataQueryError -- if this is an HTTP response,\n * it will put the correct values in the error field\n *\n * @public\n */\nexport function toDataQueryError(err: DataQueryError | string | unknown): DataQueryError {\n  const error = (err || {}) as DataQueryError;\n\n  if (!error.message) {\n    if (typeof err === 'string' || err instanceof String) {\n      return { message: err } as DataQueryError;\n    }\n\n    let message = 'Query error';\n    if (error.message) {\n      message = error.message;\n    } else if (error.data && error.data.message && error.data?.message !== 'Query data error') {\n      message = error.data.message;\n    } else if (error?.data?.message === 'Query data error' && error?.data?.error) {\n      message = error.data.error;\n    } else if (error.data && error.data.error) {\n      message = error.data.error;\n    } else if (error.status) {\n      message = `Query error: ${error.status} ${error.statusText}`;\n    }\n    error.message = message;\n  }\n\n  return error;\n}\n","import { map, Observable, ReplaySubject, Subject, Subscriber, Subscription } from 'rxjs';\n\nimport {\n  DataFrameJSON,\n  DataQueryError,\n  Field,\n  isLiveChannelMessageEvent,\n  isLiveChannelStatusEvent,\n  LiveChannelConnectionState,\n  LiveChannelEvent,\n  LiveChannelId,\n  LoadingState,\n} from '@grafana/data';\nimport { LiveDataStreamOptions, StreamingFrameAction, StreamingFrameOptions } from '@grafana/runtime/src/services/live';\nimport { toDataQueryError } from '@grafana/runtime/src/utils/toDataQueryError';\n\nimport { getStreamingFrameOptions, StreamingDataFrame } from '../data/StreamingDataFrame';\nimport { StreamingResponseDataType } from '../data/utils';\n\nimport { DataStreamSubscriptionKey, StreamingDataQueryResponse } from './service';\n\nconst bufferIfNot =\n  (canEmitObservable: Observable<boolean>) =>\n  <T>(source: Observable<T>): Observable<T[]> => {\n    return new Observable((subscriber: Subscriber<T[]>) => {\n      let buffer: T[] = [];\n      let canEmit = true;\n\n      const emitBuffer = () => {\n        subscriber.next(buffer);\n        buffer = [];\n      };\n\n      const canEmitSub = canEmitObservable.subscribe({\n        next: (val) => {\n          canEmit = val;\n\n          if (canEmit && buffer.length) {\n            emitBuffer();\n          }\n        },\n      });\n\n      const sourceSub = source.subscribe({\n        next(value) {\n          if (canEmit) {\n            if (!buffer.length) {\n              subscriber.next([value]);\n            } else {\n              emitBuffer();\n            }\n          } else {\n            buffer.push(value);\n          }\n        },\n        error(error) {\n          subscriber.error(error);\n        },\n        complete() {\n          subscriber.complete();\n        },\n      });\n\n      return () => {\n        sourceSub.unsubscribe();\n        canEmitSub.unsubscribe();\n      };\n    });\n  };\n\nexport type DataStreamHandlerDeps<T> = {\n  channelId: LiveChannelId;\n  liveEventsObservable: Observable<LiveChannelEvent<T>>;\n  onShutdown: () => void;\n  subscriberReadiness: Observable<boolean>;\n  defaultStreamingFrameOptions: Readonly<StreamingFrameOptions>;\n  shutdownDelayInMs: number;\n};\n\nenum InternalStreamMessageType {\n  Error,\n  NewValuesSameSchema,\n  ChangedSchema,\n}\n\ntype InternalStreamMessageTypeToData = {\n  [InternalStreamMessageType.Error]: {\n    error: DataQueryError;\n  };\n  [InternalStreamMessageType.ChangedSchema]: {};\n  [InternalStreamMessageType.NewValuesSameSchema]: {\n    values: unknown[][];\n  };\n};\n\ntype InternalStreamMessage<T = InternalStreamMessageType> = T extends InternalStreamMessageType\n  ? {\n      type: T;\n    } & InternalStreamMessageTypeToData[T]\n  : never;\n\nconst reduceNewValuesSameSchemaMessages = (\n  packets: Array<InternalStreamMessage<InternalStreamMessageType.NewValuesSameSchema>>\n) => ({\n  values: packets.reduce((acc, { values }) => {\n    for (let i = 0; i < values.length; i++) {\n      if (!acc[i]) {\n        acc[i] = [];\n      }\n      for (let j = 0; j < values[i].length; j++) {\n        acc[i].push(values[i][j]);\n      }\n    }\n    return acc;\n  }, [] as unknown[][]),\n  type: InternalStreamMessageType.NewValuesSameSchema,\n});\n\nconst filterMessages = <T extends InternalStreamMessageType>(\n  packets: InternalStreamMessage[],\n  type: T\n): Array<InternalStreamMessage<T>> => packets.filter((p) => p.type === type) as Array<InternalStreamMessage<T>>;\n\nexport class LiveDataStream<T = unknown> {\n  private frameBuffer: StreamingDataFrame;\n  private liveEventsSubscription: Subscription;\n  private stream: Subject<InternalStreamMessage> = new ReplaySubject(1);\n  private shutdownTimeoutId: ReturnType<typeof setTimeout> | undefined;\n\n  constructor(private deps: DataStreamHandlerDeps<T>) {\n    this.frameBuffer = StreamingDataFrame.empty(deps.defaultStreamingFrameOptions);\n    this.liveEventsSubscription = deps.liveEventsObservable.subscribe({\n      error: this.onError,\n      complete: this.onComplete,\n      next: this.onNext,\n    });\n  }\n\n  private shutdown = () => {\n    this.stream.complete();\n    this.liveEventsSubscription.unsubscribe();\n    this.deps.onShutdown();\n  };\n\n  private shutdownIfNoSubscribers = () => {\n    if (!this.stream.observed) {\n      this.shutdown();\n    }\n  };\n\n  private onError = (err: any) => {\n    console.log('LiveQuery [error]', { err }, this.deps.channelId);\n    this.stream.next({\n      type: InternalStreamMessageType.Error,\n      error: toDataQueryError(err),\n    });\n    this.shutdown();\n  };\n\n  private onComplete = () => {\n    console.log('LiveQuery [complete]', this.deps.channelId);\n    this.shutdown();\n  };\n\n  private onNext = (evt: LiveChannelEvent) => {\n    if (isLiveChannelMessageEvent(evt)) {\n      this.process(evt.message);\n      return;\n    }\n\n    const liveChannelStatusEvent = isLiveChannelStatusEvent(evt);\n    if (liveChannelStatusEvent && evt.error) {\n      this.stream.next({\n        type: InternalStreamMessageType.Error,\n        error: {\n          ...toDataQueryError(evt.error),\n          message: `Streaming channel error: ${evt.error.message}`,\n        },\n      });\n      return;\n    }\n\n    if (\n      liveChannelStatusEvent &&\n      (evt.state === LiveChannelConnectionState.Connected || evt.state === LiveChannelConnectionState.Pending) &&\n      evt.message\n    ) {\n      this.process(evt.message);\n    }\n  };\n\n  private process = (msg: DataFrameJSON) => {\n    const packetInfo = this.frameBuffer.push(msg);\n\n    if (packetInfo.schemaChanged) {\n      this.stream.next({\n        type: InternalStreamMessageType.ChangedSchema,\n      });\n    } else {\n      this.stream.next({\n        type: InternalStreamMessageType.NewValuesSameSchema,\n        values: this.frameBuffer.getValuesFromLastPacket(),\n      });\n    }\n  };\n\n  private resizeBuffer = (bufferOptions: StreamingFrameOptions) => {\n    if (bufferOptions && this.frameBuffer.needsResizing(bufferOptions)) {\n      this.frameBuffer.resize(bufferOptions);\n    }\n  };\n\n  private prepareInternalStreamForNewSubscription = (options: LiveDataStreamOptions): void => {\n    if (!this.frameBuffer.hasAtLeastOnePacket() && options.frame) {\n      // will skip initial frames from subsequent subscribers\n      this.process(options.frame);\n    }\n  };\n\n  private clearShutdownTimeout = () => {\n    if (this.shutdownTimeoutId) {\n      clearTimeout(this.shutdownTimeoutId);\n      this.shutdownTimeoutId = undefined;\n    }\n  };\n\n  get = (options: LiveDataStreamOptions, subKey: DataStreamSubscriptionKey): Observable<StreamingDataQueryResponse> => {\n    this.clearShutdownTimeout();\n    const buffer = getStreamingFrameOptions(options.buffer);\n\n    this.resizeBuffer(buffer);\n    this.prepareInternalStreamForNewSubscription(options);\n\n    const shouldSendLastPacketOnly = options?.buffer?.action === StreamingFrameAction.Replace;\n    const fieldsNamesFilter = options.filter?.fields;\n    const dataNeedsFiltering = fieldsNamesFilter?.length;\n    const fieldFilterPredicate = dataNeedsFiltering ? ({ name }: Field) => fieldsNamesFilter.includes(name) : undefined;\n    let matchingFieldIndexes: number[] | undefined = undefined;\n\n    const getFullFrameResponseData = <T>(\n      messages: InternalStreamMessage[],\n      error?: DataQueryError\n    ): StreamingDataQueryResponse => {\n      matchingFieldIndexes = fieldFilterPredicate\n        ? this.frameBuffer.getMatchingFieldIndexes(fieldFilterPredicate)\n        : undefined;\n\n      if (!shouldSendLastPacketOnly) {\n        return {\n          key: subKey,\n          state: error ? LoadingState.Error : LoadingState.Streaming,\n          data: [\n            {\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer),\n            },\n          ],\n          error,\n        };\n      }\n\n      if (error) {\n        // send empty frame with error\n        return {\n          key: subKey,\n          state: LoadingState.Error,\n          data: [\n            {\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, { maxLength: 0 }),\n            },\n          ],\n          error,\n        };\n      }\n\n      if (!messages.length) {\n        console.warn(`expected to find at least one non error message ${messages.map(({ type }) => type)}`);\n        // send empty frame\n        return {\n          key: subKey,\n          state: LoadingState.Streaming,\n          data: [\n            {\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, { maxLength: 0 }),\n            },\n          ],\n          error,\n        };\n      }\n\n      return {\n        key: subKey,\n        state: LoadingState.Streaming,\n        data: [\n          {\n            type: StreamingResponseDataType.FullFrame,\n            frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, {\n              maxLength: this.frameBuffer.packetInfo.length,\n            }),\n          },\n        ],\n        error,\n      };\n    };\n\n    const getNewValuesSameSchemaResponseData = (\n      messages: Array<InternalStreamMessage<InternalStreamMessageType.NewValuesSameSchema>>\n    ): StreamingDataQueryResponse => {\n      const lastMessage = messages.length ? messages[messages.length - 1] : undefined;\n      const values =\n        shouldSendLastPacketOnly && lastMessage\n          ? lastMessage.values\n          : reduceNewValuesSameSchemaMessages(messages).values;\n\n      const filteredValues = matchingFieldIndexes\n        ? values.filter((v, i) => (matchingFieldIndexes as number[]).includes(i))\n        : values;\n\n      return {\n        key: subKey,\n        state: LoadingState.Streaming,\n        data: [\n          {\n            type: StreamingResponseDataType.NewValuesSameSchema,\n            values: filteredValues,\n          },\n        ],\n      };\n    };\n\n    let shouldSendFullFrame = true;\n    const transformedInternalStream = this.stream.pipe(\n      bufferIfNot(this.deps.subscriberReadiness),\n      map((messages, i) => {\n        const errors = filterMessages(messages, InternalStreamMessageType.Error);\n        const lastError = errors.length ? errors[errors.length - 1].error : undefined;\n\n        if (shouldSendFullFrame) {\n          shouldSendFullFrame = false;\n          return getFullFrameResponseData(messages, lastError);\n        }\n\n        if (errors.length) {\n          // send the latest frame with the last error, discard everything else\n          return getFullFrameResponseData(messages, lastError);\n        }\n\n        const schemaChanged = messages.some((n) => n.type === InternalStreamMessageType.ChangedSchema);\n        if (schemaChanged) {\n          // send the latest frame, discard intermediate appends\n          return getFullFrameResponseData(messages, undefined);\n        }\n\n        const newValueSameSchemaMessages = filterMessages(messages, InternalStreamMessageType.NewValuesSameSchema);\n        if (newValueSameSchemaMessages.length !== messages.length) {\n          console.warn(`unsupported message type ${messages.map(({ type }) => type)}`);\n        }\n\n        return getNewValuesSameSchemaResponseData(newValueSameSchemaMessages);\n      })\n    );\n\n    return new Observable<StreamingDataQueryResponse>((subscriber) => {\n      const sub = transformedInternalStream.subscribe({\n        next: (n) => {\n          subscriber.next(n);\n        },\n        error: (err) => {\n          subscriber.error(err);\n        },\n        complete: () => {\n          subscriber.complete();\n        },\n      });\n\n      return () => {\n        // TODO: potentially resize (downsize) the buffer on unsubscribe\n        sub.unsubscribe();\n        if (!this.stream.observed) {\n          this.clearShutdownTimeout();\n          this.shutdownTimeoutId = setTimeout(this.shutdownIfNoSubscribers, this.deps.shutdownDelayInMs);\n        }\n      };\n    });\n  };\n}\n","import {\n  Subscription,\n  JoinContext,\n  LeaveContext,\n  PublicationContext,\n  SubscriptionErrorContext,\n  SubscribedContext,\n} from 'centrifuge';\nimport { Subject, of, Observable } from 'rxjs';\n\nimport {\n  LiveChannelStatusEvent,\n  LiveChannelEvent,\n  LiveChannelEventType,\n  LiveChannelConnectionState,\n  LiveChannelPresenceStatus,\n  LiveChannelAddress,\n  DataFrameJSON,\n  isValidLiveChannelAddress,\n} from '@grafana/data';\n\n/**\n * Internal class that maps Centrifuge support to GrafanaLive\n */\nexport class CentrifugeLiveChannel<T = any> {\n  readonly currentStatus: LiveChannelStatusEvent;\n\n  readonly opened = Date.now();\n  readonly id: string;\n  readonly addr: LiveChannelAddress;\n\n  readonly stream = new Subject<LiveChannelEvent<T>>();\n\n  // Hold on to the last header with schema\n  lastMessageWithSchema?: DataFrameJSON;\n\n  subscription?: Subscription;\n  shutdownCallback?: () => void;\n  initalized?: boolean;\n\n  constructor(id: string, addr: LiveChannelAddress) {\n    this.id = id;\n    this.addr = addr;\n    this.currentStatus = {\n      type: LiveChannelEventType.Status,\n      id,\n      timestamp: this.opened,\n      state: LiveChannelConnectionState.Pending,\n    };\n    if (!isValidLiveChannelAddress(addr)) {\n      this.currentStatus.state = LiveChannelConnectionState.Invalid;\n      this.currentStatus.error = 'invalid channel address';\n    }\n  }\n\n  // This should only be called when centrifuge is connected\n  initalize(): void {\n    if (this.initalized) {\n      throw new Error('Channel already initalized: ' + this.id);\n    }\n    this.initalized = true;\n\n    this.subscription!.on('publication', (ctx: PublicationContext) => {\n      try {\n        if (ctx.data) {\n          if (ctx.data.schema) {\n            this.lastMessageWithSchema = ctx.data as DataFrameJSON;\n          }\n\n          this.stream.next({\n            type: LiveChannelEventType.Message,\n            message: ctx.data,\n          });\n        }\n\n        // Clear any error messages\n        if (this.currentStatus.error) {\n          this.currentStatus.timestamp = Date.now();\n          delete this.currentStatus.error;\n          this.sendStatus();\n        }\n      } catch (err) {\n        console.log('publish error', this.addr, err);\n        this.currentStatus.error = err;\n        this.currentStatus.timestamp = Date.now();\n        this.sendStatus();\n      }\n    })\n      .on('error', (ctx: SubscriptionErrorContext) => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.error = ctx.error.message;\n        this.sendStatus();\n      })\n      .on('subscribed', (ctx: SubscribedContext) => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Connected;\n        delete this.currentStatus.error;\n\n        if (ctx.data?.schema) {\n          this.lastMessageWithSchema = ctx.data as DataFrameJSON;\n        }\n        this.sendStatus(ctx.data);\n      })\n      .on('unsubscribed', () => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Disconnected;\n        this.sendStatus();\n      })\n      .on('subscribing', () => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Connecting;\n        this.sendStatus();\n      })\n      .on('join', (ctx: JoinContext) => {\n        this.stream.next({ type: LiveChannelEventType.Join, user: ctx.info.user });\n      })\n      .on('leave', (ctx: LeaveContext) => {\n        this.stream.next({ type: LiveChannelEventType.Leave, user: ctx.info.user });\n      });\n  }\n\n  private sendStatus(message?: any) {\n    const copy = { ...this.currentStatus };\n    if (message) {\n      copy.message = message;\n    }\n    this.stream.next(copy);\n  }\n\n  disconnectIfNoListeners = () => {\n    const count = this.stream.observers.length;\n    if (count === 0) {\n      this.disconnect();\n    }\n  };\n\n  /**\n   * Get the stream of events and\n   */\n  getStream() {\n    return new Observable((subscriber) => {\n      const initialMessage = { ...this.currentStatus };\n      if (this.lastMessageWithSchema?.schema) {\n        // send just schema instead of schema+data to avoid having data gaps\n        initialMessage.message = { schema: this.lastMessageWithSchema?.schema };\n      }\n\n      subscriber.next({ ...this.currentStatus, message: this.lastMessageWithSchema });\n\n      const sub = this.stream.subscribe(subscriber);\n      return () => {\n        sub.unsubscribe();\n        const count = this.stream.observers.length;\n\n        // Wait 1/4 second to fully disconnect\n        if (count === 0) {\n          setTimeout(this.disconnectIfNoListeners, 250);\n        }\n      };\n    }) as Observable<LiveChannelEvent<T>>;\n  }\n\n  /**\n   * This is configured by the server when the config supports presence\n   */\n  async getPresence(): Promise<LiveChannelPresenceStatus> {\n    if (!this.subscription) {\n      return Promise.reject('not subscribed');\n    }\n\n    return this.subscription!.presence().then((v) => {\n      return {\n        users: Object.keys(v.clients),\n      };\n    });\n  }\n\n  /**\n   * This will close and terminate all streams for this channel\n   */\n  disconnect() {\n    this.currentStatus.state = LiveChannelConnectionState.Shutdown;\n    this.currentStatus.timestamp = Date.now();\n\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n      this.subscription.removeAllListeners(); // they keep all listeners attached after unsubscribe\n      this.subscription = undefined;\n    }\n\n    this.stream.complete();\n\n    this.stream.next({ ...this.currentStatus });\n    this.stream.complete();\n\n    if (this.shutdownCallback) {\n      this.shutdownCallback();\n    }\n  }\n\n  shutdownWithError(err: string) {\n    this.currentStatus.error = err;\n    this.sendStatus();\n    this.disconnect();\n  }\n}\n\nexport function getErrorChannel<TMessage>(msg: string, id: string, addr: LiveChannelAddress) {\n  return {\n    id,\n    opened: Date.now(),\n    addr,\n\n    // return an error\n    getStream: () =>\n      of({\n        type: LiveChannelEventType.Status,\n        id,\n        timestamp: Date.now(),\n        state: LiveChannelConnectionState.Invalid,\n        error: msg,\n      }),\n\n    // already disconnected\n    disconnect: () => {},\n  };\n}\n","import { Centrifuge, State } from 'centrifuge';\nimport { BehaviorSubject, Observable, share, startWith } from 'rxjs';\n\nimport {\n  DataQueryError,\n  DataQueryResponse,\n  LiveChannelAddress,\n  LiveChannelConnectionState,\n  LiveChannelId,\n  toLiveChannelId,\n} from '@grafana/data';\nimport { FetchResponse } from '@grafana/runtime/src/services/backendSrv';\nimport {\n  GrafanaLiveSrv,\n  LiveDataStreamOptions,\n  LiveQueryDataOptions,\n  StreamingFrameAction,\n  StreamingFrameOptions,\n} from '@grafana/runtime/src/services/live';\nimport { BackendDataSourceResponse } from '@grafana/runtime/src/utils/queryResponse';\n\nimport { StreamingResponseData } from '../data/utils';\n\nimport { LiveDataStream } from './LiveDataStream';\nimport { CentrifugeLiveChannel } from './channel';\n\nexport type CentrifugeSrvDeps = {\n  grafanaAuthToken: string | null;\n  appUrl: string;\n  orgId: number;\n  orgRole: string;\n  sessionId: string;\n  liveEnabled: boolean;\n  dataStreamSubscriberReadiness: Observable<boolean>;\n};\n\nexport type StreamingDataQueryResponse = Omit<DataQueryResponse, 'data'> & { data: [StreamingResponseData] };\n\nexport type CentrifugeSrv = Omit<GrafanaLiveSrv, 'publish' | 'getDataStream' | 'getQueryData'> & {\n  getDataStream: (options: LiveDataStreamOptions) => Observable<StreamingDataQueryResponse>;\n  getQueryData: (\n    options: LiveQueryDataOptions\n  ) => Promise<\n    | { data: BackendDataSourceResponse | undefined }\n    | FetchResponse<BackendDataSourceResponse | undefined>\n    | DataQueryError\n  >;\n};\n\nexport type DataStreamSubscriptionKey = string;\n\nconst defaultStreamingFrameOptions: Readonly<StreamingFrameOptions> = {\n  maxLength: 100,\n  maxDelta: Infinity,\n  action: StreamingFrameAction.Append,\n};\n\nconst dataStreamShutdownDelayInMs = 5000;\n\nexport class CentrifugeService implements CentrifugeSrv {\n  readonly open = new Map<string, CentrifugeLiveChannel>();\n  private readonly liveDataStreamByChannelId: Record<LiveChannelId, LiveDataStream> = {};\n  readonly centrifuge: Centrifuge;\n  readonly connectionState: BehaviorSubject<boolean>;\n  readonly connectionBlocker: Promise<void>;\n  private readonly dataStreamSubscriberReadiness: Observable<boolean>;\n\n  constructor(private deps: CentrifugeSrvDeps) {\n    this.dataStreamSubscriberReadiness = deps.dataStreamSubscriberReadiness.pipe(share(), startWith(true));\n\n    let liveUrl = `${deps.appUrl.replace(/^http/, 'ws')}/api/live/ws`;\n\n    const token = deps.grafanaAuthToken;\n    if (token !== null && token !== '') {\n      liveUrl += '?auth_token=' + token;\n    }\n\n    this.centrifuge = new Centrifuge(liveUrl, {\n      timeout: 30000,\n    });\n    // orgRole is set when logged in *or* anonymous users can use grafana\n    if (deps.liveEnabled && deps.orgRole !== '') {\n      this.centrifuge.connect(); // do connection\n    }\n    this.connectionState = new BehaviorSubject<boolean>(this.centrifuge.state === State.Connected);\n    this.connectionBlocker = new Promise<void>((resolve) => {\n      if (this.centrifuge.state === State.Connected) {\n        return resolve();\n      }\n      const connectListener = () => {\n        resolve();\n        this.centrifuge.removeListener('connected', connectListener);\n      };\n      this.centrifuge.addListener('connected', connectListener);\n    });\n\n    // Register global listeners\n    this.centrifuge.on('connected', this.onConnect);\n    this.centrifuge.on('connecting', this.onDisconnect);\n    this.centrifuge.on('disconnected', this.onDisconnect);\n    this.centrifuge.on('publication', this.onServerSideMessage);\n  }\n\n  //----------------------------------------------------------\n  // Internal functions\n  //----------------------------------------------------------\n\n  private onConnect = (context: any) => {\n    this.connectionState.next(true);\n  };\n\n  private onDisconnect = (context: any) => {\n    this.connectionState.next(false);\n  };\n\n  private onServerSideMessage = (context: any) => {\n    console.log('Publication from server-side channel', context);\n  };\n\n  /**\n   * Get a channel.  If the scope, namespace, or path is invalid, a shutdown\n   * channel will be returned with an error state indicated in its status\n   */\n  private getChannel<TMessage>(addr: LiveChannelAddress): CentrifugeLiveChannel<TMessage> {\n    const id = `${this.deps.orgId}/${addr.scope}/${addr.namespace}/${addr.path}`;\n    let channel = this.open.get(id);\n    if (channel != null) {\n      return channel;\n    }\n\n    channel = new CentrifugeLiveChannel(id, addr);\n    if (channel.currentStatus.state === LiveChannelConnectionState.Invalid) {\n      return channel;\n    }\n    channel.shutdownCallback = () => {\n      this.open.delete(id);\n\n      // without a call to `removeSubscription`, the subscription will remain in centrifuge's internal registry\n      this.centrifuge.removeSubscription(this.centrifuge.getSubscription(id));\n    };\n    this.open.set(id, channel);\n\n    // Initialize the channel in the background\n    this.initChannel(channel).catch((err) => {\n      if (channel) {\n        channel.currentStatus.state = LiveChannelConnectionState.Invalid;\n        channel.shutdownWithError(err);\n      }\n      this.open.delete(id);\n    });\n\n    // return the not-yet initialized channel\n    return channel;\n  }\n\n  private async initChannel(channel: CentrifugeLiveChannel): Promise<void> {\n    if (this.centrifuge.state !== State.Connected) {\n      await this.connectionBlocker;\n    }\n    const subscription = this.centrifuge.newSubscription(channel.id, {\n      data: channel.addr.data,\n    });\n    channel.subscription = subscription;\n    channel.initalize();\n    subscription.subscribe();\n    return;\n  }\n\n  //----------------------------------------------------------\n  // Exported functions\n  //----------------------------------------------------------\n\n  /**\n   * Listen for changes to the connection state\n   */\n  getConnectionState = () => {\n    return this.connectionState.asObservable();\n  };\n\n  /**\n   * Watch for messages in a channel\n   */\n  getStream: CentrifugeSrv['getStream'] = <T>(address: LiveChannelAddress) => {\n    return this.getChannel<T>(address).getStream();\n  };\n\n  private createSubscriptionKey = (options: LiveDataStreamOptions): DataStreamSubscriptionKey =>\n    options.key ?? `xstr/${streamCounter++}`;\n\n  private getLiveDataStream = (options: LiveDataStreamOptions): LiveDataStream => {\n    const channelId = toLiveChannelId(options.addr);\n    const existingStream = this.liveDataStreamByChannelId[channelId];\n\n    if (existingStream) {\n      return existingStream;\n    }\n\n    const channel = this.getChannel(options.addr);\n    this.liveDataStreamByChannelId[channelId] = new LiveDataStream({\n      channelId,\n      onShutdown: () => {\n        delete this.liveDataStreamByChannelId[channelId];\n      },\n      liveEventsObservable: channel.getStream(),\n      subscriberReadiness: this.dataStreamSubscriberReadiness,\n      defaultStreamingFrameOptions,\n      shutdownDelayInMs: dataStreamShutdownDelayInMs,\n    });\n    return this.liveDataStreamByChannelId[channelId];\n  };\n  /**\n   * Connect to a channel and return results as DataFrames\n   */\n  getDataStream: CentrifugeSrv['getDataStream'] = (options) => {\n    const subscriptionKey = this.createSubscriptionKey(options);\n\n    const stream = this.getLiveDataStream(options);\n    return stream.get(options, subscriptionKey);\n  };\n\n  /**\n   * Executes a query over the live websocket. Query response can contain live channels we can subscribe to for further updates\n   *\n   * Since the initial request and subscription are on the same socket, this will support HA setups\n   */\n  getQueryData: CentrifugeSrv['getQueryData'] = async (options) => {\n    if (this.centrifuge.state !== State.Connected) {\n      await this.connectionBlocker;\n    }\n    return this.centrifuge.rpc('grafana.query', options.body);\n  };\n\n  /**\n   * For channels that support presence, this will request the current state from the server.\n   *\n   * Join and leave messages will be sent to the open stream\n   */\n  getPresence: CentrifugeSrv['getPresence'] = (address) => {\n    return this.getChannel(address).getPresence();\n  };\n}\n\n// This is used to give a unique key for each stream.  The actual value does not matter\nlet streamCounter = 0;\n","import * as comlink from 'comlink';\nimport { Subscriber } from 'rxjs';\n\n// Observers, ie. functions passed to `observable.subscribe(...)`, are converted to a subclass of `Subscriber` before they are sent to the source Observable.\n// The conversion happens internally in the RxJS library - this transfer handler is catches them and wraps them with a proxy\nconst subscriberTransferHandler: any = {\n  canHandle(value: any): boolean {\n    return value && value instanceof Subscriber;\n  },\n\n  serialize(value: Function): [MessagePort, Transferable[]] {\n    const obj = comlink.proxy(value);\n\n    const { port1, port2 } = new MessageChannel();\n\n    comlink.expose(obj, port1);\n\n    return [port2, [port2]];\n  },\n\n  deserialize(value: MessagePort): comlink.Remote<MessagePort> {\n    value.start();\n\n    return comlink.wrap<MessagePort>(value);\n  },\n};\ncomlink.transferHandlers.set('SubscriberHandler', subscriberTransferHandler);\n","import { Labels } from '@grafana/data';\n\n/** replace labels in a string.  Used for loki+prometheus legend formats */\nexport function renderLegendFormat(aliasPattern: string, aliasData: Labels): string {\n  const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n  return aliasPattern.replace(aliasRegex, (_, g1) => (aliasData[g1] ? aliasData[g1] : g1));\n}\n"],"names":["fieldIndexComparer","field","reverse","values","type","FieldType","numericIndexComparer","stringIndexComparer","booleanIndexComparer","timeIndexComparer","naturalIndexComparer","timeComparer","a","b","isNumber","numericComparer","dateTime","isBefore","falsyComparer","stringComparer","localeCompare","booleanComparer","vA","get","vB","fieldTypeMatcher","id","FieldMatcherID","name","description","defaultOptions","frame","allFrames","getOptionsDisplayText","numericMatcher","timeMatcher","getFieldTypeMatchers","MatcherID","FrameMatcherID","ValueMatcherID","refIdMacher","pattern","regex","stringToJsRegex","test","refId","getRefIdMatchers","firstFieldMatcher","fields","firstTimeFieldMatcher","find","f","getSimpleFieldMatchers","isEqualValueMatcher","options","valueIndex","value","isApplicable","getDefaultOptions","isNotEqualValueMatcher","getEqualValueMatchers","isNullValueMatcher","isNotNullValueMatcher","getNullValueMatchers","isGreaterValueMatcher","isNaN","isGreaterOrEqualValueMatcher","isLowerValueMatcher","isLowerOrEqualValueMatcher","getNumericValueMatchers","isBetweenValueMatcher","from","to","getRangeValueMatchers","regexValueMatcher","RegExp","getRegexValueMatcher","DataTransformerID","Registry","constructor","init","Map","this","initialized","Error","getIfExists","initialize","byId","ext","register","sort","v","list","map","selectOptions","current","filter","select","currentOptions","ordered","excludeFromPicker","option","label","state","PluginState","push","Object","ids","found","isEmpty","length","has","set","aliasIds","alias","ArrayVector","FunctionalVector","buffer","super","add","index","toArray","toJSON","SortedVector","source","order","vectorToArray","getOrderArray","arr","Array","i","toDataQueryError","err","error","message","String","data","status","statusText","InternalStreamMessageType","filterMessages","packets","p","LiveDataStream","deps","ReplaySubject","stream","complete","liveEventsSubscription","unsubscribe","onShutdown","observed","shutdown","console","log","channelId","next","evt","isLiveChannelMessageEvent","process","liveChannelStatusEvent","isLiveChannelStatusEvent","LiveChannelConnectionState","msg","frameBuffer","schemaChanged","ChangedSchema","NewValuesSameSchema","getValuesFromLastPacket","bufferOptions","needsResizing","resize","hasAtLeastOnePacket","shutdownTimeoutId","clearTimeout","undefined","subKey","clearShutdownTimeout","getStreamingFrameOptions","resizeBuffer","prepareInternalStreamForNewSubscription","shouldSendLastPacketOnly","action","StreamingFrameAction","fieldsNamesFilter","fieldFilterPredicate","includes","matchingFieldIndexes","getFullFrameResponseData","messages","getMatchingFieldIndexes","key","LoadingState","StreamingResponseDataType","serialize","maxLength","packetInfo","warn","getNewValuesSameSchemaResponseData","lastMessage","reduce","acc","j","filteredValues","shouldSendFullFrame","transformedInternalStream","pipe","canEmitObservable","subscriberReadiness","Observable","subscriber","canEmit","emitBuffer","canEmitSub","subscribe","val","sourceSub","errors","lastError","some","n","newValueSameSchemaMessages","sub","setTimeout","shutdownIfNoSubscribers","shutdownDelayInMs","StreamingDataFrame","defaultStreamingFrameOptions","liveEventsObservable","onError","onComplete","onNext","CentrifugeLiveChannel","addr","Date","now","Subject","observers","disconnect","currentStatus","LiveChannelEventType","timestamp","opened","isValidLiveChannelAddress","initalize","initalized","subscription","on","ctx","schema","lastMessageWithSchema","sendStatus","user","info","copy","getStream","initialMessage","disconnectIfNoListeners","async","presence","then","users","keys","clients","Promise","reject","removeAllListeners","shutdownCallback","shutdownWithError","maxDelta","Infinity","CentrifugeService","context","connectionState","asObservable","address","getChannel","streamCounter","toLiveChannelId","existingStream","liveDataStreamByChannelId","channel","dataStreamSubscriberReadiness","subscriptionKey","createSubscriptionKey","getLiveDataStream","centrifuge","State","connectionBlocker","rpc","body","getPresence","share","startWith","liveUrl","appUrl","replace","token","grafanaAuthToken","Centrifuge","timeout","liveEnabled","orgRole","connect","BehaviorSubject","resolve","connectListener","removeListener","addListener","onConnect","onDisconnect","onServerSideMessage","orgId","scope","namespace","path","open","delete","removeSubscription","getSubscription","initChannel","catch","newSubscription","subscriberTransferHandler","canHandle","Subscriber","obj","comlink","port1","port2","MessageChannel","deserialize","start","renderLegendFormat","aliasPattern","aliasData","_","g1"],"sourceRoot":""}